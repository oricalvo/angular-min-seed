/**
 * core-js 2.4.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * Â© 2016 Denis Pushkarev
 */
!function(__e, __g, undefined){
'use strict';
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(50);
	__webpack_require__(51);
	__webpack_require__(52);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(58);
	__webpack_require__(59);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(77);
	__webpack_require__(78);
	__webpack_require__(79);
	__webpack_require__(83);
	__webpack_require__(86);
	__webpack_require__(87);
	__webpack_require__(88);
	__webpack_require__(89);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(105);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(109);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(126);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(173);
	__webpack_require__(174);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(179);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(185);
	__webpack_require__(187);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(193);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(203);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(209);
	__webpack_require__(210);
	__webpack_require__(211);
	__webpack_require__(212);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(220);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(231);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	module.exports = __webpack_require__(288);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(2)
	  , has            = __webpack_require__(3)
	  , DESCRIPTORS    = __webpack_require__(4)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(16)
	  , META           = __webpack_require__(20).KEY
	  , $fails         = __webpack_require__(5)
	  , shared         = __webpack_require__(21)
	  , setToStringTag = __webpack_require__(22)
	  , uid            = __webpack_require__(17)
	  , wks            = __webpack_require__(23)
	  , wksExt         = __webpack_require__(24)
	  , wksDefine      = __webpack_require__(25)
	  , keyOf          = __webpack_require__(27)
	  , enumKeys       = __webpack_require__(40)
	  , isArray        = __webpack_require__(43)
	  , anObject       = __webpack_require__(10)
	  , toIObject      = __webpack_require__(30)
	  , toPrimitive    = __webpack_require__(14)
	  , createDesc     = __webpack_require__(15)
	  , _create        = __webpack_require__(44)
	  , gOPNExt        = __webpack_require__(47)
	  , $GOPD          = __webpack_require__(49)
	  , $DP            = __webpack_require__(9)
	  , $keys          = __webpack_require__(28)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(48).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(42).f  = $propertyIsEnumerable;
	  __webpack_require__(41).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(26)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(8)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 2 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 3 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(5)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(2)
	  , core      = __webpack_require__(7)
	  , hide      = __webpack_require__(8)
	  , redefine  = __webpack_require__(16)
	  , ctx       = __webpack_require__(18)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(9)
	  , createDesc = __webpack_require__(15);
	module.exports = __webpack_require__(4) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(10)
	  , IE8_DOM_DEFINE = __webpack_require__(12)
	  , toPrimitive    = __webpack_require__(14)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(4) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(11);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(4) && !__webpack_require__(5)(function(){
	  return Object.defineProperty(__webpack_require__(13)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(11)
	  , document = __webpack_require__(2).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(11);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(2)
	  , hide      = __webpack_require__(8)
	  , has       = __webpack_require__(3)
	  , SRC       = __webpack_require__(17)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);

	__webpack_require__(7).inspectSource = function(it){
	  return $toString.call(it);
	};

	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(19);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(17)('meta')
	  , isObject = __webpack_require__(11)
	  , has      = __webpack_require__(3)
	  , setDesc  = __webpack_require__(9).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(5)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(9).f
	  , has = __webpack_require__(3)
	  , TAG = __webpack_require__(23)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(21)('wks')
	  , uid        = __webpack_require__(17)
	  , Symbol     = __webpack_require__(2).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(23);

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(2)
	  , core           = __webpack_require__(7)
	  , LIBRARY        = __webpack_require__(26)
	  , wksExt         = __webpack_require__(24)
	  , defineProperty = __webpack_require__(9).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(28)
	  , toIObject = __webpack_require__(30);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(29)
	  , enumBugKeys = __webpack_require__(39);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(3)
	  , toIObject    = __webpack_require__(30)
	  , arrayIndexOf = __webpack_require__(34)(false)
	  , IE_PROTO     = __webpack_require__(38)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(31)
	  , defined = __webpack_require__(33);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(32);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(30)
	  , toLength  = __webpack_require__(35)
	  , toIndex   = __webpack_require__(37);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(36)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(36)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(21)('keys')
	  , uid    = __webpack_require__(17);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(28)
	  , gOPS    = __webpack_require__(41)
	  , pIE     = __webpack_require__(42);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 42 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(32);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(10)
	  , dPs         = __webpack_require__(45)
	  , enumBugKeys = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(38)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(13)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(46).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(9)
	  , anObject = __webpack_require__(10)
	  , getKeys  = __webpack_require__(28);

	module.exports = __webpack_require__(4) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2).document && document.documentElement;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(30)
	  , gOPN      = __webpack_require__(48).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(29)
	  , hiddenKeys = __webpack_require__(39).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(42)
	  , createDesc     = __webpack_require__(15)
	  , toIObject      = __webpack_require__(30)
	  , toPrimitive    = __webpack_require__(14)
	  , has            = __webpack_require__(3)
	  , IE8_DOM_DEFINE = __webpack_require__(12)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(4) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(4), 'Object', {defineProperty: __webpack_require__(9).f});

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(4), 'Object', {defineProperties: __webpack_require__(45)});

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(30)
	  , $getOwnPropertyDescriptor = __webpack_require__(49).f;

	__webpack_require__(53)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(7)
	  , fails   = __webpack_require__(5);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(44)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(56)
	  , $getPrototypeOf = __webpack_require__(57);

	__webpack_require__(53)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(33);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(3)
	  , toObject    = __webpack_require__(56)
	  , IE_PROTO    = __webpack_require__(38)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(56)
	  , $keys    = __webpack_require__(28);

	__webpack_require__(53)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(53)('getOwnPropertyNames', function(){
	  return __webpack_require__(47).f;
	});

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(11)
	  , meta     = __webpack_require__(20).onFreeze;

	__webpack_require__(53)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(11)
	  , meta     = __webpack_require__(20).onFreeze;

	__webpack_require__(53)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(11)
	  , meta     = __webpack_require__(20).onFreeze;

	__webpack_require__(53)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(11);

	__webpack_require__(53)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(11);

	__webpack_require__(53)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(11);

	__webpack_require__(53)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(67)});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(28)
	  , gOPS     = __webpack_require__(41)
	  , pIE      = __webpack_require__(42)
	  , toObject = __webpack_require__(56)
	  , IObject  = __webpack_require__(31)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(5)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {is: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(71).set});

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(11)
	  , anObject = __webpack_require__(10);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(18)(Function.call, __webpack_require__(49).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(73)
	  , test    = {};
	test[__webpack_require__(23)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(16)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(32)
	  , TAG = __webpack_require__(23)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(6);

	$export($export.P, 'Function', {bind: __webpack_require__(75)});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(19)
	  , isObject   = __webpack_require__(11)
	  , invoke     = __webpack_require__(76)
	  , arraySlice = [].slice
	  , factories  = {};

	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(9).f
	  , createDesc = __webpack_require__(15)
	  , has        = __webpack_require__(3)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';

	var isExtensible = Object.isExtensible || function(){
	  return true;
	};

	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(4) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(11)
	  , getPrototypeOf = __webpack_require__(57)
	  , HAS_INSTANCE   = __webpack_require__(23)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(9).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(2)
	  , has               = __webpack_require__(3)
	  , cof               = __webpack_require__(32)
	  , inheritIfRequired = __webpack_require__(80)
	  , toPrimitive       = __webpack_require__(14)
	  , fails             = __webpack_require__(5)
	  , gOPN              = __webpack_require__(48).f
	  , gOPD              = __webpack_require__(49).f
	  , dP                = __webpack_require__(9).f
	  , $trim             = __webpack_require__(81).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(44)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(4) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(16)(global, NUMBER, $Number);
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(11)
	  , setPrototypeOf = __webpack_require__(71).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	  , defined = __webpack_require__(33)
	  , fails   = __webpack_require__(5)
	  , spaces  = __webpack_require__(82)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');

	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};

	module.exports = exporter;

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(6)
	  , toInteger    = __webpack_require__(36)
	  , aNumberValue = __webpack_require__(84)
	  , repeat       = __webpack_require__(85)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';

	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};

	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(5)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(32);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(36)
	  , defined   = __webpack_require__(33);

	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(6)
	  , $fails       = __webpack_require__(5)
	  , aNumberValue = __webpack_require__(84)
	  , $toPrecision = 1..toPrecision;

	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(6);

	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(6)
	  , _isFinite = __webpack_require__(2).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(6);

	$export($export.S, 'Number', {isInteger: __webpack_require__(90)});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(11)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(6);

	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(6)
	  , isInteger = __webpack_require__(90)
	  , abs       = Math.abs;

	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(6);

	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(6);

	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(6)
	  , $parseFloat = __webpack_require__(96);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(2).parseFloat
	  , $trim       = __webpack_require__(81).trim;

	module.exports = 1 / $parseFloat(__webpack_require__(82) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(6)
	  , $parseInt = __webpack_require__(98);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(2).parseInt
	  , $trim     = __webpack_require__(81).trim
	  , ws        = __webpack_require__(82)
	  , hex       = /^[\-+]?0[xX]/;

	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(6)
	  , $parseInt = __webpack_require__(98);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(6)
	  , $parseFloat = __webpack_require__(96);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(6)
	  , log1p   = __webpack_require__(102)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;

	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 102 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(6)
	  , $asinh  = Math.asinh;

	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(6)
	  , $atanh  = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(6)
	  , sign    = __webpack_require__(106);

	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 106 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(6)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(6)
	  , $expm1  = __webpack_require__(110);

	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 110 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(6)
	  , sign      = __webpack_require__(106)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);

	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};


	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
	var $export = __webpack_require__(6)
	  , abs     = Math.abs;

	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(6)
	  , $imul   = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(5)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {log1p: __webpack_require__(102)});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {sign: __webpack_require__(106)});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(6)
	  , expm1   = __webpack_require__(110)
	  , exp     = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(5)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(6)
	  , expm1   = __webpack_require__(110)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(6)
	  , toIndex        = __webpack_require__(37)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(6)
	  , toIObject = __webpack_require__(30)
	  , toLength  = __webpack_require__(35);

	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(81)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $at     = __webpack_require__(125)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(36)
	  , defined   = __webpack_require__(33);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(6)
	  , toLength  = __webpack_require__(35)
	  , context   = __webpack_require__(127)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];

	$export($export.P + $export.F * __webpack_require__(129)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(128)
	  , defined  = __webpack_require__(33);

	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(11)
	  , cof      = __webpack_require__(32)
	  , MATCH    = __webpack_require__(23)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(23)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(6)
	  , context  = __webpack_require__(127)
	  , INCLUDES = 'includes';

	$export($export.P + $export.F * __webpack_require__(129)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);

	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(85)
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(6)
	  , toLength    = __webpack_require__(35)
	  , context     = __webpack_require__(127)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];

	$export($export.P + $export.F * __webpack_require__(129)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(125)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(134)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(26)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(16)
	  , hide           = __webpack_require__(8)
	  , has            = __webpack_require__(3)
	  , Iterators      = __webpack_require__(135)
	  , $iterCreate    = __webpack_require__(136)
	  , setToStringTag = __webpack_require__(22)
	  , getPrototypeOf = __webpack_require__(57)
	  , ITERATOR       = __webpack_require__(23)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(44)
	  , descriptor     = __webpack_require__(15)
	  , setToStringTag = __webpack_require__(22)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(8)(IteratorPrototype, __webpack_require__(23)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(138)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	  , fails   = __webpack_require__(5)
	  , defined = __webpack_require__(33)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(138)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(138)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(138)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(138)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(138)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(138)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(138)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(138)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(138)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(138)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(138)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(138)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(6);

	$export($export.S, 'Array', {isArray: __webpack_require__(43)});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(18)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(56)
	  , call           = __webpack_require__(153)
	  , isArrayIter    = __webpack_require__(154)
	  , toLength       = __webpack_require__(35)
	  , createProperty = __webpack_require__(155)
	  , getIterFn      = __webpack_require__(156);

	$export($export.S + $export.F * !__webpack_require__(157)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(10);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(135)
	  , ITERATOR   = __webpack_require__(23)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(9)
	  , createDesc      = __webpack_require__(15);

	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(73)
	  , ITERATOR  = __webpack_require__(23)('iterator')
	  , Iterators = __webpack_require__(135);
	module.exports = __webpack_require__(7).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(23)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(6)
	  , createProperty = __webpack_require__(155);

	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(5)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(6)
	  , toIObject = __webpack_require__(30)
	  , arrayJoin = [].join;

	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(31) != Object || !__webpack_require__(160)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(5);

	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(6)
	  , html       = __webpack_require__(46)
	  , cof        = __webpack_require__(32)
	  , toIndex    = __webpack_require__(37)
	  , toLength   = __webpack_require__(35)
	  , arraySlice = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(5)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(6)
	  , aFunction = __webpack_require__(19)
	  , toObject  = __webpack_require__(56)
	  , fails     = __webpack_require__(5)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];

	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(160)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(6)
	  , $forEach = __webpack_require__(164)(0)
	  , STRICT   = __webpack_require__(160)([].forEach, true);

	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(18)
	  , IObject  = __webpack_require__(31)
	  , toObject = __webpack_require__(56)
	  , toLength = __webpack_require__(35)
	  , asc      = __webpack_require__(165);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(166);

	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(11)
	  , isArray  = __webpack_require__(43)
	  , SPECIES  = __webpack_require__(23)('species');

	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $map    = __webpack_require__(164)(1);

	$export($export.P + $export.F * !__webpack_require__(160)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $filter = __webpack_require__(164)(2);

	$export($export.P + $export.F * !__webpack_require__(160)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $some   = __webpack_require__(164)(3);

	$export($export.P + $export.F * !__webpack_require__(160)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $every  = __webpack_require__(164)(4);

	$export($export.P + $export.F * !__webpack_require__(160)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $reduce = __webpack_require__(172);

	$export($export.P + $export.F * !__webpack_require__(160)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(19)
	  , toObject  = __webpack_require__(56)
	  , IObject   = __webpack_require__(31)
	  , toLength  = __webpack_require__(35);

	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(6)
	  , $reduce = __webpack_require__(172);

	$export($export.P + $export.F * !__webpack_require__(160)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(6)
	  , $indexOf      = __webpack_require__(34)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(160)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(6)
	  , toIObject     = __webpack_require__(30)
	  , toInteger     = __webpack_require__(36)
	  , toLength      = __webpack_require__(35)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(160)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(6);

	$export($export.P, 'Array', {copyWithin: __webpack_require__(177)});

	__webpack_require__(178)('copyWithin');

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(56)
	  , toIndex  = __webpack_require__(37)
	  , toLength = __webpack_require__(35);

	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(23)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(8)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(6);

	$export($export.P, 'Array', {fill: __webpack_require__(180)});

	__webpack_require__(178)('fill');

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(56)
	  , toIndex  = __webpack_require__(37)
	  , toLength = __webpack_require__(35);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(6)
	  , $find   = __webpack_require__(164)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(178)(KEY);

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(6)
	  , $find   = __webpack_require__(164)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(178)(KEY);

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(178)
	  , step             = __webpack_require__(184)
	  , Iterators        = __webpack_require__(135)
	  , toIObject        = __webpack_require__(30);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(134)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(186)('Array');

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(2)
	  , dP          = __webpack_require__(9)
	  , DESCRIPTORS = __webpack_require__(4)
	  , SPECIES     = __webpack_require__(23)('species');

	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(2)
	  , inheritIfRequired = __webpack_require__(80)
	  , dP                = __webpack_require__(9).f
	  , gOPN              = __webpack_require__(48).f
	  , isRegExp          = __webpack_require__(128)
	  , $flags            = __webpack_require__(188)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;

	if(__webpack_require__(4) && (!CORRECT_NEW || __webpack_require__(5)(function(){
	  re2[__webpack_require__(23)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(16)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(186)('RegExp');

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(10);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(190);
	var anObject    = __webpack_require__(10)
	  , $flags      = __webpack_require__(188)
	  , DESCRIPTORS = __webpack_require__(4)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];

	var define = function(fn){
	  __webpack_require__(16)(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(5)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(4) && /./g.flags != 'g')__webpack_require__(9).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(188)
	});

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(192)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(8)
	  , redefine = __webpack_require__(16)
	  , fails    = __webpack_require__(5)
	  , defined  = __webpack_require__(33)
	  , wks      = __webpack_require__(23);

	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(192)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(192)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(192)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(128)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(26)
	  , global             = __webpack_require__(2)
	  , ctx                = __webpack_require__(18)
	  , classof            = __webpack_require__(73)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(11)
	  , aFunction          = __webpack_require__(19)
	  , anInstance         = __webpack_require__(197)
	  , forOf              = __webpack_require__(198)
	  , speciesConstructor = __webpack_require__(199)
	  , task               = __webpack_require__(200).set
	  , microtask          = __webpack_require__(201)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;

	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(23)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(202)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(22)($Promise, PROMISE);
	__webpack_require__(186)(PROMISE);
	Wrapper = __webpack_require__(7)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(157)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 197 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(18)
	  , call        = __webpack_require__(153)
	  , isArrayIter = __webpack_require__(154)
	  , anObject    = __webpack_require__(10)
	  , toLength    = __webpack_require__(35)
	  , getIterFn   = __webpack_require__(156)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(10)
	  , aFunction = __webpack_require__(19)
	  , SPECIES   = __webpack_require__(23)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(18)
	  , invoke             = __webpack_require__(76)
	  , html               = __webpack_require__(46)
	  , cel                = __webpack_require__(13)
	  , global             = __webpack_require__(2)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(32)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(2)
	  , macrotask = __webpack_require__(200).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(32)(process) == 'process';

	module.exports = function(){
	  var head, last, notify;

	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };

	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(16);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(204);

	// 23.1 Map Objects
	module.exports = __webpack_require__(205)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(9).f
	  , create      = __webpack_require__(44)
	  , redefineAll = __webpack_require__(202)
	  , ctx         = __webpack_require__(18)
	  , anInstance  = __webpack_require__(197)
	  , defined     = __webpack_require__(33)
	  , forOf       = __webpack_require__(198)
	  , $iterDefine = __webpack_require__(134)
	  , step        = __webpack_require__(184)
	  , setSpecies  = __webpack_require__(186)
	  , DESCRIPTORS = __webpack_require__(4)
	  , fastKey     = __webpack_require__(20).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(2)
	  , $export           = __webpack_require__(6)
	  , redefine          = __webpack_require__(16)
	  , redefineAll       = __webpack_require__(202)
	  , meta              = __webpack_require__(20)
	  , forOf             = __webpack_require__(198)
	  , anInstance        = __webpack_require__(197)
	  , isObject          = __webpack_require__(11)
	  , fails             = __webpack_require__(5)
	  , $iterDetect       = __webpack_require__(157)
	  , setToStringTag    = __webpack_require__(22)
	  , inheritIfRequired = __webpack_require__(80);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(204);

	// 23.2 Set Objects
	module.exports = __webpack_require__(205)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(164)(0)
	  , redefine     = __webpack_require__(16)
	  , meta         = __webpack_require__(20)
	  , assign       = __webpack_require__(67)
	  , weak         = __webpack_require__(208)
	  , isObject     = __webpack_require__(11)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;

	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(205)('WeakMap', wrapper, methods, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(202)
	  , getWeak           = __webpack_require__(20).getWeak
	  , anObject          = __webpack_require__(10)
	  , isObject          = __webpack_require__(11)
	  , anInstance        = __webpack_require__(197)
	  , forOf             = __webpack_require__(198)
	  , createArrayMethod = __webpack_require__(164)
	  , $has              = __webpack_require__(3)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(208);

	// 23.4 WeakSet Objects
	__webpack_require__(205)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(6)
	  , aFunction = __webpack_require__(19)
	  , anObject  = __webpack_require__(10)
	  , rApply    = (__webpack_require__(2).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(5)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(6)
	  , create     = __webpack_require__(44)
	  , aFunction  = __webpack_require__(19)
	  , anObject   = __webpack_require__(10)
	  , isObject   = __webpack_require__(11)
	  , fails      = __webpack_require__(5)
	  , bind       = __webpack_require__(75)
	  , rConstruct = (__webpack_require__(2).Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});

	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(9)
	  , $export     = __webpack_require__(6)
	  , anObject    = __webpack_require__(10)
	  , toPrimitive = __webpack_require__(14);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(5)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(6)
	  , gOPD     = __webpack_require__(49).f
	  , anObject = __webpack_require__(10);

	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(6)
	  , anObject = __webpack_require__(10);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(136)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});

	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(49)
	  , getPrototypeOf = __webpack_require__(57)
	  , has            = __webpack_require__(3)
	  , $export        = __webpack_require__(6)
	  , isObject       = __webpack_require__(11)
	  , anObject       = __webpack_require__(10);

	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}

	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(49)
	  , $export  = __webpack_require__(6)
	  , anObject = __webpack_require__(10);

	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(6)
	  , getProto = __webpack_require__(57)
	  , anObject = __webpack_require__(10);

	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(6);

	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(6)
	  , anObject      = __webpack_require__(10)
	  , $isExtensible = Object.isExtensible;

	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(6);

	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(221)});

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(48)
	  , gOPS     = __webpack_require__(41)
	  , anObject = __webpack_require__(10)
	  , Reflect  = __webpack_require__(2).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(6)
	  , anObject           = __webpack_require__(10)
	  , $preventExtensions = Object.preventExtensions;

	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(9)
	  , gOPD           = __webpack_require__(49)
	  , getPrototypeOf = __webpack_require__(57)
	  , has            = __webpack_require__(3)
	  , $export        = __webpack_require__(6)
	  , createDesc     = __webpack_require__(15)
	  , anObject       = __webpack_require__(10)
	  , isObject       = __webpack_require__(11);

	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(6)
	  , setProto = __webpack_require__(71);

	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(6);

	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(6)
	  , toObject    = __webpack_require__(56)
	  , toPrimitive = __webpack_require__(14);

	$export($export.P + $export.F * __webpack_require__(5)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(6)
	  , fails   = __webpack_require__(5)
	  , getTime = Date.prototype.getTime;

	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(16)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(23)('toPrimitive')
	  , proto        = Date.prototype;

	if(!(TO_PRIMITIVE in proto))__webpack_require__(8)(proto, TO_PRIMITIVE, __webpack_require__(230));

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(10)
	  , toPrimitive = __webpack_require__(14)
	  , NUMBER      = 'number';

	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(6)
	  , $typed       = __webpack_require__(232)
	  , buffer       = __webpack_require__(233)
	  , anObject     = __webpack_require__(10)
	  , toIndex      = __webpack_require__(37)
	  , toLength     = __webpack_require__(35)
	  , isObject     = __webpack_require__(11)
	  , ArrayBuffer  = __webpack_require__(2).ArrayBuffer
	  , speciesConstructor = __webpack_require__(199)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';

	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});

	$export($export.P + $export.U + $export.F * __webpack_require__(5)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	__webpack_require__(186)(ARRAY_BUFFER);

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2)
	  , hide   = __webpack_require__(8)
	  , uid    = __webpack_require__(17)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(2)
	  , DESCRIPTORS    = __webpack_require__(4)
	  , LIBRARY        = __webpack_require__(26)
	  , $typed         = __webpack_require__(232)
	  , hide           = __webpack_require__(8)
	  , redefineAll    = __webpack_require__(202)
	  , fails          = __webpack_require__(5)
	  , anInstance     = __webpack_require__(197)
	  , toInteger      = __webpack_require__(36)
	  , toLength       = __webpack_require__(35)
	  , gOPN           = __webpack_require__(48).f
	  , dP             = __webpack_require__(9).f
	  , arrayFill      = __webpack_require__(180)
	  , setToStringTag = __webpack_require__(22)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};

	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};

	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};

	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};

	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};

	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	$export($export.G + $export.W + $export.F * !__webpack_require__(232).ABV, {
	  DataView: __webpack_require__(233).DataView
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(4)){
	  var LIBRARY             = __webpack_require__(26)
	    , global              = __webpack_require__(2)
	    , fails               = __webpack_require__(5)
	    , $export             = __webpack_require__(6)
	    , $typed              = __webpack_require__(232)
	    , $buffer             = __webpack_require__(233)
	    , ctx                 = __webpack_require__(18)
	    , anInstance          = __webpack_require__(197)
	    , propertyDesc        = __webpack_require__(15)
	    , hide                = __webpack_require__(8)
	    , redefineAll         = __webpack_require__(202)
	    , toInteger           = __webpack_require__(36)
	    , toLength            = __webpack_require__(35)
	    , toIndex             = __webpack_require__(37)
	    , toPrimitive         = __webpack_require__(14)
	    , has                 = __webpack_require__(3)
	    , same                = __webpack_require__(69)
	    , classof             = __webpack_require__(73)
	    , isObject            = __webpack_require__(11)
	    , toObject            = __webpack_require__(56)
	    , isArrayIter         = __webpack_require__(154)
	    , create              = __webpack_require__(44)
	    , getPrototypeOf      = __webpack_require__(57)
	    , gOPN                = __webpack_require__(48).f
	    , getIterFn           = __webpack_require__(156)
	    , uid                 = __webpack_require__(17)
	    , wks                 = __webpack_require__(23)
	    , createArrayMethod   = __webpack_require__(164)
	    , createArrayIncludes = __webpack_require__(34)
	    , speciesConstructor  = __webpack_require__(199)
	    , ArrayIterators      = __webpack_require__(183)
	    , Iterators           = __webpack_require__(135)
	    , $iterDetect         = __webpack_require__(157)
	    , setSpecies          = __webpack_require__(186)
	    , arrayFill           = __webpack_require__(180)
	    , arrayCopyWithin     = __webpack_require__(177)
	    , $DP                 = __webpack_require__(9)
	    , $GOPD               = __webpack_require__(49)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';

	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });

	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };

	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };

	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };

	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });

	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });

	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });

	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});

	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(236)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(6)
	  , $includes = __webpack_require__(34)(true);

	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	__webpack_require__(178)('includes');

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(6)
	  , $at     = __webpack_require__(125)(true);

	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(6)
	  , $pad    = __webpack_require__(248);

	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(35)
	  , repeat   = __webpack_require__(85)
	  , defined  = __webpack_require__(33);

	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(6)
	  , $pad    = __webpack_require__(248);

	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(81)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(81)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(6)
	  , defined     = __webpack_require__(33)
	  , toLength    = __webpack_require__(35)
	  , isRegExp    = __webpack_require__(128)
	  , getFlags    = __webpack_require__(188)
	  , RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};

	__webpack_require__(136)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});

	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(25)('asyncIterator');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(25)('observable');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(6)
	  , ownKeys        = __webpack_require__(221)
	  , toIObject      = __webpack_require__(30)
	  , gOPD           = __webpack_require__(49)
	  , createProperty = __webpack_require__(155);

	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(6)
	  , $values = __webpack_require__(257)(false);

	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(28)
	  , toIObject = __webpack_require__(30)
	  , isEnum    = __webpack_require__(42).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(6)
	  , $entries = __webpack_require__(257)(true);

	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(6)
	  , toObject        = __webpack_require__(56)
	  , aFunction       = __webpack_require__(19)
	  , $defineProperty = __webpack_require__(9);

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(26)|| !__webpack_require__(5)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(2)[K];
	});

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(6)
	  , toObject        = __webpack_require__(56)
	  , aFunction       = __webpack_require__(19)
	  , $defineProperty = __webpack_require__(9);

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(6)
	  , toObject                 = __webpack_require__(56)
	  , toPrimitive              = __webpack_require__(14)
	  , getPrototypeOf           = __webpack_require__(57)
	  , getOwnPropertyDescriptor = __webpack_require__(49).f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(6)
	  , toObject                 = __webpack_require__(56)
	  , toPrimitive              = __webpack_require__(14)
	  , getPrototypeOf           = __webpack_require__(57)
	  , getOwnPropertyDescriptor = __webpack_require__(49).f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);

	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(265)('Map')});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(73)
	  , from    = __webpack_require__(266);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(198);

	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);

	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(265)('Set')});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(6);

	$export($export.S, 'System', {global: __webpack_require__(2)});

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(6)
	  , cof     = __webpack_require__(32);

	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(6);

	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(275)
	  , anObject                  = __webpack_require__(10)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(203)
	  , $export = __webpack_require__(6)
	  , shared  = __webpack_require__(21)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(207)));

	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};

	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(275)
	  , anObject               = __webpack_require__(10)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;

	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(275)
	  , anObject               = __webpack_require__(10)
	  , getPrototypeOf         = __webpack_require__(57)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;

	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(206)
	  , from                    = __webpack_require__(266)
	  , metadata                = __webpack_require__(275)
	  , anObject                = __webpack_require__(10)
	  , getPrototypeOf          = __webpack_require__(57)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;

	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(275)
	  , anObject               = __webpack_require__(10)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;

	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(275)
	  , anObject                = __webpack_require__(10)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;

	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(275)
	  , anObject               = __webpack_require__(10)
	  , getPrototypeOf         = __webpack_require__(57)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;

	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(275)
	  , anObject               = __webpack_require__(10)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;

	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(275)
	  , anObject                  = __webpack_require__(10)
	  , aFunction                 = __webpack_require__(19)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(6)
	  , microtask = __webpack_require__(201)()
	  , process   = __webpack_require__(2).process
	  , isNode    = __webpack_require__(32)(process) == 'process';

	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(6)
	  , global      = __webpack_require__(2)
	  , core        = __webpack_require__(7)
	  , microtask   = __webpack_require__(201)()
	  , OBSERVABLE  = __webpack_require__(23)('observable')
	  , aFunction   = __webpack_require__(19)
	  , anObject    = __webpack_require__(10)
	  , anInstance  = __webpack_require__(197)
	  , redefineAll = __webpack_require__(202)
	  , hide        = __webpack_require__(8)
	  , forOf       = __webpack_require__(198)
	  , RETURN      = forOf.RETURN;

	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};

	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};

	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});

	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});

	hide($Observable.prototype, OBSERVABLE, function(){ return this; });

	$export($export.G, {Observable: $Observable});

	__webpack_require__(186)('Observable');

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	  , $task   = __webpack_require__(200);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(183)
	  , redefine      = __webpack_require__(16)
	  , global        = __webpack_require__(2)
	  , hide          = __webpack_require__(8)
	  , Iterators     = __webpack_require__(135)
	  , wks           = __webpack_require__(23)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(2)
	  , $export    = __webpack_require__(6)
	  , invoke     = __webpack_require__(76)
	  , partial    = __webpack_require__(289)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(290)
	  , invoke    = __webpack_require__(76)
	  , aFunction = __webpack_require__(19);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2);

/***/ }
/******/ ]);
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = __e;
// RequireJS export
else if(typeof define == 'function' && define.amd)define(function(){return __e});
// Export to global object
else __g.core = __e;
}(1, 1);
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	__webpack_require__(1);
	var event_target_1 = __webpack_require__(2);
	var define_property_1 = __webpack_require__(4);
	var register_element_1 = __webpack_require__(5);
	var property_descriptor_1 = __webpack_require__(6);
	var timers_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(3);
	var set = 'set';
	var clear = 'clear';
	var blockingMethods = ['alert', 'prompt', 'confirm'];
	var _global = typeof window == 'undefined' ? global : window;
	timers_1.patchTimer(_global, set, clear, 'Timeout');
	timers_1.patchTimer(_global, set, clear, 'Interval');
	timers_1.patchTimer(_global, set, clear, 'Immediate');
	timers_1.patchTimer(_global, 'request', 'cancel', 'AnimationFrame');
	timers_1.patchTimer(_global, 'mozRequest', 'mozCancel', 'AnimationFrame');
	timers_1.patchTimer(_global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
	for (var i = 0; i < blockingMethods.length; i++) {
	    var name = blockingMethods[i];
	    utils_1.patchMethod(_global, name, function (delegate, symbol, name) {
	        return function (s, args) {
	            return Zone.current.run(delegate, _global, args, name);
	        };
	    });
	}
	event_target_1.eventTargetPatch(_global);
	property_descriptor_1.propertyDescriptorPatch(_global);
	utils_1.patchClass('MutationObserver');
	utils_1.patchClass('WebKitMutationObserver');
	utils_1.patchClass('FileReader');
	define_property_1.propertyPatch();
	register_element_1.registerElementPatch(_global);
	// Treat XMLHTTPRequest as a macrotask.
	patchXHR(_global);
	var XHR_TASK = utils_1.zoneSymbol('xhrTask');
	function patchXHR(window) {
	    function findPendingTask(target) {
	        var pendingTask = target[XHR_TASK];
	        return pendingTask;
	    }
	    function scheduleTask(task) {
	        var data = task.data;
	        data.target.addEventListener('readystatechange', function () {
	            if (data.target.readyState === XMLHttpRequest.DONE) {
	                if (!data.aborted) {
	                    task.invoke();
	                }
	            }
	        });
	        var storedTask = data.target[XHR_TASK];
	        if (!storedTask) {
	            data.target[XHR_TASK] = task;
	        }
	        setNative.apply(data.target, data.args);
	        return task;
	    }
	    function placeholderCallback() {
	    }
	    function clearTask(task) {
	        var data = task.data;
	        // Note - ideally, we would call data.target.removeEventListener here, but it's too late
	        // to prevent it from firing. So instead, we store info for the event listener.
	        data.aborted = true;
	        return clearNative.apply(data.target, data.args);
	    }
	    var setNative = utils_1.patchMethod(window.XMLHttpRequest.prototype, 'send', function () { return function (self, args) {
	        var zone = Zone.current;
	        var options = {
	            target: self,
	            isPeriodic: false,
	            delay: null,
	            args: args,
	            aborted: false
	        };
	        return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);
	    }; });
	    var clearNative = utils_1.patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) { return function (self, args) {
	        var task = findPendingTask(self);
	        if (task && typeof task.type == 'string') {
	            // If the XHR has already completed, do nothing.
	            if (task.cancelFn == null) {
	                return;
	            }
	            task.zone.cancelTask(task);
	        }
	        // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no task to cancel. Do nothing.
	    }; });
	}
	/// GEO_LOCATION
	if (_global['navigator'] && _global['navigator'].geolocation) {
	    utils_1.patchPrototype(_global['navigator'].geolocation, [
	        'getCurrentPosition',
	        'watchPosition'
	    ]);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {;
	;
	var Zone = (function (global) {
	    if (global.Zone) {
	        throw new Error('Zone already loaded.');
	    }
	    var Zone = (function () {
	        function Zone(parent, zoneSpec) {
	            this._properties = null;
	            this._parent = parent;
	            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
	            this._properties = zoneSpec && zoneSpec.properties || {};
	            this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
	        }
	        Object.defineProperty(Zone, "current", {
	            get: function () { return _currentZone; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(Zone, "currentTask", {
	            get: function () { return _currentTask; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(Zone.prototype, "parent", {
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(Zone.prototype, "name", {
	            get: function () { return this._name; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Zone.prototype.get = function (key) {
	            var zone = this.getZoneWith(key);
	            if (zone)
	                return zone._properties[key];
	        };
	        Zone.prototype.getZoneWith = function (key) {
	            var current = this;
	            while (current) {
	                if (current._properties.hasOwnProperty(key)) {
	                    return current;
	                }
	                current = current._parent;
	            }
	            return null;
	        };
	        Zone.prototype.fork = function (zoneSpec) {
	            if (!zoneSpec)
	                throw new Error('ZoneSpec required!');
	            return this._zoneDelegate.fork(this, zoneSpec);
	        };
	        Zone.prototype.wrap = function (callback, source) {
	            if (typeof callback !== 'function') {
	                throw new Error('Expecting function got: ' + callback);
	            }
	            var _callback = this._zoneDelegate.intercept(this, callback, source);
	            var zone = this;
	            return function () {
	                return zone.runGuarded(_callback, this, arguments, source);
	            };
	        };
	        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {
	            if (applyThis === void 0) { applyThis = null; }
	            if (applyArgs === void 0) { applyArgs = null; }
	            if (source === void 0) { source = null; }
	            var oldZone = _currentZone;
	            _currentZone = this;
	            try {
	                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	            }
	            finally {
	                _currentZone = oldZone;
	            }
	        };
	        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {
	            if (applyThis === void 0) { applyThis = null; }
	            if (applyArgs === void 0) { applyArgs = null; }
	            if (source === void 0) { source = null; }
	            var oldZone = _currentZone;
	            _currentZone = this;
	            try {
	                try {
	                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                _currentZone = oldZone;
	            }
	        };
	        Zone.prototype.runTask = function (task, applyThis, applyArgs) {
	            task.runCount++;
	            if (task.zone != this)
	                throw new Error('A task can only be run in the zone which created it! (Creation: ' +
	                    task.zone.name + '; Execution: ' + this.name + ')');
	            var previousTask = _currentTask;
	            _currentTask = task;
	            var oldZone = _currentZone;
	            _currentZone = this;
	            try {
	                if (task.type == 'macroTask' && task.data && !task.data.isPeriodic) {
	                    task.cancelFn = null;
	                }
	                try {
	                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                _currentZone = oldZone;
	                _currentTask = previousTask;
	            }
	        };
	        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {
	            return this._zoneDelegate.scheduleTask(this, new ZoneTask('microTask', this, source, callback, data, customSchedule, null));
	        };
	        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {
	            return this._zoneDelegate.scheduleTask(this, new ZoneTask('macroTask', this, source, callback, data, customSchedule, customCancel));
	        };
	        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {
	            return this._zoneDelegate.scheduleTask(this, new ZoneTask('eventTask', this, source, callback, data, customSchedule, customCancel));
	        };
	        Zone.prototype.cancelTask = function (task) {
	            var value = this._zoneDelegate.cancelTask(this, task);
	            task.runCount = -1;
	            task.cancelFn = null;
	            return value;
	        };
	        Zone.__symbol__ = __symbol__;
	        return Zone;
	    }());
	    ;
	    var ZoneDelegate = (function () {
	        function ZoneDelegate(zone, parentDelegate, zoneSpec) {
	            this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 };
	            this.zone = zone;
	            this._parentDelegate = parentDelegate;
	            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
	            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
	            this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
	            this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
	            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
	            this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
	            this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
	            this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
	            this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
	            this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
	            this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
	            this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
	            this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
	            this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
	            this._hasTaskZS = zoneSpec && (zoneSpec.onHasTask ? zoneSpec : parentDelegate._hasTaskZS);
	            this._hasTaskDlgt = zoneSpec && (zoneSpec.onHasTask ? parentDelegate : parentDelegate._hasTaskDlgt);
	        }
	        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {
	            return this._forkZS
	                ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec)
	                : new Zone(targetZone, zoneSpec);
	        };
	        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {
	            return this._interceptZS
	                ? this._interceptZS.onIntercept(this._interceptDlgt, this.zone, targetZone, callback, source)
	                : callback;
	        };
	        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {
	            return this._invokeZS
	                ? this._invokeZS.onInvoke(this._invokeDlgt, this.zone, targetZone, callback, applyThis, applyArgs, source)
	                : callback.apply(applyThis, applyArgs);
	        };
	        ZoneDelegate.prototype.handleError = function (targetZone, error) {
	            return this._handleErrorZS
	                ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this.zone, targetZone, error)
	                : true;
	        };
	        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {
	            try {
	                if (this._scheduleTaskZS) {
	                    return this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this.zone, targetZone, task);
	                }
	                else if (task.scheduleFn) {
	                    task.scheduleFn(task);
	                }
	                else if (task.type == 'microTask') {
	                    scheduleMicroTask(task);
	                }
	                else {
	                    throw new Error('Task is missing scheduleFn.');
	                }
	                return task;
	            }
	            finally {
	                if (targetZone == this.zone) {
	                    this._updateTaskCount(task.type, 1);
	                }
	            }
	        };
	        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {
	            try {
	                return this._invokeTaskZS
	                    ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this.zone, targetZone, task, applyThis, applyArgs)
	                    : task.callback.apply(applyThis, applyArgs);
	            }
	            finally {
	                if (targetZone == this.zone && (task.type != 'eventTask') && !(task.data && task.data.isPeriodic)) {
	                    this._updateTaskCount(task.type, -1);
	                }
	            }
	        };
	        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {
	            var value;
	            if (this._cancelTaskZS) {
	                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this.zone, targetZone, task);
	            }
	            else if (!task.cancelFn) {
	                throw new Error('Task does not support cancellation, or is already canceled.');
	            }
	            else {
	                value = task.cancelFn(task);
	            }
	            if (targetZone == this.zone) {
	                // this should not be in the finally block, because exceptions assume not canceled.
	                this._updateTaskCount(task.type, -1);
	            }
	            return value;
	        };
	        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {
	            return this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this.zone, targetZone, isEmpty);
	        };
	        ZoneDelegate.prototype._updateTaskCount = function (type, count) {
	            var counts = this._taskCounts;
	            var prev = counts[type];
	            var next = counts[type] = prev + count;
	            if (next < 0) {
	                throw new Error('More tasks executed then were scheduled.');
	            }
	            if (prev == 0 || next == 0) {
	                var isEmpty = {
	                    microTask: counts.microTask > 0,
	                    macroTask: counts.macroTask > 0,
	                    eventTask: counts.eventTask > 0,
	                    change: type
	                };
	                try {
	                    this.hasTask(this.zone, isEmpty);
	                }
	                finally {
	                    if (this._parentDelegate) {
	                        this._parentDelegate._updateTaskCount(type, count);
	                    }
	                }
	            }
	        };
	        return ZoneDelegate;
	    }());
	    var ZoneTask = (function () {
	        function ZoneTask(type, zone, source, callback, options, scheduleFn, cancelFn) {
	            this.runCount = 0;
	            this.type = type;
	            this.zone = zone;
	            this.source = source;
	            this.data = options;
	            this.scheduleFn = scheduleFn;
	            this.cancelFn = cancelFn;
	            this.callback = callback;
	            var self = this;
	            this.invoke = function () {
	                try {
	                    return zone.runTask(self, this, arguments);
	                }
	                finally {
	                    drainMicroTaskQueue();
	                }
	            };
	        }
	        ZoneTask.prototype.toString = function () {
	            if (this.data && typeof this.data.handleId !== 'undefined') {
	                return this.data.handleId;
	            }
	            else {
	                return this.toString();
	            }
	        };
	        return ZoneTask;
	    }());
	    function __symbol__(name) { return '__zone_symbol__' + name; }
	    ;
	    var symbolSetTimeout = __symbol__('setTimeout');
	    var symbolPromise = __symbol__('Promise');
	    var symbolThen = __symbol__('then');
	    var _currentZone = new Zone(null, null);
	    var _currentTask = null;
	    var _microTaskQueue = [];
	    var _isDrainingMicrotaskQueue = false;
	    var _uncaughtPromiseErrors = [];
	    var _drainScheduled = false;
	    function scheduleQueueDrain() {
	        if (!_drainScheduled && !_currentTask && _microTaskQueue.length == 0) {
	            // We are not running in Task, so we need to kickstart the microtask queue.
	            if (global[symbolPromise]) {
	                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);
	            }
	            else {
	                global[symbolSetTimeout](drainMicroTaskQueue, 0);
	            }
	        }
	    }
	    function scheduleMicroTask(task) {
	        scheduleQueueDrain();
	        _microTaskQueue.push(task);
	    }
	    function consoleError(e) {
	        var rejection = e && e.rejection;
	        if (rejection) {
	            console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
	        }
	        console.error(e);
	    }
	    function drainMicroTaskQueue() {
	        if (!_isDrainingMicrotaskQueue) {
	            _isDrainingMicrotaskQueue = true;
	            while (_microTaskQueue.length) {
	                var queue = _microTaskQueue;
	                _microTaskQueue = [];
	                for (var i = 0; i < queue.length; i++) {
	                    var task = queue[i];
	                    try {
	                        task.zone.runTask(task, null, null);
	                    }
	                    catch (e) {
	                        consoleError(e);
	                    }
	                }
	            }
	            while (_uncaughtPromiseErrors.length) {
	                var _loop_1 = function() {
	                    var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
	                    try {
	                        uncaughtPromiseError.zone.runGuarded(function () { throw uncaughtPromiseError; });
	                    }
	                    catch (e) {
	                        consoleError(e);
	                    }
	                };
	                while (_uncaughtPromiseErrors.length) {
	                    _loop_1();
	                }
	            }
	            _isDrainingMicrotaskQueue = false;
	            _drainScheduled = false;
	        }
	    }
	    function isThenable(value) {
	        return value && value.then;
	    }
	    function forwardResolution(value) { return value; }
	    function forwardRejection(rejection) { return ZoneAwarePromise.reject(rejection); }
	    var symbolState = __symbol__('state');
	    var symbolValue = __symbol__('value');
	    var source = 'Promise.then';
	    var UNRESOLVED = null;
	    var RESOLVED = true;
	    var REJECTED = false;
	    var REJECTED_NO_CATCH = 0;
	    function makeResolver(promise, state) {
	        return function (v) {
	            resolvePromise(promise, state, v);
	            // Do not return value or you will break the Promise spec.
	        };
	    }
	    function resolvePromise(promise, state, value) {
	        if (promise[symbolState] === UNRESOLVED) {
	            if (value instanceof ZoneAwarePromise && value[symbolState] !== UNRESOLVED) {
	                clearRejectedNoCatch(value);
	                resolvePromise(promise, value[symbolState], value[symbolValue]);
	            }
	            else if (isThenable(value)) {
	                value.then(makeResolver(promise, state), makeResolver(promise, false));
	            }
	            else {
	                promise[symbolState] = state;
	                var queue = promise[symbolValue];
	                promise[symbolValue] = value;
	                for (var i = 0; i < queue.length;) {
	                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
	                }
	                if (queue.length == 0 && state == REJECTED) {
	                    promise[symbolState] = REJECTED_NO_CATCH;
	                    try {
	                        throw new Error("Uncaught (in promise): " + value);
	                    }
	                    catch (e) {
	                        var error = e;
	                        error.rejection = value;
	                        error.promise = promise;
	                        error.zone = Zone.current;
	                        error.task = Zone.currentTask;
	                        _uncaughtPromiseErrors.push(error);
	                        scheduleQueueDrain();
	                    }
	                }
	            }
	        }
	        // Resolving an already resolved promise is a noop.
	        return promise;
	    }
	    function clearRejectedNoCatch(promise) {
	        if (promise[symbolState] === REJECTED_NO_CATCH) {
	            promise[symbolState] = REJECTED;
	            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
	                if (promise === _uncaughtPromiseErrors[i].promise) {
	                    _uncaughtPromiseErrors.splice(i, 1);
	                    break;
	                }
	            }
	        }
	    }
	    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
	        clearRejectedNoCatch(promise);
	        var delegate = promise[symbolState] ? onFulfilled || forwardResolution : onRejected || forwardRejection;
	        zone.scheduleMicroTask(source, function () {
	            try {
	                resolvePromise(chainPromise, true, zone.run(delegate, null, [promise[symbolValue]]));
	            }
	            catch (error) {
	                resolvePromise(chainPromise, false, error);
	            }
	        });
	    }
	    var ZoneAwarePromise = (function () {
	        function ZoneAwarePromise(executor) {
	            var promise = this;
	            if (!(promise instanceof ZoneAwarePromise)) {
	                throw new Error('Must be an instanceof Promise.');
	            }
	            promise[symbolState] = UNRESOLVED;
	            promise[symbolValue] = []; // queue;
	            try {
	                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
	            }
	            catch (e) {
	                resolvePromise(promise, false, e);
	            }
	        }
	        ZoneAwarePromise.resolve = function (value) {
	            return resolvePromise(new this(null), RESOLVED, value);
	        };
	        ZoneAwarePromise.reject = function (error) {
	            return resolvePromise(new this(null), REJECTED, error);
	        };
	        ZoneAwarePromise.race = function (values) {
	            var resolve;
	            var reject;
	            var promise = new this(function (res, rej) { resolve = res; reject = rej; });
	            function onResolve(value) { promise && (promise = null || resolve(value)); }
	            function onReject(error) { promise && (promise = null || reject(error)); }
	            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
	                var value = values_1[_i];
	                if (!isThenable(value)) {
	                    value = this.resolve(value);
	                }
	                value.then(onResolve, onReject);
	            }
	            return promise;
	        };
	        ZoneAwarePromise.all = function (values) {
	            var resolve;
	            var reject;
	            var promise = new this(function (res, rej) { resolve = res; reject = rej; });
	            var count = 0;
	            var resolvedValues = [];
	            function onReject(error) { promise && reject(error); promise = null; }
	            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
	                var value = values_2[_i];
	                if (!isThenable(value)) {
	                    value = this.resolve(value);
	                }
	                value.then((function (index) { return function (value) {
	                    resolvedValues[index] = value;
	                    count--;
	                    if (promise && !count) {
	                        resolve(resolvedValues);
	                    }
	                    promise == null;
	                }; })(count), onReject);
	                count++;
	            }
	            if (!count)
	                resolve(resolvedValues);
	            return promise;
	        };
	        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {
	            var chainPromise = new this.constructor(null);
	            var zone = Zone.current;
	            if (this[symbolState] == UNRESOLVED) {
	                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
	            }
	            else {
	                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
	            }
	            return chainPromise;
	        };
	        ZoneAwarePromise.prototype.catch = function (onRejected) {
	            return this.then(null, onRejected);
	        };
	        return ZoneAwarePromise;
	    }());
	    var NativePromise = global[__symbol__('Promise')] = global.Promise;
	    global.Promise = ZoneAwarePromise;
	    if (NativePromise) {
	        var NativePromiseProtototype = NativePromise.prototype;
	        var NativePromiseThen_1 = NativePromiseProtototype[__symbol__('then')]
	            = NativePromiseProtototype.then;
	        NativePromiseProtototype.then = function (onResolve, onReject) {
	            var nativePromise = this;
	            return new ZoneAwarePromise(function (resolve, reject) {
	                NativePromiseThen_1.call(nativePromise, resolve, reject);
	            }).then(onResolve, onReject);
	        };
	    }
	    // This is not part of public API, but it is usefull for tests, so we expose it.
	    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
	    return global.Zone = Zone;
	})(typeof window === 'undefined' ? global : window);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(3);
	var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';
	var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex'.split(',');
	var EVENT_TARGET = 'EventTarget';
	function eventTargetPatch(_global) {
	    var apis = [];
	    var isWtf = _global['wtf'];
	    if (isWtf) {
	        // Workaround for: https://github.com/google/tracing-framework/issues/555
	        apis = WTF_ISSUE_555.split(',').map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);
	    }
	    else if (_global[EVENT_TARGET]) {
	        apis.push(EVENT_TARGET);
	    }
	    else {
	        // Note: EventTarget is not available in all browsers,
	        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
	        apis = NO_EVENT_TARGET;
	    }
	    for (var i = 0; i < apis.length; i++) {
	        var type = _global[apis[i]];
	        utils_1.patchEventTargetMethods(type && type.prototype);
	    }
	}
	exports.eventTargetPatch = eventTargetPatch;


/***/ },
/* 3 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Suppress closure compiler errors about unknown 'process' variable
	 * @fileoverview
	 * @suppress {undefinedVars}
	 */
	"use strict";
	exports.zoneSymbol = Zone['__symbol__'];
	var _global = typeof window == 'undefined' ? global : window;
	function bindArguments(args, source) {
	    for (var i = args.length - 1; i >= 0; i--) {
	        if (typeof args[i] === 'function') {
	            args[i] = Zone.current.wrap(args[i], source + '_' + i);
	        }
	    }
	    return args;
	}
	exports.bindArguments = bindArguments;
	;
	function patchPrototype(prototype, fnNames) {
	    var source = prototype.constructor['name'];
	    var _loop_1 = function(i) {
	        var name_1 = fnNames[i];
	        var delegate = prototype[name_1];
	        if (delegate) {
	            prototype[name_1] = (function (delegate) {
	                return function () {
	                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));
	                };
	            })(delegate);
	        }
	    };
	    for (var i = 0; i < fnNames.length; i++) {
	        _loop_1(i);
	    }
	}
	exports.patchPrototype = patchPrototype;
	;
	exports.isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);
	exports.isNode = (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]');
	exports.isBrowser = !exports.isNode && !exports.isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);
	function patchProperty(obj, prop) {
	    var desc = Object.getOwnPropertyDescriptor(obj, prop) || {
	        enumerable: true,
	        configurable: true
	    };
	    // A property descriptor cannot have getter/setter and be writable
	    // deleting the writable and value properties avoids this error:
	    //
	    // TypeError: property descriptors must not specify a value or be writable when a
	    // getter or setter has been specified
	    delete desc.writable;
	    delete desc.value;
	    // substr(2) cuz 'onclick' -> 'click', etc
	    var eventName = prop.substr(2);
	    var _prop = '_' + prop;
	    desc.set = function (fn) {
	        if (this[_prop]) {
	            this.removeEventListener(eventName, this[_prop]);
	        }
	        if (typeof fn === 'function') {
	            var wrapFn = function (event) {
	                var result;
	                result = fn.apply(this, arguments);
	                if (result != undefined && !result)
	                    event.preventDefault();
	            };
	            this[_prop] = wrapFn;
	            this.addEventListener(eventName, wrapFn, false);
	        }
	        else {
	            this[_prop] = null;
	        }
	    };
	    desc.get = function () {
	        return this[_prop];
	    };
	    Object.defineProperty(obj, prop, desc);
	}
	exports.patchProperty = patchProperty;
	;
	function patchOnProperties(obj, properties) {
	    var onProperties = [];
	    for (var prop in obj) {
	        if (prop.substr(0, 2) == 'on') {
	            onProperties.push(prop);
	        }
	    }
	    for (var j = 0; j < onProperties.length; j++) {
	        patchProperty(obj, onProperties[j]);
	    }
	    if (properties) {
	        for (var i = 0; i < properties.length; i++) {
	            patchProperty(obj, 'on' + properties[i]);
	        }
	    }
	}
	exports.patchOnProperties = patchOnProperties;
	;
	var EVENT_TASKS = exports.zoneSymbol('eventTasks');
	var ADD_EVENT_LISTENER = 'addEventListener';
	var REMOVE_EVENT_LISTENER = 'removeEventListener';
	var SYMBOL_ADD_EVENT_LISTENER = exports.zoneSymbol(ADD_EVENT_LISTENER);
	var SYMBOL_REMOVE_EVENT_LISTENER = exports.zoneSymbol(REMOVE_EVENT_LISTENER);
	function findExistingRegisteredTask(target, handler, name, capture, remove) {
	    var eventTasks = target[EVENT_TASKS];
	    if (eventTasks) {
	        for (var i = 0; i < eventTasks.length; i++) {
	            var eventTask = eventTasks[i];
	            var data = eventTask.data;
	            if (data.handler === handler
	                && data.useCapturing === capture
	                && data.eventName === name) {
	                if (remove) {
	                    eventTasks.splice(i, 1);
	                }
	                return eventTask;
	            }
	        }
	    }
	    return null;
	}
	function attachRegisteredEvent(target, eventTask) {
	    var eventTasks = target[EVENT_TASKS];
	    if (!eventTasks) {
	        eventTasks = target[EVENT_TASKS] = [];
	    }
	    eventTasks.push(eventTask);
	}
	function scheduleEventListener(eventTask) {
	    var meta = eventTask.data;
	    attachRegisteredEvent(meta.target, eventTask);
	    return meta.target[SYMBOL_ADD_EVENT_LISTENER](meta.eventName, eventTask.invoke, meta.useCapturing);
	}
	function cancelEventListener(eventTask) {
	    var meta = eventTask.data;
	    findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, true);
	    meta.target[SYMBOL_REMOVE_EVENT_LISTENER](meta.eventName, eventTask.invoke, meta.useCapturing);
	}
	function zoneAwareAddEventListener(self, args) {
	    var eventName = args[0];
	    var handler = args[1];
	    var useCapturing = args[2] || false;
	    // - Inside a Web Worker, `this` is undefined, the context is `global`
	    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined
	    // see https://github.com/angular/zone.js/issues/190
	    var target = self || _global;
	    var delegate = null;
	    if (typeof handler == 'function') {
	        delegate = handler;
	    }
	    else if (handler && handler.handleEvent) {
	        delegate = function (event) { return handler.handleEvent(event); };
	    }
	    var validZoneHandler = false;
	    try {
	        // In cross site contexts (such as WebDriver frameworks like Selenium),
	        // accessing the handler object here will cause an exception to be thrown which
	        // will fail tests prematurely.
	        validZoneHandler = handler && handler.toString() === "[object FunctionWrapper]";
	    }
	    catch (e) {
	        // Returning nothing here is fine, because objects in a cross-site context are unusable
	        return;
	    }
	    // Ignore special listeners of IE11 & Edge dev tools, see https://github.com/angular/zone.js/issues/150
	    if (!delegate || validZoneHandler) {
	        return target[SYMBOL_ADD_EVENT_LISTENER](eventName, handler, useCapturing);
	    }
	    var eventTask = findExistingRegisteredTask(target, handler, eventName, useCapturing, false);
	    if (eventTask) {
	        // we already registered, so this will have noop.
	        return target[SYMBOL_ADD_EVENT_LISTENER](eventName, eventTask.invoke, useCapturing);
	    }
	    var zone = Zone.current;
	    var source = target.constructor['name'] + '.addEventListener:' + eventName;
	    var data = {
	        target: target,
	        eventName: eventName,
	        name: eventName,
	        useCapturing: useCapturing,
	        handler: handler
	    };
	    zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);
	}
	function zoneAwareRemoveEventListener(self, args) {
	    var eventName = args[0];
	    var handler = args[1];
	    var useCapturing = args[2] || false;
	    // - Inside a Web Worker, `this` is undefined, the context is `global`
	    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined
	    // see https://github.com/angular/zone.js/issues/190
	    var target = self || _global;
	    var eventTask = findExistingRegisteredTask(target, handler, eventName, useCapturing, true);
	    if (eventTask) {
	        eventTask.zone.cancelTask(eventTask);
	    }
	    else {
	        target[SYMBOL_REMOVE_EVENT_LISTENER](eventName, handler, useCapturing);
	    }
	}
	function patchEventTargetMethods(obj) {
	    if (obj && obj.addEventListener) {
	        patchMethod(obj, ADD_EVENT_LISTENER, function () { return zoneAwareAddEventListener; });
	        patchMethod(obj, REMOVE_EVENT_LISTENER, function () { return zoneAwareRemoveEventListener; });
	        return true;
	    }
	    else {
	        return false;
	    }
	}
	exports.patchEventTargetMethods = patchEventTargetMethods;
	;
	var originalInstanceKey = exports.zoneSymbol('originalInstance');
	// wrap some native API on `window`
	function patchClass(className) {
	    var OriginalClass = _global[className];
	    if (!OriginalClass)
	        return;
	    _global[className] = function () {
	        var a = bindArguments(arguments, className);
	        switch (a.length) {
	            case 0:
	                this[originalInstanceKey] = new OriginalClass();
	                break;
	            case 1:
	                this[originalInstanceKey] = new OriginalClass(a[0]);
	                break;
	            case 2:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
	                break;
	            case 3:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
	                break;
	            case 4:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
	                break;
	            default: throw new Error('Arg list too long.');
	        }
	    };
	    var instance = new OriginalClass(function () { });
	    var prop;
	    for (prop in instance) {
	        // https://bugs.webkit.org/show_bug.cgi?id=44721
	        if (className === 'XMLHttpRequest' && prop === 'responseBlob')
	            continue;
	        (function (prop) {
	            if (typeof instance[prop] === 'function') {
	                _global[className].prototype[prop] = function () {
	                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
	                };
	            }
	            else {
	                Object.defineProperty(_global[className].prototype, prop, {
	                    set: function (fn) {
	                        if (typeof fn === 'function') {
	                            this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);
	                        }
	                        else {
	                            this[originalInstanceKey][prop] = fn;
	                        }
	                    },
	                    get: function () {
	                        return this[originalInstanceKey][prop];
	                    }
	                });
	            }
	        }(prop));
	    }
	    for (prop in OriginalClass) {
	        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
	            _global[className][prop] = OriginalClass[prop];
	        }
	    }
	}
	exports.patchClass = patchClass;
	;
	function createNamedFn(name, delegate) {
	    try {
	        return (Function('f', "return function " + name + "(){return f(this, arguments)}"))(delegate);
	    }
	    catch (e) {
	        // if we fail, we must be CSP, just return delegate.
	        return function () {
	            return delegate(this, arguments);
	        };
	    }
	}
	exports.createNamedFn = createNamedFn;
	function patchMethod(target, name, patchFn) {
	    var proto = target;
	    while (proto && !proto.hasOwnProperty(name)) {
	        proto = Object.getPrototypeOf(proto);
	    }
	    if (!proto && target[name]) {
	        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
	        proto = target;
	    }
	    var delegateName = exports.zoneSymbol(name);
	    var delegate;
	    if (proto && !(delegate = proto[delegateName])) {
	        delegate = proto[delegateName] = proto[name];
	        proto[name] = createNamedFn(name, patchFn(delegate, delegateName, name));
	    }
	    return delegate;
	}
	exports.patchMethod = patchMethod;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(3);
	/*
	 * This is necessary for Chrome and Chrome mobile, to enable
	 * things like redefining `createdCallback` on an element.
	 */
	var _defineProperty = Object.defineProperty;
	var _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var _create = Object.create;
	var unconfigurablesKey = utils_1.zoneSymbol('unconfigurables');
	function propertyPatch() {
	    Object.defineProperty = function (obj, prop, desc) {
	        if (isUnconfigurable(obj, prop)) {
	            throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
	        }
	        var originalConfigurableFlag = desc.configurable;
	        if (prop !== 'prototype') {
	            desc = rewriteDescriptor(obj, prop, desc);
	        }
	        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
	    };
	    Object.defineProperties = function (obj, props) {
	        Object.keys(props).forEach(function (prop) {
	            Object.defineProperty(obj, prop, props[prop]);
	        });
	        return obj;
	    };
	    Object.create = function (obj, proto) {
	        if (typeof proto === 'object' && !Object.isFrozen(proto)) {
	            Object.keys(proto).forEach(function (prop) {
	                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
	            });
	        }
	        return _create(obj, proto);
	    };
	    Object.getOwnPropertyDescriptor = function (obj, prop) {
	        var desc = _getOwnPropertyDescriptor(obj, prop);
	        if (isUnconfigurable(obj, prop)) {
	            desc.configurable = false;
	        }
	        return desc;
	    };
	}
	exports.propertyPatch = propertyPatch;
	;
	function _redefineProperty(obj, prop, desc) {
	    var originalConfigurableFlag = desc.configurable;
	    desc = rewriteDescriptor(obj, prop, desc);
	    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
	}
	exports._redefineProperty = _redefineProperty;
	;
	function isUnconfigurable(obj, prop) {
	    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
	}
	function rewriteDescriptor(obj, prop, desc) {
	    desc.configurable = true;
	    if (!desc.configurable) {
	        if (!obj[unconfigurablesKey]) {
	            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });
	        }
	        obj[unconfigurablesKey][prop] = true;
	    }
	    return desc;
	}
	function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
	    try {
	        return _defineProperty(obj, prop, desc);
	    }
	    catch (e) {
	        if (desc.configurable) {
	            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's retry with the original flag value
	            if (typeof originalConfigurableFlag == 'undefined') {
	                delete desc.configurable;
	            }
	            else {
	                desc.configurable = originalConfigurableFlag;
	            }
	            return _defineProperty(obj, prop, desc);
	        }
	        else {
	            throw e;
	        }
	    }
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var define_property_1 = __webpack_require__(4);
	var utils_1 = __webpack_require__(3);
	function registerElementPatch(_global) {
	    if (!utils_1.isBrowser || !('registerElement' in _global.document)) {
	        return;
	    }
	    var _registerElement = document.registerElement;
	    var callbacks = [
	        'createdCallback',
	        'attachedCallback',
	        'detachedCallback',
	        'attributeChangedCallback'
	    ];
	    document.registerElement = function (name, opts) {
	        if (opts && opts.prototype) {
	            callbacks.forEach(function (callback) {
	                var source = 'Document.registerElement::' + callback;
	                if (opts.prototype.hasOwnProperty(callback)) {
	                    var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
	                    if (descriptor && descriptor.value) {
	                        descriptor.value = Zone.current.wrap(descriptor.value, source);
	                        define_property_1._redefineProperty(opts.prototype, callback, descriptor);
	                    }
	                    else {
	                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
	                    }
	                }
	                else if (opts.prototype[callback]) {
	                    opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
	                }
	            });
	        }
	        return _registerElement.apply(document, [name, opts]);
	    };
	}
	exports.registerElementPatch = registerElementPatch;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var webSocketPatch = __webpack_require__(7);
	var utils_1 = __webpack_require__(3);
	var eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');
	function propertyDescriptorPatch(_global) {
	    if (utils_1.isNode) {
	        return;
	    }
	    var supportsWebSocket = typeof WebSocket !== 'undefined';
	    if (canPatchViaPropertyDescriptor()) {
	        // for browsers that we can patch the descriptor:  Chrome & Firefox
	        if (utils_1.isBrowser) {
	            utils_1.patchOnProperties(HTMLElement.prototype, eventNames);
	        }
	        utils_1.patchOnProperties(XMLHttpRequest.prototype, null);
	        if (typeof IDBIndex !== 'undefined') {
	            utils_1.patchOnProperties(IDBIndex.prototype, null);
	            utils_1.patchOnProperties(IDBRequest.prototype, null);
	            utils_1.patchOnProperties(IDBOpenDBRequest.prototype, null);
	            utils_1.patchOnProperties(IDBDatabase.prototype, null);
	            utils_1.patchOnProperties(IDBTransaction.prototype, null);
	            utils_1.patchOnProperties(IDBCursor.prototype, null);
	        }
	        if (supportsWebSocket) {
	            utils_1.patchOnProperties(WebSocket.prototype, null);
	        }
	    }
	    else {
	        // Safari, Android browsers (Jelly Bean)
	        patchViaCapturingAllTheEvents();
	        utils_1.patchClass('XMLHttpRequest');
	        if (supportsWebSocket) {
	            webSocketPatch.apply(_global);
	        }
	    }
	}
	exports.propertyDescriptorPatch = propertyDescriptorPatch;
	function canPatchViaPropertyDescriptor() {
	    if (utils_1.isBrowser && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick')
	        && typeof Element !== 'undefined') {
	        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
	        // IDL interface attributes are not configurable
	        var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
	        if (desc && !desc.configurable)
	            return false;
	    }
	    Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {
	        get: function () {
	            return true;
	        }
	    });
	    var req = new XMLHttpRequest();
	    var result = !!req.onreadystatechange;
	    Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {});
	    return result;
	}
	;
	var unboundKey = utils_1.zoneSymbol('unbound');
	// Whenever any eventListener fires, we check the eventListener target and all parents
	// for `onwhatever` properties and replace them with zone-bound functions
	// - Chrome (for now)
	function patchViaCapturingAllTheEvents() {
	    var _loop_1 = function(i) {
	        var property = eventNames[i];
	        var onproperty = 'on' + property;
	        document.addEventListener(property, function (event) {
	            var elt = event.target, bound, source;
	            if (elt) {
	                source = elt.constructor['name'] + '.' + onproperty;
	            }
	            else {
	                source = 'unknown.' + onproperty;
	            }
	            while (elt) {
	                if (elt[onproperty] && !elt[onproperty][unboundKey]) {
	                    bound = Zone.current.wrap(elt[onproperty], source);
	                    bound[unboundKey] = elt[onproperty];
	                    elt[onproperty] = bound;
	                }
	                elt = elt.parentElement;
	            }
	        }, true);
	    };
	    for (var i = 0; i < eventNames.length; i++) {
	        _loop_1(i);
	    }
	    ;
	}
	;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(3);
	// we have to patch the instance since the proto is non-configurable
	function apply(_global) {
	    var WS = _global.WebSocket;
	    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener
	    // On older Chrome, no need since EventTarget was already patched
	    if (!_global.EventTarget) {
	        utils_1.patchEventTargetMethods(WS.prototype);
	    }
	    _global.WebSocket = function (a, b) {
	        var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
	        var proxySocket;
	        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
	        var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
	        if (onmessageDesc && onmessageDesc.configurable === false) {
	            proxySocket = Object.create(socket);
	            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {
	                proxySocket[propName] = function () {
	                    return socket[propName].apply(socket, arguments);
	                };
	            });
	        }
	        else {
	            // we can patch the real socket
	            proxySocket = socket;
	        }
	        utils_1.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open']);
	        return proxySocket;
	    };
	    for (var prop in WS) {
	        _global.WebSocket[prop] = WS[prop];
	    }
	}
	exports.apply = apply;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(3);
	function patchTimer(window, setName, cancelName, nameSuffix) {
	    var setNative = null;
	    var clearNative = null;
	    setName += nameSuffix;
	    cancelName += nameSuffix;
	    function scheduleTask(task) {
	        var data = task.data;
	        data.args[0] = task.invoke;
	        data.handleId = setNative.apply(window, data.args);
	        return task;
	    }
	    function clearTask(task) {
	        return clearNative(task.data.handleId);
	    }
	    setNative = utils_1.patchMethod(window, setName, function (delegate) { return function (self, args) {
	        if (typeof args[0] === 'function') {
	            var zone = Zone.current;
	            var options = {
	                handleId: null,
	                isPeriodic: nameSuffix === 'Interval',
	                delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,
	                args: args
	            };
	            var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
	            if (!task) {
	                return task;
	            }
	            // Node.js must additionally support the ref and unref functions.
	            var handle = task.data.handleId;
	            if (handle.ref && handle.unref) {
	                task.ref = handle.ref.bind(handle);
	                task.unref = handle.unref.bind(handle);
	            }
	            return task;
	        }
	        else {
	            // cause an error by calling it directly.
	            return delegate.apply(window, args);
	        }
	    }; });
	    clearNative = utils_1.patchMethod(window, cancelName, function (delegate) { return function (self, args) {
	        var task = args[0];
	        if (task && typeof task.type === 'string') {
	            if (task.cancelFn && task.data.isPeriodic || task.runCount === 0) {
	                // Do not cancel already canceled functions
	                task.zone.cancelTask(task);
	            }
	        }
	        else {
	            // cause an error by calling it directly.
	            delegate.apply(window, args);
	        }
	    }; });
	}
	exports.patchTimer = patchTimer;


/***/ }
/******/ ]);
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Object.create support
    var supportsCreate = typeof Object.create === "function";
    // feature test for __proto__ support
    var supportsProto = (function () {
        var sentinel = {};
        function __() { }
        __.prototype = sentinel;
        var instance = new __();
        return instance.__proto__ === sentinel;
    })();
    // create an object in dictionary mode (a.k.a. "slow" mode in v8)
    var createDictionary = supportsCreate ? function () { return MakeDictionary(Object.create(null)); } :
        supportsProto ? function () { return MakeDictionary({ __proto__: null }); } :
            function () { return MakeDictionary({}); };
    var HashMap;
    (function (HashMap) {
        var downLevel = !supportsCreate && !supportsProto;
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param targetKey (Optional) The property key to decorate.
      * @param targetDescriptor (Optional) The property descriptor for the target key
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, targetKey, targetDescriptor) {
        if (!IsUndefined(targetDescriptor)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (IsUndefined(targetKey))
                throw new TypeError();
            if (!IsObject(targetDescriptor))
                throw new TypeError();
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
        }
        else if (!IsUndefined(targetKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, targetKey) {
            if (!IsUndefined(targetKey)) {
                if (!IsObject(target))
                    throw new TypeError();
                targetKey = ToPropertyKey(targetKey);
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
            }
            else {
                if (!IsConstructor(target))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);
            }
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param targetKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, targetKey) {
        // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#deletemetadata-metadatakey-p-
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(targetKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            decorator(target, propertyKey);
        }
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#getorcreatemetadatamap--o-p-create-
    function GetOrCreateMetadataMap(target, targetKey, create) {
        var targetMetadata = Metadata.get(target);
        if (!targetMetadata) {
            if (!create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(target, targetMetadata);
        }
        var keyMetadata = targetMetadata.get(targetKey);
        if (!keyMetadata) {
            if (!create)
                return undefined;
            keyMetadata = new _Map();
            targetMetadata.set(targetKey, keyMetadata);
        }
        return keyMetadata;
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = GetPrototypeOf(O);
        return parent !== null ? OrdinaryHasMetadata(MetadataKey, parent, P) : false;
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
        return metadataMap !== undefined && Boolean(metadataMap.has(MetadataKey));
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetmetadata--metadatakey-o-p-
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = GetPrototypeOf(O);
        return parent !== null ? OrdinaryGetMetadata(MetadataKey, parent, P) : undefined;
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
        return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarymetadatakeys--o-p-
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = GetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
            return ownKeys;
        if (ownKeys.length <= 0)
            return parentKeys;
        var keys = new _Set();
        for (var _i = 0; _i < ownKeys.length; _i++) {
            var key = ownKeys[_i];
            keys.add(key);
        }
        for (var _a = 0; _a < parentKeys.length; _a++) {
            var key = parentKeys[_a];
            keys.add(key);
        }
        return getKeys(keys);
    }
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryownmetadatakeys--o-p-
    function OrdinaryOwnMetadataKeys(target, targetKey) {
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);
        var keys = [];
        if (metadataMap)
            forEach(metadataMap, function (_, key) { return keys.push(key); });
        return keys;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
    function IsArray(x) {
        return Array.isArray ? Array.isArray(x) : x instanceof Array || Object.prototype.toString.call(x) === "[object Array]";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
    function IsConstructor(x) {
        return typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
    function ToPropertyKey(value) {
        return IsSymbol(value) ? value : String(value);
    }
    function GetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass Exampleonstructor. Compatible implementations
        // must either set __proto__ on a subclass Exampleonstructor to the superclass Exampleonstructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? undefined : result;
    }
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    function forEach(source, callback, thisArg) {
        var entries = source.entries;
        if (typeof entries === "function") {
            var iterator = entries.call(source);
            var result;
            try {
                while (result = IteratorStep(iterator)) {
                    var _a = result.value, key = _a[0], value = _a[1];
                    callback.call(thisArg, value, key, source);
                }
            }
            finally {
                if (result)
                    IteratorClose(iterator);
            }
        }
        else {
            var forEach_1 = source.forEach;
            if (typeof forEach_1 === "function") {
                forEach_1.call(source, callback, thisArg);
            }
        }
    }
    function getKeys(source) {
        var keys = [];
        forEach(source, function (_, key) { keys.push(key); });
        return keys;
    }
    // naive MapIterator shim
    function CreateMapIterator(keys, values, kind) {
        var index = 0;
        return {
            next: function () {
                if ((keys || values) && index < (keys || values).length) {
                    var current = index++;
                    switch (kind) {
                        case "key": return { value: keys[current], done: false };
                        case "value": return { value: values[current], done: false };
                        case "key+value": return { value: [keys[current], values[current]], done: false };
                    }
                }
                keys = undefined;
                values = undefined;
                return { value: undefined, done: true };
            },
            "throw": function (error) {
                if (keys || values) {
                    keys = undefined;
                    values = undefined;
                }
                throw error;
            },
            "return": function (value) {
                if (keys || values) {
                    keys = undefined;
                    values = undefined;
                }
                return { value: value, done: true };
            }
        };
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i < size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return CreateMapIterator(this._keys, /*values*/ undefined, "key"); };
            Map.prototype.values = function () { return CreateMapIterator(/*keys*/ undefined, this._values, "value"); };
            Map.prototype.entries = function () { return CreateMapIterator(this._keys, this._values, "key+value"); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey === key)
                    return this._cacheIndex;
                var index = this._keys.indexOf(key);
                if (index < 0 && insert) {
                    index = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheKey = key, this._cacheIndex = index;
            };
            return Map;
        })();
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            return Set;
        })();
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = createDictionary();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        })();
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122 Â§ 4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte < 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: createDictionary() });
            }
            return target[rootKey];
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__DICTIONARY_MODE__ = 1;
        delete obj.____DICTIONARY_MODE__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof window !== "undefined" ? window :
        typeof WorkerGlobalScope !== "undefined" ? self :
            typeof global !== "undefined" ? global :
                Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map
/*
 * SystemJS v0.19.27
 */
(function() {
function bootstrap() {// from https://gist.github.com/Yaffle/1088850
(function(global) {
function URLPolyfill(url, baseURL) {
  if (typeof url != 'string')
    throw new TypeError('URL must be a string');
  var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(?:\/\/(?:([^:@\/?#]*)(?::([^:@\/?#]*))?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
  if (!m)
    throw new RangeError('Invalid URL format');
  var protocol = m[1] || "";
  var username = m[2] || "";
  var password = m[3] || "";
  var host = m[4] || "";
  var hostname = m[5] || "";
  var port = m[6] || "";
  var pathname = m[7] || "";
  var search = m[8] || "";
  var hash = m[9] || "";
  if (baseURL !== undefined) {
    var base = baseURL instanceof URLPolyfill ? baseURL : new URLPolyfill(baseURL);
    var flag = !protocol && !host && !username;
    if (flag && !pathname && !search)
      search = base.search;
    if (flag && pathname[0] !== "/")
      pathname = (pathname ? (((base.host || base.username) && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + pathname) : base.pathname);
    // dot segments removal
    var output = [];
    pathname.replace(/^(\.\.?(\/|$))+/, "")
      .replace(/\/(\.(\/|$))+/g, "/")
      .replace(/\/\.\.$/, "/../")
      .replace(/\/?[^\/]*/g, function (p) {
        if (p === "/..")
          output.pop();
        else
          output.push(p);
      });
    pathname = output.join("").replace(/^\//, pathname[0] === "/" ? "/" : "");
    if (flag) {
      port = base.port;
      hostname = base.hostname;
      host = base.host;
      password = base.password;
      username = base.username;
    }
    if (!protocol)
      protocol = base.protocol;
  }

  // convert windows file URLs to use /
  if (protocol == 'file:')
    pathname = pathname.replace(/\\/g, '/');

  this.origin = host ? protocol + (protocol !== "" || host !== "" ? "//" : "") + host : "";
  this.href = protocol + (protocol && host || protocol == "file:" ? "//" : "") + (username !== "" ? username + (password !== "" ? ":" + password : "") + "@" : "") + host + pathname + search + hash;
  this.protocol = protocol;
  this.username = username;
  this.password = password;
  this.host = host;
  this.hostname = hostname;
  this.port = port;
  this.pathname = pathname;
  this.search = search;
  this.hash = hash;
}
global.URLPolyfill = URLPolyfill;
})(typeof self != 'undefined' ? self : global);(function(__global) {

  var isWorker = typeof window == 'undefined' && typeof self != 'undefined' && typeof importScripts != 'undefined';
  var isBrowser = typeof window != 'undefined' && typeof document != 'undefined';
  var isWindows = typeof process != 'undefined' && typeof process.platform != 'undefined' && !!process.platform.match(/^win/);

  if (!__global.console)
    __global.console = { assert: function() {} };

  // IE8 support
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, thisLen = this.length; i < thisLen; i++) {
      if (this[i] === item) {
        return i;
      }
    }
    return -1;
  };
  
  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  var errArgs = new Error(0, '_').fileName == '_';

  function addToError(err, msg) {
    // parse the stack removing loader code lines for simplification
    if (!err.originalErr) {
      var stack = (err.stack || err.message || err).split('\n');
      var newStack = [];
      for (var i = 0; i < stack.length; i++) {
        if (typeof $__curScript == 'undefined' || stack[i].indexOf($__curScript.src) == -1)
          newStack.push(stack[i]);
      }
    }

    var newMsg = (newStack ? newStack.join('\n\t') : err.message) + '\n\t' + msg;

    // Convert file:/// URLs to paths in Node
    if (!isBrowser)
      newMsg = newMsg.replace(isWindows ? /file:\/\/\//g : /file:\/\//g, '');

    var newErr = errArgs ? new Error(newMsg, err.fileName, err.lineNumber) : new Error(newMsg);
    
    // Node needs stack adjustment for throw to show message
    if (!isBrowser)
      newErr.stack = newMsg;
    // Clearing the stack stops unnecessary loader lines showing
    else
      newErr.stack = null;
    
    // track the original error
    newErr.originalErr = err.originalErr || err;

    return newErr;
  }

  function __eval(source, debugName, context) {
    try {
      new Function(source).call(context);
    }
    catch(e) {
      throw addToError(e, 'Evaluating ' + debugName);
    }
  }

  var baseURI;
  // environent baseURI detection
  if (typeof document != 'undefined' && document.getElementsByTagName) {
    baseURI = document.baseURI;

    if (!baseURI) {
      var bases = document.getElementsByTagName('base');
      baseURI = bases[0] && bases[0].href || window.location.href;
    }

    // sanitize out the hash and querystring
    baseURI = baseURI.split('#')[0].split('?')[0];
    baseURI = baseURI.substr(0, baseURI.lastIndexOf('/') + 1);
  }
  else if (typeof process != 'undefined' && process.cwd) {
    baseURI = 'file://' + (isWindows ? '/' : '') + process.cwd() + '/';
    if (isWindows)
      baseURI = baseURI.replace(/\\/g, '/');
  }
  else if (typeof location != 'undefined') {
    baseURI = __global.location.href;
  }
  else {
    throw new TypeError('No environment baseURI');
  }

  try {
    var nativeURL = new __global.URL('test:///').protocol == 'test:';
  }
  catch(e) {}

  var URL = nativeURL ? __global.URL : __global.URLPolyfill;
/*
*********************************************************************************************

  Dynamic Module Loader Polyfill

    - Implemented exactly to the former 2014-08-24 ES6 Specification Draft Rev 27, Section 15
      http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#august_24_2014_draft_rev_27

    - Functions are commented with their spec numbers, with spec differences commented.

    - Spec bugs are commented in this code with links.

    - Abstract functions have been combined where possible, and their associated functions
      commented.

    - Realm implementation is entirely omitted.

*********************************************************************************************
*/

function Module() {}
// http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag
defineProperty(Module.prototype, 'toString', {
  value: function() {
    return 'Module';
  }
});
function Loader(options) {
  this._loader = {
    loaderObj: this,
    loads: [],
    modules: {},
    importPromises: {},
    moduleRecords: {}
  };

  // 26.3.3.6
  defineProperty(this, 'global', {
    get: function() {
      return __global;
    }
  });

  // 26.3.3.13 realm not implemented
}

(function() {

// Some Helpers

// logs a linkset snapshot for debugging
/* function snapshot(loader) {
  console.log('---Snapshot---');
  for (var i = 0; i < loader.loads.length; i++) {
    var load = loader.loads[i];
    var linkSetLog = '  ' + load.name + ' (' + load.status + '): ';

    for (var j = 0; j < load.linkSets.length; j++) {
      linkSetLog += '{' + logloads(load.linkSets[j].loads) + '} ';
    }
    console.log(linkSetLog);
  }
  console.log('');
}
function logloads(loads) {
  var log = '';
  for (var k = 0; k < loads.length; k++)
    log += loads[k].name + (k != loads.length - 1 ? ' ' : '');
  return log;
} */


/* function checkInvariants() {
  // see https://bugs.ecmascript.org/show_bug.cgi?id=2603#c1

  var loads = System._loader.loads;
  var linkSets = [];

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    console.assert(load.status == 'loading' || load.status == 'loaded', 'Each load is loading or loaded');

    for (var j = 0; j < load.linkSets.length; j++) {
      var linkSet = load.linkSets[j];

      for (var k = 0; k < linkSet.loads.length; k++)
        console.assert(loads.indexOf(linkSet.loads[k]) != -1, 'linkSet loads are a subset of loader loads');

      if (linkSets.indexOf(linkSet) == -1)
        linkSets.push(linkSet);
    }
  }

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    for (var j = 0; j < linkSets.length; j++) {
      var linkSet = linkSets[j];

      if (linkSet.loads.indexOf(load) != -1)
        console.assert(load.linkSets.indexOf(linkSet) != -1, 'linkSet contains load -> load contains linkSet');

      if (load.linkSets.indexOf(linkSet) != -1)
        console.assert(linkSet.loads.indexOf(load) != -1, 'load contains linkSet -> linkSet contains load');
    }
  }

  for (var i = 0; i < linkSets.length; i++) {
    var linkSet = linkSets[i];
    for (var j = 0; j < linkSet.loads.length; j++) {
      var load = linkSet.loads[j];

      for (var k = 0; k < load.dependencies.length; k++) {
        var depName = load.dependencies[k].value;
        var depLoad;
        for (var l = 0; l < loads.length; l++) {
          if (loads[l].name != depName)
            continue;
          depLoad = loads[l];
          break;
        }

        // loading records are allowed not to have their dependencies yet
        // if (load.status != 'loading')
        //  console.assert(depLoad, 'depLoad found');

        // console.assert(linkSet.loads.indexOf(depLoad) != -1, 'linkset contains all dependencies');
      }
    }
  }
} */

  // 15.2.3 - Runtime Semantics: Loader State

  // 15.2.3.11
  function createLoaderLoad(object) {
    return {
      // modules is an object for ES5 implementation
      modules: {},
      loads: [],
      loaderObj: object
    };
  }

  // 15.2.3.2 Load Records and LoadRequest Objects

  // 15.2.3.2.1
  function createLoad(name) {
    return {
      status: 'loading',
      name: name,
      linkSets: [],
      dependencies: [],
      metadata: {}
    };
  }

  // 15.2.3.2.2 createLoadRequestObject, absorbed into calling functions

  // 15.2.4

  // 15.2.4.1
  function loadModule(loader, name, options) {
    return new Promise(asyncStartLoadPartwayThrough({
      step: options.address ? 'fetch' : 'locate',
      loader: loader,
      moduleName: name,
      // allow metadata for import https://bugs.ecmascript.org/show_bug.cgi?id=3091
      moduleMetadata: options && options.metadata || {},
      moduleSource: options.source,
      moduleAddress: options.address
    }));
  }

  // 15.2.4.2
  function requestLoad(loader, request, refererName, refererAddress) {
    // 15.2.4.2.1 CallNormalize
    return new Promise(function(resolve, reject) {
      resolve(loader.loaderObj.normalize(request, refererName, refererAddress));
    })
    // 15.2.4.2.2 GetOrCreateLoad
    .then(function(name) {
      var load;
      if (loader.modules[name]) {
        load = createLoad(name);
        load.status = 'linked';
        // https://bugs.ecmascript.org/show_bug.cgi?id=2795
        load.module = loader.modules[name];
        return load;
      }

      for (var i = 0, l = loader.loads.length; i < l; i++) {
        load = loader.loads[i];
        if (load.name != name)
          continue;
        console.assert(load.status == 'loading' || load.status == 'loaded', 'loading or loaded');
        return load;
      }

      load = createLoad(name);
      loader.loads.push(load);

      proceedToLocate(loader, load);

      return load;
    });
  }

  // 15.2.4.3
  function proceedToLocate(loader, load) {
    proceedToFetch(loader, load,
      Promise.resolve()
      // 15.2.4.3.1 CallLocate
      .then(function() {
        return loader.loaderObj.locate({ name: load.name, metadata: load.metadata });
      })
    );
  }

  // 15.2.4.4
  function proceedToFetch(loader, load, p) {
    proceedToTranslate(loader, load,
      p
      // 15.2.4.4.1 CallFetch
      .then(function(address) {
        // adjusted, see https://bugs.ecmascript.org/show_bug.cgi?id=2602
        if (load.status != 'loading')
          return;
        load.address = address;

        return loader.loaderObj.fetch({ name: load.name, metadata: load.metadata, address: address });
      })
    );
  }

  var anonCnt = 0;

  // 15.2.4.5
  function proceedToTranslate(loader, load, p) {
    p
    // 15.2.4.5.1 CallTranslate
    .then(function(source) {
      if (load.status != 'loading')
        return;

      return Promise.resolve(loader.loaderObj.translate({ name: load.name, metadata: load.metadata, address: load.address, source: source }))

      // 15.2.4.5.2 CallInstantiate
      .then(function(source) {
        load.source = source;
        return loader.loaderObj.instantiate({ name: load.name, metadata: load.metadata, address: load.address, source: source });
      })

      // 15.2.4.5.3 InstantiateSucceeded
      .then(function(instantiateResult) {
        if (instantiateResult === undefined) {
          load.address = load.address || '<Anonymous Module ' + ++anonCnt + '>';

          // instead of load.kind, use load.isDeclarative
          load.isDeclarative = true;
          return transpile.call(loader.loaderObj, load)
          .then(function(transpiled) {
            // Hijack System.register to set declare function
            var curSystem = __global.System;
            var curRegister = curSystem.register;
            curSystem.register = function(name, deps, declare) {
              if (typeof name != 'string') {
                declare = deps;
                deps = name;
              }
              // store the registered declaration as load.declare
              // store the deps as load.deps
              load.declare = declare;
              load.depsList = deps;
            }
            // empty {} context is closest to undefined 'this' we can get
            __eval(transpiled, load.address, {});
            curSystem.register = curRegister;
          });
        }
        else if (typeof instantiateResult == 'object') {
          load.depsList = instantiateResult.deps || [];
          load.execute = instantiateResult.execute;
          load.isDeclarative = false;
        }
        else
          throw TypeError('Invalid instantiate return value');
      })
      // 15.2.4.6 ProcessLoadDependencies
      .then(function() {
        load.dependencies = [];
        var depsList = load.depsList;

        var loadPromises = [];
        for (var i = 0, l = depsList.length; i < l; i++) (function(request, index) {
          loadPromises.push(
            requestLoad(loader, request, load.name, load.address)

            // 15.2.4.6.1 AddDependencyLoad (load is parentLoad)
            .then(function(depLoad) {

              // adjusted from spec to maintain dependency order
              // this is due to the System.register internal implementation needs
              load.dependencies[index] = {
                key: request,
                value: depLoad.name
              };

              if (depLoad.status != 'linked') {
                var linkSets = load.linkSets.concat([]);
                for (var i = 0, l = linkSets.length; i < l; i++)
                  addLoadToLinkSet(linkSets[i], depLoad);
              }

              // console.log('AddDependencyLoad ' + depLoad.name + ' for ' + load.name);
              // snapshot(loader);
            })
          );
        })(depsList[i], i);

        return Promise.all(loadPromises);
      })

      // 15.2.4.6.2 LoadSucceeded
      .then(function() {
        // console.log('LoadSucceeded ' + load.name);
        // snapshot(loader);

        console.assert(load.status == 'loading', 'is loading');

        load.status = 'loaded';

        var linkSets = load.linkSets.concat([]);
        for (var i = 0, l = linkSets.length; i < l; i++)
          updateLinkSetOnLoad(linkSets[i], load);
      });
    })
    // 15.2.4.5.4 LoadFailed
    ['catch'](function(exc) {
      load.status = 'failed';
      load.exception = exc;

      var linkSets = load.linkSets.concat([]);
      for (var i = 0, l = linkSets.length; i < l; i++) {
        linkSetFailed(linkSets[i], load, exc);
      }

      console.assert(load.linkSets.length == 0, 'linkSets not removed');
    });
  }

  // 15.2.4.7 PromiseOfStartLoadPartwayThrough absorbed into calling functions

  // 15.2.4.7.1
  function asyncStartLoadPartwayThrough(stepState) {
    return function(resolve, reject) {
      var loader = stepState.loader;
      var name = stepState.moduleName;
      var step = stepState.step;

      if (loader.modules[name])
        throw new TypeError('"' + name + '" already exists in the module table');

      // adjusted to pick up existing loads
      var existingLoad;
      for (var i = 0, l = loader.loads.length; i < l; i++) {
        if (loader.loads[i].name == name) {
          existingLoad = loader.loads[i];

          if (step == 'translate' && !existingLoad.source) {
            existingLoad.address = stepState.moduleAddress;
            proceedToTranslate(loader, existingLoad, Promise.resolve(stepState.moduleSource));
          }

          // a primary load -> use that existing linkset if it is for the direct load here
          // otherwise create a new linkset unit
          if (existingLoad.linkSets.length && existingLoad.linkSets[0].loads[0].name == existingLoad.name)
            return existingLoad.linkSets[0].done.then(function() {
              resolve(existingLoad);
            });
        }
      }

      var load = existingLoad || createLoad(name);

      load.metadata = stepState.moduleMetadata;

      var linkSet = createLinkSet(loader, load);

      loader.loads.push(load);

      resolve(linkSet.done);

      if (step == 'locate')
        proceedToLocate(loader, load);

      else if (step == 'fetch')
        proceedToFetch(loader, load, Promise.resolve(stepState.moduleAddress));

      else {
        console.assert(step == 'translate', 'translate step');
        load.address = stepState.moduleAddress;
        proceedToTranslate(loader, load, Promise.resolve(stepState.moduleSource));
      }
    }
  }

  // Declarative linking functions run through alternative implementation:
  // 15.2.5.1.1 CreateModuleLinkageRecord not implemented
  // 15.2.5.1.2 LookupExport not implemented
  // 15.2.5.1.3 LookupModuleDependency not implemented

  // 15.2.5.2.1
  function createLinkSet(loader, startingLoad) {
    var linkSet = {
      loader: loader,
      loads: [],
      startingLoad: startingLoad, // added see spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
      loadingCount: 0
    };
    linkSet.done = new Promise(function(resolve, reject) {
      linkSet.resolve = resolve;
      linkSet.reject = reject;
    });
    addLoadToLinkSet(linkSet, startingLoad);
    return linkSet;
  }
  // 15.2.5.2.2
  function addLoadToLinkSet(linkSet, load) {
    if (load.status == 'failed')
      return;

    console.assert(load.status == 'loading' || load.status == 'loaded', 'loading or loaded on link set');

    for (var i = 0, l = linkSet.loads.length; i < l; i++)
      if (linkSet.loads[i] == load)
        return;

    linkSet.loads.push(load);
    load.linkSets.push(linkSet);

    // adjustment, see https://bugs.ecmascript.org/show_bug.cgi?id=2603
    if (load.status != 'loaded') {
      linkSet.loadingCount++;
    }

    var loader = linkSet.loader;

    for (var i = 0, l = load.dependencies.length; i < l; i++) {
      if (!load.dependencies[i])
        continue;

      var name = load.dependencies[i].value;

      if (loader.modules[name])
        continue;

      for (var j = 0, d = loader.loads.length; j < d; j++) {
        if (loader.loads[j].name != name)
          continue;

        addLoadToLinkSet(linkSet, loader.loads[j]);
        break;
      }
    }
    // console.log('add to linkset ' + load.name);
    // snapshot(linkSet.loader);
  }

  // linking errors can be generic or load-specific
  // this is necessary for debugging info
  function doLink(linkSet) {
    var error = false;
    try {
      link(linkSet, function(load, exc) {
        linkSetFailed(linkSet, load, exc);
        error = true;
      });
    }
    catch(e) {
      linkSetFailed(linkSet, null, e);
      error = true;
    }
    return error;
  }

  // 15.2.5.2.3
  function updateLinkSetOnLoad(linkSet, load) {
    // console.log('update linkset on load ' + load.name);
    // snapshot(linkSet.loader);

    console.assert(load.status == 'loaded' || load.status == 'linked', 'loaded or linked');

    linkSet.loadingCount--;

    if (linkSet.loadingCount > 0)
      return;

    // adjusted for spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
    var startingLoad = linkSet.startingLoad;

    // non-executing link variation for loader tracing
    // on the server. Not in spec.
    /***/
    if (linkSet.loader.loaderObj.execute === false) {
      var loads = [].concat(linkSet.loads);
      for (var i = 0, l = loads.length; i < l; i++) {
        var load = loads[i];
        load.module = !load.isDeclarative ? {
          module: _newModule({})
        } : {
          name: load.name,
          module: _newModule({}),
          evaluated: true
        };
        load.status = 'linked';
        finishLoad(linkSet.loader, load);
      }
      return linkSet.resolve(startingLoad);
    }
    /***/

    var abrupt = doLink(linkSet);

    if (abrupt)
      return;

    console.assert(linkSet.loads.length == 0, 'loads cleared');

    linkSet.resolve(startingLoad);
  }

  // 15.2.5.2.4
  function linkSetFailed(linkSet, load, exc) {
    var loader = linkSet.loader;
    var requests;

    checkError: 
    if (load) {
      if (linkSet.loads[0].name == load.name) {
        exc = addToError(exc, 'Error loading ' + load.name);
      }
      else {
        for (var i = 0; i < linkSet.loads.length; i++) {
          var pLoad = linkSet.loads[i];
          for (var j = 0; j < pLoad.dependencies.length; j++) {
            var dep = pLoad.dependencies[j];
            if (dep.value == load.name) {
              exc = addToError(exc, 'Error loading ' + load.name + ' as "' + dep.key + '" from ' + pLoad.name);
              break checkError;
            }
          }
        }
        exc = addToError(exc, 'Error loading ' + load.name + ' from ' + linkSet.loads[0].name);
      }
    }
    else {
      exc = addToError(exc, 'Error linking ' + linkSet.loads[0].name);
    }


    var loads = linkSet.loads.concat([]);
    for (var i = 0, l = loads.length; i < l; i++) {
      var load = loads[i];

      // store all failed load records
      loader.loaderObj.failed = loader.loaderObj.failed || [];
      if (indexOf.call(loader.loaderObj.failed, load) == -1)
        loader.loaderObj.failed.push(load);

      var linkIndex = indexOf.call(load.linkSets, linkSet);
      console.assert(linkIndex != -1, 'link not present');
      load.linkSets.splice(linkIndex, 1);
      if (load.linkSets.length == 0) {
        var globalLoadsIndex = indexOf.call(linkSet.loader.loads, load);
        if (globalLoadsIndex != -1)
          linkSet.loader.loads.splice(globalLoadsIndex, 1);
      }
    }
    linkSet.reject(exc);
  }

  // 15.2.5.2.5
  function finishLoad(loader, load) {
    // add to global trace if tracing
    if (loader.loaderObj.trace) {
      if (!loader.loaderObj.loads)
        loader.loaderObj.loads = {};
      var depMap = {};
      load.dependencies.forEach(function(dep) {
        depMap[dep.key] = dep.value;
      });
      loader.loaderObj.loads[load.name] = {
        name: load.name,
        deps: load.dependencies.map(function(dep){ return dep.key }),
        depMap: depMap,
        address: load.address,
        metadata: load.metadata,
        source: load.source,
        kind: load.isDeclarative ? 'declarative' : 'dynamic'
      };
    }
    // if not anonymous, add to the module table
    if (load.name) {
      console.assert(!loader.modules[load.name], 'load not in module table');
      loader.modules[load.name] = load.module;
    }
    var loadIndex = indexOf.call(loader.loads, load);
    if (loadIndex != -1)
      loader.loads.splice(loadIndex, 1);
    for (var i = 0, l = load.linkSets.length; i < l; i++) {
      loadIndex = indexOf.call(load.linkSets[i].loads, load);
      if (loadIndex != -1)
        load.linkSets[i].loads.splice(loadIndex, 1);
    }
    load.linkSets.splice(0, load.linkSets.length);
  }

  function doDynamicExecute(linkSet, load, linkError) {
    try {
      var module = load.execute();
    }
    catch(e) {
      linkError(load, e);
      return;
    }
    if (!module || !(module instanceof Module))
      linkError(load, new TypeError('Execution must define a Module instance'));
    else
      return module;
  }

  // 26.3 Loader

  // 26.3.1.1
  // defined at top

  // importPromises adds ability to import a module twice without error - https://bugs.ecmascript.org/show_bug.cgi?id=2601
  function createImportPromise(loader, name, promise) {
    var importPromises = loader._loader.importPromises;
    return importPromises[name] = promise.then(function(m) {
      importPromises[name] = undefined;
      return m;
    }, function(e) {
      importPromises[name] = undefined;
      throw e;
    });
  }

  Loader.prototype = {
    // 26.3.3.1
    constructor: Loader,
    // 26.3.3.2
    define: function(name, source, options) {
      // check if already defined
      if (this._loader.importPromises[name])
        throw new TypeError('Module is already loading.');
      return createImportPromise(this, name, new Promise(asyncStartLoadPartwayThrough({
        step: 'translate',
        loader: this._loader,
        moduleName: name,
        moduleMetadata: options && options.metadata || {},
        moduleSource: source,
        moduleAddress: options && options.address
      })));
    },
    // 26.3.3.3
    'delete': function(name) {
      var loader = this._loader;
      delete loader.importPromises[name];
      delete loader.moduleRecords[name];
      return loader.modules[name] ? delete loader.modules[name] : false;
    },
    // 26.3.3.4 entries not implemented
    // 26.3.3.5
    get: function(key) {
      if (!this._loader.modules[key])
        return;
      doEnsureEvaluated(this._loader.modules[key], [], this);
      return this._loader.modules[key].module;
    },
    // 26.3.3.7
    has: function(name) {
      return !!this._loader.modules[name];
    },
    // 26.3.3.8
    'import': function(name, parentName, parentAddress) {
      if (typeof parentName == 'object')
        parentName = parentName.name;

      // run normalize first
      var loaderObj = this;

      // added, see https://bugs.ecmascript.org/show_bug.cgi?id=2659
      return Promise.resolve(loaderObj.normalize(name, parentName))
      .then(function(name) {
        var loader = loaderObj._loader;

        if (loader.modules[name]) {
          doEnsureEvaluated(loader.modules[name], [], loader._loader);
          return loader.modules[name].module;
        }

        return loader.importPromises[name] || createImportPromise(loaderObj, name,
          loadModule(loader, name, {})
          .then(function(load) {
            delete loader.importPromises[name];
            return evaluateLoadedModule(loader, load);
          }));
      });
    },
    // 26.3.3.9 keys not implemented
    // 26.3.3.10
    load: function(name) {
      var loader = this._loader;
      if (loader.modules[name])
        return Promise.resolve();
      return loader.importPromises[name] || createImportPromise(this, name, new Promise(asyncStartLoadPartwayThrough({
        step: 'locate',
        loader: loader,
        moduleName: name,
        moduleMetadata: {},
        moduleSource: undefined,
        moduleAddress: undefined
      }))
      .then(function() {
        delete loader.importPromises[name];
      }));
    },
    // 26.3.3.11
    module: function(source, options) {
      var load = createLoad();
      load.address = options && options.address;
      var linkSet = createLinkSet(this._loader, load);
      var sourcePromise = Promise.resolve(source);
      var loader = this._loader;
      var p = linkSet.done.then(function() {
        return evaluateLoadedModule(loader, load);
      });
      proceedToTranslate(loader, load, sourcePromise);
      return p;
    },
    // 26.3.3.12
    newModule: function (obj) {
      if (typeof obj != 'object')
        throw new TypeError('Expected object');

      var m = new Module();

      var pNames = [];
      if (Object.getOwnPropertyNames && obj != null)
        pNames = Object.getOwnPropertyNames(obj);
      else
        for (var key in obj)
          pNames.push(key);

      for (var i = 0; i < pNames.length; i++) (function(key) {
        defineProperty(m, key, {
          configurable: false,
          enumerable: true,
          get: function () {
            return obj[key];
          },
          set: function() {
            throw new Error('Module exports cannot be changed externally.');
          }
        });
      })(pNames[i]);

      if (Object.freeze)
        Object.freeze(m);

      return m;
    },
    // 26.3.3.14
    set: function(name, module) {
      if (!(module instanceof Module))
        throw new TypeError('Loader.set(' + name + ', module) must be a module');
      this._loader.modules[name] = {
        module: module
      };
    },
    // 26.3.3.15 values not implemented
    // 26.3.3.16 @@iterator not implemented
    // 26.3.3.17 @@toStringTag not implemented

    // 26.3.3.18.1
    normalize: function(name, referrerName, referrerAddress) {
      return name;
    },
    // 26.3.3.18.2
    locate: function(load) {
      return load.name;
    },
    // 26.3.3.18.3
    fetch: function(load) {
    },
    // 26.3.3.18.4
    translate: function(load) {
      return load.source;
    },
    // 26.3.3.18.5
    instantiate: function(load) {
    }
  };

  var _newModule = Loader.prototype.newModule;
/*
 * ES6 Module Declarative Linking Code - Dev Build Only
 */
  function link(linkSet, linkError) {

    var loader = linkSet.loader;

    if (!linkSet.loads.length)
      return;

    var loads = linkSet.loads.concat([]);

    for (var i = 0; i < loads.length; i++) {
      var load = loads[i];

      var module = doDynamicExecute(linkSet, load, linkError);
      if (!module)
        return;
      load.module = {
        name: load.name,
        module: module
      };
      load.status = 'linked';

      finishLoad(loader, load);
    }
  }

  function evaluateLoadedModule(loader, load) {
    console.assert(load.status == 'linked', 'is linked ' + load.name);
    return load.module.module;
  }

  function doEnsureEvaluated() {}

  function transpile() {
    throw new TypeError('ES6 transpilation is only provided in the dev module loader build.');
  }
})();/*
*********************************************************************************************

  System Loader Implementation

    - Implemented to https://github.com/jorendorff/js-loaders/blob/master/browser-loader.js

    - <script type="module"> supported

*********************************************************************************************
*/

var System;

function SystemLoader() {
  Loader.call(this);
  this.paths = {};
}

// NB no specification provided for System.paths, used ideas discussed in https://github.com/jorendorff/js-loaders/issues/25
function applyPaths(paths, name) {
  // most specific (most number of slashes in path) match wins
  var pathMatch = '', wildcard, maxWildcardPrefixLen = 0;

  // check to see if we have a paths entry
  for (var p in paths) {
    var pathParts = p.split('*');
    if (pathParts.length > 2)
      throw new TypeError('Only one wildcard in a path is permitted');

    // exact path match
    if (pathParts.length == 1) {
      if (name == p)
        return paths[p];
      
      // support trailing / in paths rules
      else if (name.substr(0, p.length - 1) == p.substr(0, p.length - 1) && (name.length < p.length || name[p.length - 1] == p[p.length - 1]) && paths[p][paths[p].length - 1] == '/')
        return paths[p].substr(0, paths[p].length - 1) + (name.length > p.length ? '/' + name.substr(p.length) : '');
    }
    // wildcard path match
    else {
      var wildcardPrefixLen = pathParts[0].length;
      if (wildcardPrefixLen >= maxWildcardPrefixLen &&
          name.substr(0, pathParts[0].length) == pathParts[0] &&
          name.substr(name.length - pathParts[1].length) == pathParts[1]) {
            maxWildcardPrefixLen = wildcardPrefixLen;
            pathMatch = p;
            wildcard = name.substr(pathParts[0].length, name.length - pathParts[1].length - pathParts[0].length);
          }
    }
  }

  var outPath = paths[pathMatch];
  if (typeof wildcard == 'string')
    outPath = outPath.replace('*', wildcard);

  return outPath;
}

// inline Object.create-style class extension
function LoaderProto() {}
LoaderProto.prototype = Loader.prototype;
SystemLoader.prototype = new LoaderProto();
  var fetchTextFromURL;
  if (typeof XMLHttpRequest != 'undefined') {
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      var xhr = new XMLHttpRequest();
      var sameDomain = true;
      var doTimeout = false;
      if (!('withCredentials' in xhr)) {
        // check if same domain
        var domainCheck = /^(\w+:)?\/\/([^\/]+)/.exec(url);
        if (domainCheck) {
          sameDomain = domainCheck[2] === window.location.host;
          if (domainCheck[1])
            sameDomain &= domainCheck[1] === window.location.protocol;
        }
      }
      if (!sameDomain && typeof XDomainRequest != 'undefined') {
        xhr = new XDomainRequest();
        xhr.onload = load;
        xhr.onerror = error;
        xhr.ontimeout = error;
        xhr.onprogress = function() {};
        xhr.timeout = 0;
        doTimeout = true;
      }
      function load() {
        fulfill(xhr.responseText);
      }
      function error() {
        reject(new Error('XHR error' + (xhr.status ? ' (' + xhr.status + (xhr.statusText ? ' ' + xhr.statusText  : '') + ')' : '') + ' loading ' + url));
      }

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          // in Chrome on file:/// URLs, status is 0
          if (xhr.status == 0) {
            if (xhr.responseText) {
              load();
            }
            else {
              // when responseText is empty, wait for load or error event
              // to inform if it is a 404 or empty file
              xhr.addEventListener('error', error);
              xhr.addEventListener('load', load);
            }
          }
          else if (xhr.status === 200) {
            load();
          }
          else {
            error();
          }
        }
      };
      xhr.open("GET", url, true);

      if (xhr.setRequestHeader) {
        xhr.setRequestHeader('Accept', 'application/x-es-module, */*');
        // can set "authorization: true" to enable withCredentials only
        if (authorization) {
          if (typeof authorization == 'string')
            xhr.setRequestHeader('Authorization', authorization);
          xhr.withCredentials = true;
        }
      }

      if (doTimeout) {
        setTimeout(function() {
          xhr.send();
        }, 0);
      } else {
        xhr.send(null);
      }
    };
  }
  else if (typeof require != 'undefined' && typeof process != 'undefined') {
    var fs;
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      if (url.substr(0, 8) != 'file:///')
        throw new Error('Unable to fetch "' + url + '". Only file URLs of the form file:/// allowed running in Node.');
      fs = fs || require('fs');
      if (isWindows)
        url = url.replace(/\//g, '\\').substr(8);
      else
        url = url.substr(7);
      return fs.readFile(url, function(err, data) {
        if (err) {
          return reject(err);
        }
        else {
          // Strip Byte Order Mark out if it's the leading char
          var dataString = data + '';
          if (dataString[0] === '\ufeff')
            dataString = dataString.substr(1);

          fulfill(dataString);
        }
      });
    };
  }
  else if (typeof self != 'undefined' && typeof self.fetch != 'undefined') {
    fetchTextFromURL = function(url, authorization, fulfill, reject) {
      var opts = {
        headers: {'Accept': 'application/x-es-module, */*'}
      };

      if (authorization) {
        if (typeof authorization == 'string')
          opts.headers['Authorization'] = authorization;
        opts.credentials = 'include';
      }

      fetch(url, opts)
        .then(function (r) {
          if (r.ok) {
            return r.text();
          } else {
            throw new Error('Fetch error: ' + r.status + ' ' + r.statusText);
          }
        })
        .then(fulfill, reject);
    }
  }
  else {
    throw new TypeError('No environment fetch API available.');
  }

  SystemLoader.prototype.fetch = function(load) {
    return new Promise(function(resolve, reject) {
      fetchTextFromURL(load.address, undefined, resolve, reject);
    });
  };
/*
 * Traceur, Babel and TypeScript transpile hook for Loader
 */
var transpile = (function() {

  // use Traceur by default
  Loader.prototype.transpiler = 'traceur';

  function transpile(load) {
    var self = this;

    return Promise.resolve(__global[self.transpiler == 'typescript' ? 'ts' : self.transpiler]
        || (self.pluginLoader || self)['import'](self.transpiler))
    .then(function(transpiler) {
      if (transpiler.__useDefault)
        transpiler = transpiler['default'];

      var transpileFunction;
      if (transpiler.Compiler)
        transpileFunction = traceurTranspile;
      else if (transpiler.createLanguageService)
        transpileFunction = typescriptTranspile;
      else
        transpileFunction = babelTranspile;

      // note __moduleName will be part of the transformer meta in future when we have the spec for this
      return '(function(__moduleName){' + transpileFunction.call(self, load, transpiler) + '\n})("' + load.name + '");\n//# sourceURL=' + load.address + '!transpiled';
    });
  };

  function traceurTranspile(load, traceur) {
    var options = this.traceurOptions || {};
    options.modules = 'instantiate';
    options.script = false;
    if (options.sourceMaps === undefined)
      options.sourceMaps = 'inline';
    options.filename = load.address;
    options.inputSourceMap = load.metadata.sourceMap;
    options.moduleName = false;

    var compiler = new traceur.Compiler(options);

    return doTraceurCompile(load.source, compiler, options.filename);
  }
  function doTraceurCompile(source, compiler, filename) {
    try {
      return compiler.compile(source, filename);
    }
    catch(e) {
      // on older versions of traceur (<0.9.3), an array of errors is thrown
      // rather than a single error.
      if (e.length) {
        throw e[0];
      }
      throw e;
    }
  }

  function babelTranspile(load, babel) {
    var options = this.babelOptions || {};
    options.modules = 'system';
    if (options.sourceMap === undefined)
      options.sourceMap = 'inline';
    options.inputSourceMap = load.metadata.sourceMap;
    options.filename = load.address;
    options.code = true;
    options.ast = false;

    return babel.transform(load.source, options).code;
  }

  function typescriptTranspile(load, ts) {
    var options = this.typescriptOptions || {};
    options.target = options.target || ts.ScriptTarget.ES5;
    if (options.sourceMap === undefined)
      options.sourceMap = true;
    if (options.sourceMap && options.inlineSourceMap !== false)
      options.inlineSourceMap = true;

    options.module = ts.ModuleKind.System;

    return ts.transpile(load.source, options, load.address);
  }

  return transpile;
})();
// SystemJS Loader Class and Extension helpers

function SystemJSLoader() {
  SystemLoader.call(this);

  systemJSConstructor.call(this);
}

// inline Object.create-style class extension
function SystemProto() {};
SystemProto.prototype = SystemLoader.prototype;
SystemJSLoader.prototype = new SystemProto();
SystemJSLoader.prototype.constructor = SystemJSLoader;

// remove ESML instantiate
SystemJSLoader.prototype.instantiate = function() {};

var systemJSConstructor;

function hook(name, hook) {
  SystemJSLoader.prototype[name] = hook(SystemJSLoader.prototype[name] || function() {});
}
function hookConstructor(hook) {
  systemJSConstructor = hook(systemJSConstructor || function() {});
}

function dedupe(deps) {
  var newDeps = [];
  for (var i = 0, l = deps.length; i < l; i++)
    if (indexOf.call(newDeps, deps[i]) == -1)
      newDeps.push(deps[i])
  return newDeps;
}

function group(deps) {
  var names = [];
  var indices = [];
  for (var i = 0, l = deps.length; i < l; i++) {
    var index = indexOf.call(names, deps[i]);
    if (index === -1) {
      names.push(deps[i]);
      indices.push([i]);
    }
    else {
      indices[index].push(i);
    }
  }
  return { names: names, indices: indices };
}

var getOwnPropertyDescriptor = true;
try {
  Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
}
catch(e) {
  getOwnPropertyDescriptor = false;
}

// converts any module.exports object into an object ready for SystemJS.newModule
function getESModule(exports) {
  var esModule = {};
  // don't trigger getters/setters in environments that support them
  if (typeof exports == 'object' || typeof exports == 'function') {
    var hasOwnProperty = exports && exports.hasOwnProperty;
    if (getOwnPropertyDescriptor) {
      for (var p in exports) {
        if (!trySilentDefineProperty(esModule, exports, p))
          setPropertyIfHasOwnProperty(esModule, exports, p, hasOwnProperty);
      }
    }
    else {
      for (var p in exports)
        setPropertyIfHasOwnProperty(esModule, exports, p, hasOwnProperty);
    }
  }
  esModule['default'] = exports;
  defineProperty(esModule, '__useDefault', {
    value: true
  });
  return esModule;
}

function setPropertyIfHasOwnProperty(targetObj, sourceObj, propName, hasOwnProperty) {
  if (!hasOwnProperty || sourceObj.hasOwnProperty(propName))
    targetObj[propName] = sourceObj[propName];
}

function trySilentDefineProperty(targetObj, sourceObj, propName) {
  try {
    var d;
    if (d = Object.getOwnPropertyDescriptor(sourceObj, propName))
      defineProperty(targetObj, propName, d);

    return true;
  } catch (ex) {
    // Object.getOwnPropertyDescriptor threw an exception, fall back to normal set property.
    return false;
  }
}

function extend(a, b, prepend) {
  for (var p in b) {
    if (!prepend || !(p in a))
      a[p] = b[p];
  }
  return a;
}

// package configuration options
var packageProperties = ['main', 'format', 'defaultExtension', 'meta', 'map', 'basePath', 'depCache'];

// meta first-level extends where:
// array + array appends
// object + object extends
// other properties replace
function extendMeta(a, b, prepend) {
  for (var p in b) {
    var val = b[p];
    if (!(p in a))
      a[p] = val;
    else if (val instanceof Array && a[p] instanceof Array)
      a[p] = [].concat(prepend ? val : a[p]).concat(prepend ? a[p] : val);
    else if (typeof val == 'object' && val !== null && typeof a[p] == 'object')
      a[p] = extend(extend({}, a[p]), val, prepend);
    else if (!prepend)
      a[p] = val;
  }
}

function warn(msg) {
  if (this.warnings && typeof console != 'undefined' && console.warn)
    console.warn(msg);
}
// we define a __exec for globally-scoped execution
// used by module format implementations
var __exec;

(function() {

  var hasBtoa = typeof btoa != 'undefined';

  function getSource(load) {
    var lastLineIndex = load.source.lastIndexOf('\n');

    // wrap ES formats with a System closure for System global encapsulation
    var wrap = load.metadata.format != 'global';

    var sourceMap = load.metadata.sourceMap;
    if (sourceMap) {
      if (typeof sourceMap != 'object')
        throw new TypeError('load.metadata.sourceMap must be set to an object.');

      sourceMap = JSON.stringify(sourceMap);
    }

    return (wrap ? '(function(System, SystemJS) {' : '') + load.source + (wrap ? '\n})(System, System);' : '')
        // adds the sourceURL comment if not already present
        + (load.source.substr(lastLineIndex, 15) != '\n//# sourceURL=' 
          ? '\n//# sourceURL=' + load.address + (sourceMap ? '!transpiled' : '') : '')
        // add sourceMappingURL if load.metadata.sourceMap is set
        + (sourceMap && hasBtoa && '\n//# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(sourceMap))) || '');
  }

  var curLoad;

  // System.register, System.registerDynamic, AMD define pipeline
  // if currently evalling code here, immediately reduce the registered entry against the load record
  hook('pushRegister_', function() {
    return function(register) {
      if (!curLoad)
        return false;

      this.reduceRegister_(curLoad, register);
      return true;
    };
  });

  // System clobbering protection (mostly for Traceur)
  var curSystem;
  var callCounter = 0;
  function preExec(loader, load) {
    curLoad = load;
    if (callCounter++ == 0)
      curSystem = __global.System;
    __global.System = __global.SystemJS = loader; 
  }
  function postExec() {
    if (--callCounter == 0)
      __global.System = __global.SystemJS = curSystem;
    curLoad = undefined;
  }

  var vm;
  __exec = function(load) {
    if (!load.source)
      return;
    if ((load.metadata.integrity || load.metadata.nonce) && supportsScriptExec)
      return scriptExec.call(this, load);
    try {
      preExec(this, load);
      curLoad = load;
      // global scoped eval for node (avoids require scope leak)
      if (this._nodeRequire) {
        vm = vm || this._nodeRequire('vm');
        vm.runInThisContext(getSource(load));
      }
      else {
        (0, eval)(getSource(load));
      }
      postExec();
    }
    catch(e) {
      postExec(); 
      throw addToError(e, 'Evaluating ' + load.address);
    }
  };

  var supportsScriptExec = false;
  if (isBrowser && typeof document != 'undefined' && document.getElementsByTagName) {
    var scripts = document.getElementsByTagName('script');
    $__curScript = scripts[scripts.length - 1];

    if (!(window.chrome && window.chrome.extension || navigator.userAgent.match(/^Node\.js/)))
      supportsScriptExec = true;
  }

  // script execution via injecting a script tag into the page
  // this allows CSP integrity and nonce to be set for CSP environments
  var head;
  function scriptExec(load) {
    if (!head)
      head = document.head || document.body || document.documentElement;

    var script = document.createElement('script');
    script.text = getSource(load, false);
    var onerror = window.onerror;
    var e;
    window.onerror = function(_e) {
      e = addToError(_e, 'Evaluating ' + load.address);
    }
    preExec(this, load);

    if (load.metadata.integrity)
      script.setAttribute('integrity', load.metadata.integrity);
    if (load.metadata.nonce)
      script.setAttribute('nonce', load.metadata.nonce);

    head.appendChild(script);
    head.removeChild(script);
    postExec();
    window.onerror = onerror;
    if (e)
      throw e;
  }

})();
var absURLRegEx = /^[^\/]+:\/\//;

function readMemberExpression(p, value) {
  var pParts = p.split('.');
  while (pParts.length)
    value = value[pParts.shift()];
  return value;
}

var baseURLCache = {};
function getBaseURLObj() {
  if (baseURLCache[this.baseURL])
    return baseURLCache[this.baseURL];

  // normalize baseURL if not already
  if (this.baseURL[this.baseURL.length - 1] != '/')
    this.baseURL += '/';

  var baseURL = new URL(this.baseURL, baseURI);

  this.baseURL = baseURL.href;

  return (baseURLCache[this.baseURL] = baseURL);
}

function getMapMatch(map, name) {
  var bestMatch, bestMatchLength = 0;

  for (var p in map) {
    if (name.substr(0, p.length) == p && (name.length == p.length || name[p.length] == '/')) {
      var curMatchLength = p.split('/').length;
      if (curMatchLength <= bestMatchLength)
        continue;
      bestMatch = p;
      bestMatchLength = curMatchLength;
    }
  }

  return bestMatch;
}

function setProduction(isProduction) {
  this.set('@system-env', this.newModule({
    browser: isBrowser,
    node: !!this._nodeRequire,
    production: isProduction,
    'default': true
  }));
}

var baseURIObj = new URL(baseURI);

hookConstructor(function(constructor) {
  return function() {
    constructor.call(this);

    // support baseURL
    this.baseURL = baseURI.substr(0, baseURI.lastIndexOf('/') + 1);

    // support map and paths
    this.map = {};
    this.paths = {};

    // global behaviour flags
    this.warnings = false;
    this.defaultJSExtensions = false;
    this.pluginFirst = false;
    this.loaderErrorStack = false;

    // by default load ".json" files as json
    // leading * meta doesn't need normalization
    // NB add this in next breaking release
    // this.meta['*.json'] = { format: 'json' };

    // support the empty module, as a concept
    this.set('@empty', this.newModule({}));

    setProduction.call(this, false);
  };
});

// include the node require since we're overriding it
if (typeof require != 'undefined' && typeof process != 'undefined' && !process.browser)
  SystemJSLoader.prototype._nodeRequire = require;

var nodeCoreModules = ['assert', 'buffer', 'child_process', 'cluster', 'console', 'constants', 
    'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'module', 'net', 'os', 'path', 
    'process', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'sys', 'timers', 
    'tls', 'tty', 'url', 'util', 'vm', 'zlib'];

/*
  Core SystemJS Normalization

  If a name is relative, we apply URL normalization to the page
  If a name is an absolute URL, we leave it as-is

  Plain names (neither of the above) run through the map and paths
  normalization phases.

  The paths normalization phase applies last (paths extension), which
  defines the `decanonicalize` function and normalizes everything into
  a URL.
 */

function isPlain(name) {
  return (name[0] != '.' || (!!name[1] && name[1] != '/' && name[1] != '.')) && name[0] != '/' && !name.match(absURLRegEx);
}

function urlResolve(name, parent) {
  if (parent)
    parent = parent.replace(/#/g, '%05');
  return new URL(name, parent || baseURIObj).href.replace(/%05/g, '#');
}

// only applies to plain names
function baseURLResolve(loader, name) {
  return new URL(name, getBaseURLObj.call(loader)).href;
}

function coreResolve(name, parentName) {
  // standard URL resolution
  if (!isPlain(name))
    return urlResolve(name, parentName);

  // plain names not starting with './', '://' and '/' go through custom resolution
  var mapMatch = getMapMatch(this.map, name);

  if (mapMatch) {
    name = this.map[mapMatch] + name.substr(mapMatch.length);

    if (!isPlain(name))
      return urlResolve(name);
  }

  if (this.has(name))
    return name;
  // dynamically load node-core modules when requiring `@node/fs` for example
  if (name.substr(0, 6) == '@node/' && nodeCoreModules.indexOf(name.substr(6)) != -1) {
    if (!this._nodeRequire)
      throw new TypeError('Error loading ' + name + '. Can only load node core modules in Node.');
    this.set(name, this.newModule(getESModule(this._nodeRequire(name.substr(6)))));
    return name;
  }

  var pathed = applyPaths(this.paths, name);

  if (pathed && !isPlain(pathed))
    return urlResolve(pathed);

  return baseURLResolve(this, pathed || name);
}

hook('normalize', function(normalize) {
  return function(name, parentName, skipExt) {
    var resolved = coreResolve.call(this, name, parentName);
    if (!skipExt && this.defaultJSExtensions && resolved.substr(resolved.length - 3, 3) != '.js' && !isPlain(resolved))
      resolved += '.js';
    return resolved;
  };
});

// percent encode just '#' in urls if using HTTP requests
var httpRequest = typeof XMLHttpRequest != 'undefined';
hook('locate', function(locate) {
  return function(load) {
    return Promise.resolve(locate.call(this, load))
    .then(function(address) {
      if (httpRequest)
        return address.replace(/#/g, '%23');
      return address;
    });
  };
});

/*
 * Fetch with authorization
 */
hook('fetch', function() {
  return function(load) {
    return new Promise(function(resolve, reject) {
      fetchTextFromURL(load.address, load.metadata.authorization, resolve, reject);
    });
  };
});

/*
  __useDefault
  
  When a module object looks like:
  newModule(
    __useDefault: true,
    default: 'some-module'
  })

  Then importing that module provides the 'some-module'
  result directly instead of the full module.

  Useful for eg module.exports = function() {}
*/
hook('import', function(systemImport) {
  return function(name, parentName, parentAddress) {
    if (parentName && parentName.name)
      warn.call(this, 'SystemJS.import(name, { name: parentName }) is deprecated for SystemJS.import(name, parentName), while importing ' + name + ' from ' + parentName.name);
    return systemImport.call(this, name, parentName, parentAddress).then(function(module) {
      return module.__useDefault ? module['default'] : module;
    });
  };
});

/*
 * Allow format: 'detect' meta to enable format detection
 */
hook('translate', function(systemTranslate) {
  return function(load) {
    if (load.metadata.format == 'detect')
      load.metadata.format = undefined;
    return systemTranslate.call(this, load);
  };
});


/*
 * JSON format support
 *
 * Supports loading JSON files as a module format itself
 *
 * Usage:
 *
 * SystemJS.config({
 *   meta: {
 *     '*.json': { format: 'json' }
 *   }
 * });
 *
 * Module is returned as if written:
 *
 * export default {JSON}
 *
 * No named exports are provided
 *
 * Files ending in ".json" are treated as json automatically by SystemJS
 */
hook('instantiate', function(instantiate) {
  return function(load) {
    if (load.metadata.format == 'json' && !this.builder) {
      var entry = load.metadata.entry = createEntry();
      entry.deps = [];
      entry.execute = function() {
        try {
          return JSON.parse(load.source);
        }
        catch(e) {
          throw new Error("Invalid JSON file " + load.name);
        }
      };
    }
  };
})

/*
 Extend config merging one deep only

  loader.config({
    some: 'random',
    config: 'here',
    deep: {
      config: { too: 'too' }
    }
  });

  <=>

  loader.some = 'random';
  loader.config = 'here'
  loader.deep = loader.deep || {};
  loader.deep.config = { too: 'too' };


  Normalizes meta and package configs allowing for:

  SystemJS.config({
    meta: {
      './index.js': {}
    }
  });

  To become

  SystemJS.meta['https://thissite.com/index.js'] = {};

  For easy normalization canonicalization with latest URL support.

*/
SystemJSLoader.prototype.env = 'development';

var curCurScript;
SystemJSLoader.prototype.config = function(cfg) {
  var loader = this;

  if ('loaderErrorStack' in cfg) {
    curCurScript = $__curScript;
    if (cfg.loaderErrorStack)
      $__curScript = undefined;
    else
      $__curScript = curCurScript;
  }

  if ('warnings' in cfg)
    loader.warnings = cfg.warnings;

  // transpiler deprecation path
  if (cfg.transpilerRuntime === false)
    loader._loader.loadedTranspilerRuntime = true;

  // always configure baseURL first
  if (cfg.baseURL) {
    var hasConfig = false;
    function checkHasConfig(obj) {
      for (var p in obj)
        if (hasOwnProperty.call(obj, p))
          return true;
    }
    if (checkHasConfig(loader.packages) || checkHasConfig(loader.meta) || checkHasConfig(loader.depCache) || checkHasConfig(loader.bundles) || checkHasConfig(loader.packageConfigPaths))
      throw new TypeError('Incorrect configuration order. The baseURL must be configured with the first SystemJS.config call.');

    loader.baseURL = cfg.baseURL;

    // sanitize baseURL
    getBaseURLObj.call(loader);
  }

  if (cfg.defaultJSExtensions) {
    loader.defaultJSExtensions = cfg.defaultJSExtensions;
    warn.call(loader, 'The defaultJSExtensions configuration option is deprecated, use packages configuration instead.');
  }

  if (cfg.pluginFirst)
    loader.pluginFirst = cfg.pluginFirst;

  if (cfg.production)
    setProduction.call(loader, true);

  if (cfg.paths) {
    for (var p in cfg.paths)
      loader.paths[p] = cfg.paths[p];
  }

  if (cfg.map) {
    var objMaps = '';
    for (var p in cfg.map) {
      var v = cfg.map[p];

      // object map backwards-compat into packages configuration
      if (typeof v !== 'string') {
        objMaps += (objMaps.length ? ', ' : '') + '"' + p + '"';

        var defaultJSExtension = loader.defaultJSExtensions && p.substr(p.length - 3, 3) != '.js';
        var prop = loader.decanonicalize(p);
        if (defaultJSExtension && prop.substr(prop.length - 3, 3) == '.js')
          prop = prop.substr(0, prop.length - 3);

        // if a package main, revert it
        var pkgMatch = '';
        for (var pkg in loader.packages) {
          if (prop.substr(0, pkg.length) == pkg 
              && (!prop[pkg.length] || prop[pkg.length] == '/') 
              && pkgMatch.split('/').length < pkg.split('/').length)
            pkgMatch = pkg;
        }
        if (pkgMatch && loader.packages[pkgMatch].main)
          prop = prop.substr(0, prop.length - loader.packages[pkgMatch].main.length - 1);

        var pkg = loader.packages[prop] = loader.packages[prop] || {};
        pkg.map = v;
      }
      else {
        loader.map[p] = v;
      }
    }
    if (objMaps)
      warn.call(loader, 'The map configuration for ' + objMaps + ' uses object submaps, which is deprecated in global map.\nUpdate this to use package contextual map with configs like SystemJS.config({ packages: { "' + p + '": { map: {...} } } }).');
  }

  if (cfg.packageConfigPaths) {
    var packageConfigPaths = [];
    for (var i = 0; i < cfg.packageConfigPaths.length; i++) {
      var path = cfg.packageConfigPaths[i];
      var packageLength = Math.max(path.lastIndexOf('*') + 1, path.lastIndexOf('/'));
      var defaultJSExtension = loader.defaultJSExtensions && path.substr(packageLength - 3, 3) != '.js';
      var normalized = loader.decanonicalize(path.substr(0, packageLength));
      if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) == '.js')
        normalized = normalized.substr(0, normalized.length - 3);
      packageConfigPaths[i] = normalized + path.substr(packageLength);
    }
    loader.packageConfigPaths = packageConfigPaths;
  }

  if (cfg.bundles) {
    for (var p in cfg.bundles) {
      var bundle = [];
      for (var i = 0; i < cfg.bundles[p].length; i++) {
        var defaultJSExtension = loader.defaultJSExtensions && cfg.bundles[p][i].substr(cfg.bundles[p][i].length - 3, 3) != '.js';
        var normalizedBundleDep = loader.decanonicalize(cfg.bundles[p][i]);
        if (defaultJSExtension && normalizedBundleDep.substr(normalizedBundleDep.length - 3, 3) == '.js')
          normalizedBundleDep = normalizedBundleDep.substr(0, normalizedBundleDep.length - 3);
        bundle.push(normalizedBundleDep);
      }
      loader.bundles[p] = bundle;
    }
  }

  if (cfg.packages) {
    for (var p in cfg.packages) {
      if (p.match(/^([^\/]+:)?\/\/$/))
        throw new TypeError('"' + p + '" is not a valid package name.');

      var prop = coreResolve.call(loader, p);

      // allow trailing slash in packages
      if (prop[prop.length - 1] == '/')
        prop = prop.substr(0, prop.length - 1);

      loader.packages[prop] = loader.packages[prop] || {};

      var pkg = cfg.packages[p];

      // meta backwards compatibility
      if (pkg.modules) {
        warn.call(loader, 'Package ' + p + ' is configured with "modules", which is deprecated as it has been renamed to "meta".');
        pkg.meta = pkg.modules;
        delete pkg.modules;
      }

      if (typeof pkg.main == 'object') {
        pkg.map = pkg.map || {};
        pkg.map['./@main'] = pkg.main;
        pkg.main['default'] = pkg.main['default'] || './';
        pkg.main = '@main';
      }

      for (var q in pkg)
        if (indexOf.call(packageProperties, q) == -1)
          warn.call(loader, '"' + q + '" is not a valid package configuration option in package ' + p);

      extendMeta(loader.packages[prop], pkg);
    }
  }

  for (var c in cfg) {
    var v = cfg[c];

    if (c == 'baseURL' || c == 'map' || c == 'packages' || c == 'bundles' || c == 'paths' || c == 'warnings' || c == 'packageConfigPaths' || c == 'loaderErrorStack')
      continue;

    if (typeof v != 'object' || v instanceof Array) {
      loader[c] = v;
    }
    else {
      loader[c] = loader[c] || {};

      for (var p in v) {
        // base-level wildcard meta does not normalize to retain catch-all quality
        if (c == 'meta' && p[0] == '*') {
          loader[c][p] = v[p];
        }
        else if (c == 'meta') {
          // meta can go through global map, with defaultJSExtensions adding
          var resolved = coreResolve.call(loader, p);
          if (loader.defaultJSExtensions && resolved.substr(resolved.length - 3, 3) != '.js' && !isPlain(resolved))
            resolved += '.js';
          loader[c][resolved] = v[p];
        }
        else if (c == 'depCache') {
          var defaultJSExtension = loader.defaultJSExtensions && p.substr(p.length - 3, 3) != '.js';
          var prop = loader.decanonicalize(p);
          if (defaultJSExtension && prop.substr(prop.length - 3, 3) == '.js')
            prop = prop.substr(0, prop.length - 3);
          loader[c][prop] = v[p];
        }
        else {
          loader[c][p] = v[p];
        }
      }
    }
  }
};/*
 * Package Configuration Extension
 *
 * Example:
 *
 * SystemJS.packages = {
 *   jquery: {
 *     main: 'index.js', // when not set, package name is requested directly
 *     format: 'amd',
 *     defaultExtension: 'ts', // defaults to 'js', can be set to false
 *     modules: {
 *       '*.ts': {
 *         loader: 'typescript'
 *       },
 *       'vendor/sizzle.js': {
 *         format: 'global'
 *       }
 *     },
 *     map: {
 *        // map internal require('sizzle') to local require('./vendor/sizzle')
 *        sizzle: './vendor/sizzle.js',
 *        // map any internal or external require of 'jquery/vendor/another' to 'another/index.js'
 *        './vendor/another.js': './another/index.js',
 *        // test.js / test -> lib/test.js
 *        './test.js': './lib/test.js',
 *
 *        // environment-specific map configurations
 *        './index.js': {
 *          '~browser': './index-node.js'
 *        }
 *     },
 *     // allows for setting package-prefixed depCache
 *     // keys are normalized module names relative to the package itself
 *     depCache: {
 *       // import 'package/index.js' loads in parallel package/lib/test.js,package/vendor/sizzle.js
 *       './index.js': ['./test'],
 *       './test.js': ['external-dep'],
 *       'external-dep/path.js': ['./another.js']
 *     }
 *   }
 * };
 *
 * Then:
 *   import 'jquery'                       -> jquery/index.js
 *   import 'jquery/submodule'             -> jquery/submodule.js
 *   import 'jquery/submodule.ts'          -> jquery/submodule.ts loaded as typescript
 *   import 'jquery/vendor/another'        -> another/index.js
 *
 * Detailed Behaviours
 * - main can have a leading "./" can be added optionally
 * - map and defaultExtension are applied to the main
 * - defaultExtension adds the extension only if the exact extension is not present
 * - defaultJSExtensions applies after map when defaultExtension is not set
 * - if a meta value is available for a module, map and defaultExtension are skipped
 * - like global map, package map also applies to subpaths (sizzle/x, ./vendor/another/sub)
 * - condition module map is '@env' module in package or '@system-env' globally
 * - map targets support conditional interpolation ('./x': './x.#{|env}.js')
 * - internal package map targets cannot use boolean conditionals
 *
 * Package Configuration Loading
 *
 * Not all packages may already have their configuration present in the System config
 * For these cases, a list of packageConfigPaths can be provided, which when matched against
 * a request, will first request a ".json" file by the package name to derive the package
 * configuration from. This allows dynamic loading of non-predetermined code, a key use
 * case in SystemJS.
 *
 * Example:
 *
 *   SystemJS.packageConfigPaths = ['packages/test/package.json', 'packages/*.json'];
 *
 *   // will first request 'packages/new-package/package.json' for the package config
 *   // before completing the package request to 'packages/new-package/path'
 *   SystemJS.import('packages/new-package/path');
 *
 *   // will first request 'packages/test/package.json' before the main
 *   SystemJS.import('packages/test');
 *
 * When a package matches packageConfigPaths, it will always send a config request for
 * the package configuration.
 * The package name itself is taken to be the match up to and including the last wildcard
 * or trailing slash.
 * The most specific package config path will be used.
 * Any existing package configurations for the package will deeply merge with the
 * package config, with the existing package configurations taking preference.
 * To opt-out of the package configuration request for a package that matches
 * packageConfigPaths, use the { configured: true } package config option.
 *
 */
(function() {

  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.packages = {};
      this.packageConfigPaths = [];
    };
  });

  function getPackage(loader, normalized) {
    // use most specific package
    var curPkg, curPkgLen = 0, pkgLen;
    for (var p in loader.packages) {
      if (normalized.substr(0, p.length) === p && (normalized.length === p.length || normalized[p.length] === '/')) {
        pkgLen = p.split('/').length;
        if (pkgLen > curPkgLen) {
          curPkg = p;
          curPkgLen = pkgLen;
        }
      }
    }
    return curPkg;
  }

  function addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions) {
    // don't apply extensions to folders or if defaultExtension = false
    if (!subPath || subPath[subPath.length - 1] == '/' || skipExtensions || pkg.defaultExtension === false)
      return subPath;

    // NB are you sure about this?
    // skip if we have interpolation conditional syntax in subPath?
    if (subPath.match(interpolationRegEx))
      return subPath;

    var metaMatch = false;

    // exact meta or meta with any content after the last wildcard skips extension
    if (pkg.meta)
      getMetaMatches(pkg.meta, subPath, function(metaPattern, matchMeta, matchDepth) {
        if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1)
          return metaMatch = true;
      });

    // exact global meta or meta with any content after the last wildcard skips extension
    if (!metaMatch && loader.meta)
      getMetaMatches(loader.meta, pkgName + '/' + subPath, function(metaPattern, matchMeta, matchDepth) {
        if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1)
          return metaMatch = true;
      });

    if (metaMatch)
      return subPath;

    // work out what the defaultExtension is and add if not there already
    // NB reconsider if default should really be ".js"?
    var defaultExtension = '.' + (pkg.defaultExtension || 'js');
    if (subPath.substr(subPath.length - defaultExtension.length) != defaultExtension)
      return subPath + defaultExtension;
    else
      return subPath;
  }

  function applyPackageConfigSync(loader, pkg, pkgName, subPath, skipExtensions) {
    // main
    if (!subPath) {
      if (pkg.main)
        subPath = pkg.main.substr(0, 2) == './' ? pkg.main.substr(2) : pkg.main;
      // also no submap if name is package itself (import 'pkg' -> 'path/to/pkg.js')
      else
        // NB can add a default package main convention here when defaultJSExtensions is deprecated
        // if it becomes internal to the package then it would no longer be an exit path
        return pkgName + (loader.defaultJSExtensions ? '.js' : '');
    }

    // map config checking without then with extensions
    if (pkg.map) {
      var mapPath = './' + subPath;

      var mapMatch = getMapMatch(pkg.map, mapPath);

      // we then check map with the default extension adding
      if (!mapMatch) {
        mapPath = './' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
        if (mapPath != './' + subPath)
          mapMatch = getMapMatch(pkg.map, mapPath);
      }
      if (mapMatch)
        return doMapSync(loader, pkg, pkgName, mapMatch, mapPath, skipExtensions);
    }

    // normal package resolution
    return pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
  }

  function validateMapping(mapMatch, mapped, pkgName) {
    // disallow internal to subpath maps
    if (mapMatch == '.')
      throw new Error('Package ' + pkgName + ' has a map entry for "." which is not permitted.');
    // disallow internal ./x -> ./x/y recursive maps
    else if (mapped.substr(0, mapMatch.length) == mapMatch && (mapMatch[mapMatch.length - 1] != '/' && mapped[mapMatch.length] == '/'))
      throw new Error('Package ' + pkgName + ' has a recursive map for "' + mapMatch + '" which is not permitted.');
  }

  function doMapSync(loader, pkg, pkgName, mapMatch, path, skipExtensions) {
    var mapped = pkg.map[mapMatch];

    if (typeof mapped == 'object')
      throw new Error('Synchronous conditional normalization not supported sync normalizing ' + mapMatch + ' in ' + pkgName);

    validateMapping(mapMatch, mapped, pkgName);

    // ignore conditionals in sync
    if (typeof mapped != 'string')
      mapped = mapMatch = path;

    validateMapping(mapMatch, mapped, pkgName);

    // package map to main / base-level
    if (mapped == '.')
      mapped = pkgName;

    // internal package map
    else if (mapped.substr(0, 2) == './')
      return pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, mapped.substr(2) + path.substr(mapMatch.length), skipExtensions);
    
    // external map reference
    return loader.normalizeSync(mapped + path.substr(mapMatch.length), pkgName + '/');
  }

  function applyPackageConfig(loader, pkg, pkgName, subPath, skipExtensions) {
    // main
    if (!subPath) {
      if (pkg.main)
        subPath = pkg.main.substr(0, 2) == './' ? pkg.main.substr(2) : pkg.main;
      // also no submap if name is package itself (import 'pkg' -> 'path/to/pkg.js')
      else
        // NB can add a default package main convention here when defaultJSExtensions is deprecated
        // if it becomes internal to the package then it would no longer be an exit path
        return Promise.resolve(pkgName + (loader.defaultJSExtensions ? '.js' : ''));
    }

    // map config checking without then with extensions
    var mapPath, mapMatch;

    if (pkg.map) {
      mapPath = './' + subPath;
      mapMatch = getMapMatch(pkg.map, mapPath);

      // we then check map with the default extension adding
      if (!mapMatch) {
        mapPath = './' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions);
        if (mapPath != './' + subPath)
          mapMatch = getMapMatch(pkg.map, mapPath);
      }
    }

    return (mapMatch ? doMap(loader, pkg, pkgName, mapMatch, mapPath, skipExtensions) : Promise.resolve())
    .then(function(mapped) {
      if (mapped)
        return Promise.resolve(mapped);

      // normal package resolution / fallback resolution for no conditional match
      return Promise.resolve(pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, subPath, skipExtensions));
    });
  }

  function doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions) {
    // NB the interpolation cases should strictly skip subsequent interpolation

    // package map to main / base-level
    if (mapped == '.')
      mapped = pkgName;
    
    // internal package map
    else if (mapped.substr(0, 2) == './')
      return Promise.resolve(pkgName + '/' + addDefaultExtension(loader, pkg, pkgName, mapped.substr(2) + path.substr(mapMatch.length), skipExtensions))
      .then(function(name) {
        return interpolateConditional.call(loader, name, pkgName + '/');
      });
    
    // external map reference
    return loader.normalize(mapped + path.substr(mapMatch.length), pkgName + '/');
  }

  function doMap(loader, pkg, pkgName, mapMatch, path, skipExtensions) {
    var mapped = pkg.map[mapMatch];

    if (typeof mapped == 'string') {
      validateMapping(mapMatch, mapped, pkgName);
      return doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions);
    }

    // we use a special conditional syntax to allow the builder to handle conditional branch points further
    if (loader.builder)
      return Promise.resolve(pkgName + '/#:' + path);

    // map object -> conditional map
    return loader['import'](pkg.map['@env'] || '@system-env', pkgName)
    .then(function(env) {
      // first map condition to match is used
      for (var e in mapped) {
        var negate = e[0] == '~';

        var value = readMemberExpression(negate ? e.substr(1) : e, env);

        if (!negate && value || negate && !value)
          return mapped[e];
      }
    })
    .then(function(mapped) {
      if (mapped) {
        if (typeof mapped != 'string')
          throw new Error('Unable to map a package conditional to a package conditional.');
        validateMapping(mapMatch, mapped, pkgName);
        return doStringMap(loader, pkg, pkgName, mapMatch, mapped, path, skipExtensions);
      }

      // no environment match -> fallback to original subPath by returning undefined
    });
  }

  // normalizeSync = decanonicalize + package resolution
  SystemJSLoader.prototype.normalizeSync = SystemJSLoader.prototype.decanonicalize = SystemJSLoader.prototype.normalize;

  // decanonicalize must JUST handle package defaultExtension: false case when defaultJSExtensions is set
  // to be deprecated!
  hook('decanonicalize', function(decanonicalize) {
    return function(name, parentName) {
      if (this.builder)
        return decanonicalize.call(this, name, parentName, true);

      var decanonicalized = decanonicalize.call(this, name, parentName);

      if (!this.defaultJSExtensions)
        return decanonicalized;
    
      var pkgName = getPackage(this, decanonicalized);

      var pkg = this.packages[pkgName];
      var defaultExtension = pkg && pkg.defaultExtension;

      if (defaultExtension == undefined && pkg && pkg.meta)
        getMetaMatches(pkg.meta, decanonicalized.substr(pkgName), function(metaPattern, matchMeta, matchDepth) {
          if (matchDepth == 0 || metaPattern.lastIndexOf('*') != metaPattern.length - 1) {
            defaultExtension = false;
            return true;
          }
        });
      
      if ((defaultExtension === false || defaultExtension && defaultExtension != '.js') && name.substr(name.length - 3, 3) != '.js' && decanonicalized.substr(decanonicalized.length - 3, 3) == '.js')
        decanonicalized = decanonicalized.substr(0, decanonicalized.length - 3);

      return decanonicalized;
    };
  });

  hook('normalizeSync', function(normalizeSync) {
    return function(name, parentName, isPlugin) {
      warn.call(this, 'SystemJS.normalizeSync has been deprecated for SystemJS.decanonicalize.');

      var loader = this;
      isPlugin = isPlugin === true;

      // apply contextual package map first
      // (we assume the parent package config has already been loaded)
      if (parentName)
        var parentPackageName = getPackage(loader, parentName) ||
            loader.defaultJSExtensions && parentName.substr(parentName.length - 3, 3) == '.js' &&
            getPackage(loader, parentName.substr(0, parentName.length - 3));

      var parentPackage = parentPackageName && loader.packages[parentPackageName];

      // ignore . since internal maps handled by standard package resolution
      if (parentPackage && name[0] != '.') {
        var parentMap = parentPackage.map;
        var parentMapMatch = parentMap && getMapMatch(parentMap, name);

        if (parentMapMatch && typeof parentMap[parentMapMatch] == 'string')
          return doMapSync(loader, parentPackage, parentPackageName, parentMapMatch, name, isPlugin);
      }

      var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';

      // apply map, core, paths, contextual package map
      var normalized = normalizeSync.call(loader, name, parentName);

      // undo defaultJSExtension
      if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) != '.js')
        defaultJSExtension = false;
      if (defaultJSExtension)
        normalized = normalized.substr(0, normalized.length - 3);

      var pkgConfigMatch = getPackageConfigMatch(loader, normalized);
      var pkgName = pkgConfigMatch && pkgConfigMatch.packageName || getPackage(loader, normalized);

      if (!pkgName)
        return normalized + (defaultJSExtension ? '.js' : '');

      var subPath = normalized.substr(pkgName.length + 1);

      return applyPackageConfigSync(loader, loader.packages[pkgName] || {}, pkgName, subPath, isPlugin);
    };
  });

  hook('normalize', function(normalize) {
    return function(name, parentName, isPlugin) {
      var loader = this;
      isPlugin = isPlugin === true;

      return Promise.resolve()
      .then(function() {
        // apply contextual package map first
        // (we assume the parent package config has already been loaded)
        if (parentName)
          var parentPackageName = getPackage(loader, parentName) ||
              loader.defaultJSExtensions && parentName.substr(parentName.length - 3, 3) == '.js' &&
              getPackage(loader, parentName.substr(0, parentName.length - 3));

        var parentPackage = parentPackageName && loader.packages[parentPackageName];

        // ignore . since internal maps handled by standard package resolution
        if (parentPackage && name.substr(0, 2) != './') {
          var parentMap = parentPackage.map;
          var parentMapMatch = parentMap && getMapMatch(parentMap, name);

          if (parentMapMatch)
            return doMap(loader, parentPackage, parentPackageName, parentMapMatch, name, isPlugin);
        }

        return Promise.resolve();
      })
      .then(function(mapped) {
        if (mapped)
          return mapped;

        var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';

        // apply map, core, paths, contextual package map
        var normalized = normalize.call(loader, name, parentName);

        // undo defaultJSExtension
        if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) != '.js')
          defaultJSExtension = false;
        if (defaultJSExtension)
          normalized = normalized.substr(0, normalized.length - 3);

        var pkgConfigMatch = getPackageConfigMatch(loader, normalized);
        var pkgName = pkgConfigMatch && pkgConfigMatch.packageName || getPackage(loader, normalized);

        if (!pkgName)
          return Promise.resolve(normalized + (defaultJSExtension ? '.js' : ''));

        var pkg = loader.packages[pkgName];

        // if package is already configured or not a dynamic config package, use existing package config
        var isConfigured = pkg && (pkg.configured || !pkgConfigMatch);
        return (isConfigured ? Promise.resolve(pkg) : loadPackageConfigPath(loader, pkgName, pkgConfigMatch.configPath))
        .then(function(pkg) {
          var subPath = normalized.substr(pkgName.length + 1);

          return applyPackageConfig(loader, pkg, pkgName, subPath, isPlugin);
        });
      });
    };
  });

  // check if the given normalized name matches a packageConfigPath
  // if so, loads the config
  var packageConfigPaths = {};

  // data object for quick checks against package paths
  function createPkgConfigPathObj(path) {
    var lastWildcard = path.lastIndexOf('*');
    var length = Math.max(lastWildcard + 1, path.lastIndexOf('/'));
    return {
      length: length,
      regEx: new RegExp('^(' + path.substr(0, length).replace(/[.+?^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '[^\\/]+') + ')(\\/|$)'),
      wildcard: lastWildcard != -1
    };
  }

  // most specific match wins
  function getPackageConfigMatch(loader, normalized) {
    var pkgName, exactMatch = false, configPath;
    for (var i = 0; i < loader.packageConfigPaths.length; i++) {
      var packageConfigPath = loader.packageConfigPaths[i];
      var p = packageConfigPaths[packageConfigPath] || (packageConfigPaths[packageConfigPath] = createPkgConfigPathObj(packageConfigPath));
      if (normalized.length < p.length)
        continue;
      var match = normalized.match(p.regEx);
      if (match && (!pkgName || (!(exactMatch && p.wildcard) && pkgName.length < match[1].length))) {
        pkgName = match[1];
        exactMatch = !p.wildcard;
        configPath = pkgName + packageConfigPath.substr(p.length);
      }
    }

    if (!pkgName)
      return;

    return {
      packageName: pkgName,
      configPath: configPath
    };
  }

  function loadPackageConfigPath(loader, pkgName, pkgConfigPath) {
    var configLoader = loader.pluginLoader || loader;

    // NB remove this when json is default
    (configLoader.meta[pkgConfigPath] = configLoader.meta[pkgConfigPath] || {}).format = 'json';
    configLoader.meta[pkgConfigPath].loader = null;

    return configLoader.load(pkgConfigPath)
    .then(function() {
      var cfg = configLoader.get(pkgConfigPath)['default'];

      // support "systemjs" prefixing
      if (cfg.systemjs)
        cfg = cfg.systemjs;

      // modules backwards compatibility
      if (cfg.modules) {
        cfg.meta = cfg.modules;
        warn.call(loader, 'Package config file ' + pkgConfigPath + ' is configured with "modules", which is deprecated as it has been renamed to "meta".');
      }

      // remove any non-system properties if generic config file (eg package.json)
      for (var p in cfg) {
        if (indexOf.call(packageProperties, p) == -1)
          delete cfg[p];
      }

      // deeply-merge (to first level) config with any existing package config
      var pkg = loader.packages[pkgName] = loader.packages[pkgName] || {};
      extendMeta(pkg, cfg, true);

      // support external depCache
      if (cfg.depCache) {
        for (var d in cfg.depCache) {
          var dNormalized;

          if (d.substr(0, 2) == './')
            dNormalized = pkgName + '/' + d.substr(2);
          else
            dNormalized = coreResolve.call(loader, d);
          loader.depCache[dNormalized] = (loader.depCache[dNormalized] || []).concat(cfg.depCache[d]);
        }
        delete cfg.depCache;
      }

      // main object becomes main map
      if (typeof pkg.main == 'object') {
        pkg.map = pkg.map || {};
        pkg.map['./@main'] = pkg.main;
        pkg.main['default'] = pkg.main['default'] || './';
        pkg.main = '@main';
      }

      return pkg;
    });
  }

  function getMetaMatches(pkgMeta, subPath, matchFn) {
    // wildcard meta
    var meta = {};
    var wildcardIndex;
    for (var module in pkgMeta) {
      // allow meta to start with ./ for flexibility
      var dotRel = module.substr(0, 2) == './' ? './' : '';
      if (dotRel)
        module = module.substr(2);

      wildcardIndex = module.indexOf('*');
      if (wildcardIndex === -1)
        continue;

      if (module.substr(0, wildcardIndex) == subPath.substr(0, wildcardIndex)
          && module.substr(wildcardIndex + 1) == subPath.substr(subPath.length - module.length + wildcardIndex + 1)) {
        // alow match function to return true for an exit path
        if (matchFn(module, pkgMeta[dotRel + module], module.split('/').length))
          return;
      }
    }
    // exact meta
    var exactMeta = pkgMeta[subPath] && pkgMeta.hasOwnProperty && pkgMeta.hasOwnProperty(subPath) ? pkgMeta[subPath] : pkgMeta['./' + subPath];
    if (exactMeta)
      matchFn(exactMeta, exactMeta, 0);
  }

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      return Promise.resolve(locate.call(this, load))
      .then(function(address) {
        var pkgName = getPackage(loader, load.name);
        if (pkgName) {
          var pkg = loader.packages[pkgName];
          var subPath = load.name.substr(pkgName.length + 1);

          // format
          if (pkg.format)
            load.metadata.format = load.metadata.format || pkg.format;

          var meta = {};
          if (pkg.meta) {
            var bestDepth = 0;

            // NB support a main shorthand in meta here?
            getMetaMatches(pkg.meta, subPath, function(metaPattern, matchMeta, matchDepth) {
              if (matchDepth > bestDepth)
                bestDepth = matchDepth;
              extendMeta(meta, matchMeta, matchDepth && bestDepth > matchDepth);
            });

            extendMeta(load.metadata, meta);
          }
        }

        return address;
      });
    };
  });

})();
/*
 * Script tag fetch
 *
 * When load.metadata.scriptLoad is true, we load via script tag injection.
 */
(function() {

  if (typeof document != 'undefined')
    var head = document.getElementsByTagName('head')[0];

  var curSystem;
  var curRequire;

  // if doing worker executing, this is set to the load record being executed
  var workerLoad = null;
  
  // interactive mode handling method courtesy RequireJS
  var ieEvents = head && (function() {
    var s = document.createElement('script');
    var isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]';
    return s.attachEvent && !(s.attachEvent.toString && s.attachEvent.toString().indexOf('[native code') < 0) && !isOpera;
  })();

  // IE interactive-only part
  // we store loading scripts array as { script: <script>, load: {...} }
  var interactiveLoadingScripts = [];
  var interactiveScript;
  function getInteractiveScriptLoad() {
    if (interactiveScript && interactiveScript.script.readyState === 'interactive')
      return interactiveScript.load;

    for (var i = 0; i < interactiveLoadingScripts.length; i++)
      if (interactiveLoadingScripts[i].script.readyState == 'interactive') {
        interactiveScript = interactiveLoadingScripts[i];
        return interactiveScript.load;
      }
  }
  
  // System.register, System.registerDynamic, AMD define pipeline
  // this is called by the above methods when they execute
  // we then run the reduceRegister_ collection function either immediately
  // if we are in IE and know the currently executing script (interactive)
  // or later if we need to wait for the synchronous load callback to know the script
  var loadingCnt = 0;
  var registerQueue = [];
  hook('pushRegister_', function(pushRegister) {
    return function(register) {
      // if using eval-execution then skip
      if (pushRegister.call(this, register))
        return false;

      // if using worker execution, then we're done
      if (workerLoad)
        this.reduceRegister_(workerLoad, register);

      // detect if we know the currently executing load (IE)
      // if so, immediately call reduceRegister
      else if (ieEvents)
        this.reduceRegister_(getInteractiveScriptLoad(), register);

      // otherwise, add to our execution queue
      // to call reduceRegister on sync script load event
      else if (loadingCnt)
        registerQueue.push(register);

      // if we're not currently loading anything though
      // then do the reduction against a null load
      // (out of band named define or named register)
      // note even in non-script environments, this catch is used
      else
        this.reduceRegister_(null, register);

      return true;
    };
  });

  function webWorkerImport(loader, load) {
    return new Promise(function(resolve, reject) {
      if (load.metadata.integrity)
        reject(new Error('Subresource integrity checking is not supported in web workers.'));

      workerLoad = load;
      try {
        importScripts(load.address);
      }
      catch(e) {
        workerLoad = null;
        reject(e);
      }
      workerLoad = null;

      // if nothing registered, then something went wrong
      if (!load.metadata.entry)
        reject(new Error(load.address + ' did not call System.register or AMD define'));

      resolve('');
    });
  }

  // override fetch to use script injection
  hook('fetch', function(fetch) {
    return function(load) {
      var loader = this;

      if (load.metadata.format == 'json' || !load.metadata.scriptLoad || (!isBrowser && !isWorker))
        return fetch.call(this, load);

      if (isWorker)
        return webWorkerImport(loader, load);

      return new Promise(function(resolve, reject) {
        var s = document.createElement('script');
        
        s.async = true;

        if (load.metadata.crossOrigin)
          s.crossOrigin = load.metadata.crossOrigin;

        if (load.metadata.integrity)
          s.setAttribute('integrity', load.metadata.integrity);

        if (ieEvents) {
          s.attachEvent('onreadystatechange', complete);
          interactiveLoadingScripts.push({
            script: s,
            load: load
          });
        }
        else {
          s.addEventListener('load', complete, false);
          s.addEventListener('error', error, false);
        }

        loadingCnt++;

        curSystem = __global.System;
        curRequire = __global.require;

        s.src = load.address;
        head.appendChild(s);

        function complete(evt) {
          if (s.readyState && s.readyState != 'loaded' && s.readyState != 'complete')
            return;

          loadingCnt--;

          // complete call is sync on execution finish
          // (in ie already done reductions)
          if (!load.metadata.entry && !registerQueue.length) {
            loader.reduceRegister_(load);
          }
          else if (!ieEvents) {
            for (var i = 0; i < registerQueue.length; i++)
              loader.reduceRegister_(load, registerQueue[i]);
            registerQueue = [];
          }

          cleanup();

          // if nothing registered, then something went wrong
          if (!load.metadata.entry && !load.metadata.bundle)
            reject(new Error(load.name + ' did not call System.register or AMD define. If loading a global module configure the global name via the meta exports property for script injection support.'));

          resolve('');
        }

        function error(evt) {
          cleanup();
          reject(new Error('Unable to load script ' + load.address));
        }

        function cleanup() {
          __global.System = curSystem;
          __global.require = curRequire;

          if (s.detachEvent) {
            s.detachEvent('onreadystatechange', complete);
            for (var i = 0; i < interactiveLoadingScripts.length; i++)
              if (interactiveLoadingScripts[i].script == s) {
                if (interactiveScript && interactiveScript.script == s)
                  interactiveScript = null;
                interactiveLoadingScripts.splice(i, 1);
              }
          }
          else {
            s.removeEventListener('load', complete, false);
            s.removeEventListener('error', error, false);
          }

          head.removeChild(s);
        }
      });
    };
  });
})();
/*
 * Instantiate registry extension
 *
 * Supports Traceur System.register 'instantiate' output for loading ES6 as ES5.
 *
 * - Creates the loader.register function
 * - Also supports metadata.format = 'register' in instantiate for anonymous register modules
 * - Also supports metadata.deps, metadata.execute and metadata.executingRequire
 *     for handling dynamic modules alongside register-transformed ES6 modules
 *
 *
 * The code here replicates the ES6 linking groups algorithm to ensure that
 * circular ES6 compiled into System.register can work alongside circular AMD 
 * and CommonJS, identically to the actual ES6 loader.
 *
 */


/*
 * Registry side table entries in loader.defined
 * Registry Entry Contains:
 *    - name
 *    - deps 
 *    - declare for declarative modules
 *    - execute for dynamic modules, different to declarative execute on module
 *    - executingRequire indicates require drives execution for circularity of dynamic modules
 *    - declarative optional boolean indicating which of the above
 *
 * Can preload modules directly on SystemJS.defined['my/module'] = { deps, execute, executingRequire }
 *
 * Then the entry gets populated with derived information during processing:
 *    - normalizedDeps derived from deps, created in instantiate
 *    - groupIndex used by group linking algorithm
 *    - evaluated indicating whether evaluation has happend
 *    - module the module record object, containing:
 *      - exports actual module exports
 *
 *    For dynamic we track the es module with:
 *    - esModule actual es module value
 *    - esmExports whether to extend the esModule with named exports
 *      
 *    Then for declarative only we track dynamic bindings with the 'module' records:
 *      - name
 *      - exports
 *      - setters declarative setter functions
 *      - dependencies, module records of dependencies
 *      - importers, module records of dependents
 *
 * After linked and evaluated, entries are removed, declarative module records remain in separate
 * module binding table
 *
 */

var leadingCommentAndMetaRegEx = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)*\s*/;
function detectRegisterFormat(source) {
  var leadingCommentAndMeta = source.match(leadingCommentAndMetaRegEx);
  return leadingCommentAndMeta && source.substr(leadingCommentAndMeta[0].length, 15) == 'System.register';
}

function createEntry() {
  return {
    name: null,
    deps: null,
    originalIndices: null,
    declare: null,
    execute: null,
    executingRequire: false,
    declarative: false,
    normalizedDeps: null,
    groupIndex: null,
    evaluated: false,
    module: null,
    esModule: null,
    esmExports: false
  };
}

(function() {

  /*
   * There are two variations of System.register:
   * 1. System.register for ES6 conversion (2-3 params) - System.register([name, ]deps, declare)
   *    see https://github.com/ModuleLoader/es6-module-loader/wiki/System.register-Explained
   *
   * 2. System.registerDynamic for dynamic modules (3-4 params) - System.registerDynamic([name, ]deps, executingRequire, execute)
   * the true or false statement 
   *
   * this extension implements the linking algorithm for the two variations identical to the spec
   * allowing compiled ES6 circular references to work alongside AMD and CJS circular references.
   *
   */
  SystemJSLoader.prototype.register = function(name, deps, declare) {
    if (typeof name != 'string') {
      declare = deps;
      deps = name;
      name = null;
    }

    // dynamic backwards-compatibility
    // can be deprecated eventually
    if (typeof declare == 'boolean')
      return this.registerDynamic.apply(this, arguments);

    var entry = createEntry();
    // ideally wouldn't apply map config to bundle names but 
    // dependencies go through map regardless so we can't restrict
    // could reconsider in shift to new spec
    entry.name = name && (this.decanonicalize || this.normalize).call(this, name);
    entry.declarative = true;
    entry.deps = deps;
    entry.declare = declare;

    this.pushRegister_({
      amd: false,
      entry: entry
    });
  };
  SystemJSLoader.prototype.registerDynamic = function(name, deps, declare, execute) {
    if (typeof name != 'string') {
      execute = declare;
      declare = deps;
      deps = name;
      name = null;
    }

    // dynamic
    var entry = createEntry();
    entry.name = name && (this.decanonicalize || this.normalize).call(this, name);
    entry.deps = deps;
    entry.execute = execute;
    entry.executingRequire = declare;

    this.pushRegister_({
      amd: false,
      entry: entry
    });
  };
  hook('reduceRegister_', function() {
    return function(load, register) {
      if (!register)
        return;

      var entry = register.entry;
      var curMeta = load && load.metadata;

      // named register
      if (entry.name) {
        if (!(entry.name in this.defined))
          this.defined[entry.name] = entry;

        if (curMeta)
          curMeta.bundle = true;
      }
      // anonymous register
      if (!entry.name || load && entry.name == load.name) {
        if (!curMeta)
          throw new TypeError('Invalid System.register call. Anonymous System.register calls can only be made by modules loaded by SystemJS.import and not via script tags.');
        if (curMeta.entry) {
          if (curMeta.format == 'register')
            throw new Error('Multiple anonymous System.register calls in module ' + load.name + '. If loading a bundle, ensure all the System.register calls are named.');
          else
            throw new Error('Module ' + load.name + ' interpreted as ' + curMeta.format + ' module format, but called System.register.');
        }
        if (!curMeta.format)
          curMeta.format = 'register';
        curMeta.entry = entry;
      }
    };
  });

  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);

      this.defined = {};
      this._loader.moduleRecords = {};
    };
  });

  function buildGroups(entry, loader, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];
      
      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;
      
      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === null || depEntry.groupIndex < depGroupIndex) {
        
        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== null) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new Error("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, loader, groups);
    }
  }

  function link(name, loader) {
    var startEntry = loader.defined[name];

    // skip if already linked
    if (startEntry.module)
      return;

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, loader, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry, loader);
        else
          linkDynamicModule(entry, loader);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  function ModuleRecord() {}
  defineProperty(ModuleRecord, 'toString', {
    value: function() {
      return 'Module';
    }
  });

  function getOrCreateModuleRecord(name, moduleRecords) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: new ModuleRecord(), // start from an empty module and extend
      importers: []
    });
  }

  function linkDeclarativeModule(entry, loader) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var moduleRecords = loader._loader.moduleRecords;
    var module = entry.module = getOrCreateModuleRecord(entry.name, moduleRecords);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(__global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    }, { id: entry.name });
    
    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute) {
      throw new TypeError('Invalid System.register form for ' + entry.name);
    }

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      // dynamic, already linked in our registry
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the loader registry
      else if (!depEntry) {
        depExports = loader.get(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry, loader);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else {
        module.dependencies.push(null);
      }
      
      // run setters for all entries with the matching dependency name
      var originalIndices = entry.originalIndices[i];
      for (var j = 0, len = originalIndices.length; j < len; ++j) {
        var index = originalIndices[j];
        if (module.setters[index]) {
          module.setters[index](depExports);
        }
      }
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name, loader) {
    var exports;
    var entry = loader.defined[name];

    if (!entry) {
      exports = loader.get(name);
      if (!exports)
        throw new Error('Unable to load dependency ' + name + '.');
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, [], loader);
    
      else if (!entry.evaluated)
        linkDynamicModule(entry, loader);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];
    
    return exports;
  }

  function linkDynamicModule(entry, loader) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        // we know we only need to link dynamic due to linking algorithm
        var depEntry = loader.defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry, loader);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(__global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i], loader);
      }
      // try and normalize the dependency to see if we have another form
      var nameNormalized = loader.normalizeSync(name, entry.name);
      if (indexOf.call(entry.normalizedDeps, nameNormalized) != -1)
        return getModule(nameNormalized, loader);

      throw new Error('Module ' + name + ' not declared as a dependency of ' + entry.name);
    }, exports, module);
    
    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;

    // __esModule flag treats as already-named
    if (exports && (exports.__esModule || exports instanceof Module))
      entry.esModule = exports;
    // set module as 'default' export, then fake named exports by iterating properties
    else if (entry.esmExports && exports !== __global)
      entry.esModule = getESModule(exports);
    // just use the 'default' export
    else
      entry.esModule = { 'default': exports };
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen, loader) {
    var entry = loader.defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!loader.defined[depName])
          loader.get(depName);
        else
          ensureEvaluated(depName, seen, loader);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(__global);
  }

  // override the delete method to also clear the register caches
  hook('delete', function(del) {
    return function(name) {
      delete this._loader.moduleRecords[name];
      delete this.defined[name];
      return del.call(this, name);
    };
  });

  hook('fetch', function(fetch) {
    return function(load) {
      if (this.defined[load.name]) {
        load.metadata.format = 'defined';
        return '';
      }

      load.metadata.deps = load.metadata.deps || [];
      
      return fetch.call(this, load);
    };
  });

  hook('translate', function(translate) {
    // we run the meta detection here (register is after meta)
    return function(load) {
      load.metadata.deps = load.metadata.deps || [];
      return Promise.resolve(translate.call(this, load)).then(function(source) {
        // run detection for register format
        if (load.metadata.format == 'register' || !load.metadata.format && detectRegisterFormat(load.source))
          load.metadata.format = 'register';
        return source;
      });
    };
  });

  hook('instantiate', function(instantiate) {
    return function(load) {
      if (load.metadata.format == 'detect')
        load.metadata.format = undefined;

      // assumes previous instantiate is sync
      // (core json support)
      instantiate.call(this, load);

      var loader = this;

      var entry;

      // first we check if this module has already been defined in the registry
      if (loader.defined[load.name]) {
        entry = loader.defined[load.name];
        // don't support deps for ES modules
        if (!entry.declarative)
          entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // picked up already by an anonymous System.register script injection
      // or via the dynamic formats
      else if (load.metadata.entry) {
        entry = load.metadata.entry;
        entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // Contains System.register calls
      // (dont run bundles in the builder)
      else if (!(loader.builder && load.metadata.bundle) 
          && (load.metadata.format == 'register' || load.metadata.format == 'esm' || load.metadata.format == 'es6')) {
        
        if (typeof __exec != 'undefined')
          __exec.call(loader, load);

        if (!load.metadata.entry && !load.metadata.bundle)
          throw new Error(load.name + ' detected as ' + load.metadata.format + ' but didn\'t execute.');

        entry = load.metadata.entry;

        // support metadata deps for System.register
        if (entry && load.metadata.deps)
          entry.deps = entry.deps.concat(load.metadata.deps);
      }

      // named bundles are just an empty module
      if (!entry) {
        entry = createEntry();
        entry.deps = load.metadata.deps;
        entry.execute = function() {};
      }

      // place this module onto defined for circular references
      loader.defined[load.name] = entry;
      
      var grouped = group(entry.deps);
      
      entry.deps = grouped.names;
      entry.originalIndices = grouped.indices;
      entry.name = load.name;
      entry.esmExports = load.metadata.esmExports !== false;

      // first, normalize all dependencies
      var normalizePromises = [];
      for (var i = 0, l = entry.deps.length; i < l; i++)
        normalizePromises.push(Promise.resolve(loader.normalize(entry.deps[i], load.name)));

      return Promise.all(normalizePromises).then(function(normalizedDeps) {

        entry.normalizedDeps = normalizedDeps;

        return {
          deps: entry.deps,
          execute: function() {
            // recursively ensure that the module and all its 
            // dependencies are linked (with dependency group handling)
            link(load.name, loader);

            // now handle dependency execution in correct order
            ensureEvaluated(load.name, [], loader);

            // remove from the registry
            loader.defined[load.name] = undefined;

            // return the defined module object
            return loader.newModule(entry.declarative ? entry.module.exports : entry.esModule);
          }
        };
      });
    };
  });
})();
/*
 * Extension to detect ES6 and auto-load Traceur or Babel for processing
 */
(function() {
  // good enough ES6 module detection regex - format detections not designed to be accurate, but to handle the 99% use case
  var esmRegEx = /(^\s*|[}\);\n]\s*)(import\s*(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s*from\s*['"]|\{)|export\s+\*\s+from\s+["']|export\s*(\{|default|function|class|var|const|let|async\s+function))/;

  var traceurRuntimeRegEx = /\$traceurRuntime\s*\./;
  var babelHelpersRegEx = /babelHelpers\s*\./;

  hook('translate', function(translate) {
    return function(load) {
      var loader = this;
      return translate.call(loader, load)
      .then(function(source) {
        // detect & transpile ES6
        if (load.metadata.format == 'esm' || load.metadata.format == 'es6' || !load.metadata.format && source.match(esmRegEx)) {
          if (load.metadata.format == 'es6')
            warn.call(loader, 'Module ' + load.name + ' has metadata setting its format to "es6", which is deprecated.\nThis should be updated to "esm".');

          load.metadata.format = 'esm';

          if (loader.transpiler === false) {
            // we accept translation to esm for builds though to enable eg rollup optimizations
            if (loader.builder)
              return source;
            throw new TypeError('Unable to dynamically transpile ES module as SystemJS.transpiler set to false.');
          }

          // setting _loader.loadedTranspiler = false tells the next block to
          // do checks for setting transpiler metadata
          loader._loader.loadedTranspiler = loader._loader.loadedTranspiler || false;
          if (loader.pluginLoader)
            loader.pluginLoader._loader.loadedTranspiler = loader._loader.loadedTranspiler || false;

          // do transpilation
          return (loader._loader.transpilerPromise || (
            loader._loader.transpilerPromise = Promise.resolve(
              __global[loader.transpiler == 'typescript' ? 'ts' : loader.transpiler] || (loader.pluginLoader || loader)['import'](loader.transpiler)
          ))).then(function(transpiler) {
            loader._loader.loadedTranspilerRuntime = true;

            // translate hooks means this is a transpiler plugin instead of a raw implementation
            if (transpiler.translate) {
              // if transpiler is the same as the plugin loader, then don't run twice
              if (transpiler == load.metadata.loaderModule)
                return load.source;

              // convert the source map into an object for transpilation chaining
              if (typeof load.metadata.sourceMap == 'string')
                load.metadata.sourceMap = JSON.parse(load.metadata.sourceMap);

              return Promise.resolve(transpiler.translate.call(loader, load))
              .then(function(source) {
                // sanitize sourceMap if an object not a JSON string
                var sourceMap = load.metadata.sourceMap;
                if (sourceMap && typeof sourceMap == 'object') {
                  var originalName = load.name.split('!')[0];
                  
                  // force set the filename of the original file
                  sourceMap.file = originalName + '!transpiled';

                  // force set the sources list if only one source
                  if (!sourceMap.sources || sourceMap.sources.length <= 1)
                    sourceMap.sources = [originalName];
                }

                if (load.metadata.format == 'esm' && !loader.builder && detectRegisterFormat(source))
                  load.metadata.format = 'register';
                return source;
              });
            }

            // legacy builder support
            if (loader.builder)
              load.metadata.originalSource = load.source;
            
            // defined in es6-module-loader/src/transpile.js
            return transpile.call(loader, load)
            .then(function(source) {
              // clear sourceMap as transpiler embeds it
              load.metadata.sourceMap = undefined;
              return source;
            });            
          });
        }

        // skip transpiler and transpiler runtime loading when transpiler is disabled
        if (loader.transpiler === false)
          return source;

        // load the transpiler correctly
        if (loader._loader.loadedTranspiler === false && (loader.transpiler == 'traceur' || loader.transpiler == 'typescript' || loader.transpiler == 'babel')
            && load.name == loader.normalizeSync(loader.transpiler)) {

          // always load transpiler as a global
          if (source.length > 100 && !load.metadata.format) {
            load.metadata.format = 'global';

            if (loader.transpiler === 'traceur')
              load.metadata.exports = 'traceur';
            if (loader.transpiler === 'typescript')
              load.metadata.exports = 'ts';
          }

          loader._loader.loadedTranspiler = true;
        }

        // load the transpiler runtime correctly
        if (loader._loader.loadedTranspilerRuntime === false) {
          if (load.name == loader.normalizeSync('traceur-runtime')
              || load.name == loader.normalizeSync('babel/external-helpers*')) {
            if (source.length > 100)
              load.metadata.format = load.metadata.format || 'global';

            loader._loader.loadedTranspilerRuntime = true;
          }
        }

        // detect transpiler runtime usage to load runtimes
        if ((load.metadata.format == 'register' || load.metadata.bundle) && loader._loader.loadedTranspilerRuntime !== true) {
          if (!__global.$traceurRuntime && load.source.match(traceurRuntimeRegEx)) {
            loader._loader.loadedTranspilerRuntime = loader._loader.loadedTranspilerRuntime || false;
            return loader['import']('traceur-runtime').then(function() {
              return source;
            });
          }
          if (!__global.babelHelpers && load.source.match(babelHelpersRegEx)) {
            loader._loader.loadedTranspilerRuntime = loader._loader.loadedTranspilerRuntime || false;
            return loader['import']('babel/external-helpers').then(function() {
              return source;
            });
          }
        }

        return source;
      });
    };
  });

})();
/*
  SystemJS Global Format

  Supports
    metadata.deps
    metadata.globals
    metadata.exports

  Without metadata.exports, detects writes to the global object.
*/
var __globalName = typeof self != 'undefined' ? 'self' : 'global';

hook('fetch', function(fetch) {
  return function(load) {
    if (load.metadata.exports && !load.metadata.format)
      load.metadata.format = 'global';
    return fetch.call(this, load);
  };
});

// ideally we could support script loading for globals, but the issue with that is that
// we can't do it with AMD support side-by-side since AMD support means defining the
// global define, and global support means not definining it, yet we don't have any hook
// into the "pre-execution" phase of a script tag being loaded to handle both cases
hook('instantiate', function(instantiate) {
  return function(load) {
    var loader = this;

    if (!load.metadata.format)
      load.metadata.format = 'global';

    // global is a fallback module format
    if (load.metadata.format == 'global' && !load.metadata.registered) {

      var entry = createEntry();

      load.metadata.entry = entry;

      entry.deps = [];

      for (var g in load.metadata.globals) {
        var gl = load.metadata.globals[g];
        if (gl)
          entry.deps.push(gl);
      }

      entry.execute = function(require, exports, module) {

        var globals;
        if (load.metadata.globals) {
          globals = {};
          for (var g in load.metadata.globals)
            if (load.metadata.globals[g])
              globals[g] = require(load.metadata.globals[g]);
        }
        
        var exportName = load.metadata.exports;

        if (exportName)
          load.source += '\n' + __globalName + '["' + exportName + '"] = ' + exportName + ';';

        var retrieveGlobal = loader.get('@@global-helpers').prepareGlobal(module.id, exportName, globals);

        __exec.call(loader, load);

        return retrieveGlobal();
      }
    }
    return instantiate.call(this, load);
  };
});


function getGlobalValue(exports) {
  if (typeof exports == 'string')
    return readMemberExpression(exports, __global);

  if (!(exports instanceof Array))
    throw new Error('Global exports must be a string or array.');

  var globalValue = {};
  var first = true;
  for (var i = 0; i < exports.length; i++) {
    var val = readMemberExpression(exports[i], __global);
    if (first) {
      globalValue['default'] = val;
      first = false;
    }
    globalValue[exports[i].split('.').pop()] = val;
  }
  return globalValue;
}

hook('reduceRegister_', function(reduceRegister) {
  return function(load, register) {
    if (register || !load.metadata.exports)
      return reduceRegister.call(this, load, register);

    load.metadata.format = 'global';
    var entry = load.metadata.entry = createEntry();
    entry.deps = load.metadata.deps;
    var globalValue = getGlobalValue(load.metadata.exports);
    entry.execute = function() {
      return globalValue;
    };
  };
});

hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(loader);

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    // bare minimum ignores
    var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'frameElement', 'external', 
      'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB', 'mozInnerScreenY', 'mozInnerScreenX'];

    var globalSnapshot;

    function forEachGlobal(callback) {
      if (Object.keys)
        Object.keys(__global).forEach(callback);
      else
        for (var g in __global) {
          if (!hasOwnProperty.call(__global, g))
            continue;
          callback(g);
        }
    }

    function forEachGlobalValue(callback) {
      forEachGlobal(function(globalName) {
        if (indexOf.call(ignoredGlobalProps, globalName) != -1)
          return;
        try {
          var value = __global[globalName];
        }
        catch (e) {
          ignoredGlobalProps.push(globalName);
        }
        callback(globalName, value);
      });
    }

    loader.set('@@global-helpers', loader.newModule({
      prepareGlobal: function(moduleName, exports, globals) {
        // disable module detection
        var curDefine = __global.define;
        
        __global.define = undefined;

        // set globals
        var oldGlobals;
        if (globals) {
          oldGlobals = {};
          for (var g in globals) {
            oldGlobals[g] = __global[g];
            __global[g] = globals[g];
          }
        }

        // store a complete copy of the global object in order to detect changes
        if (!exports) {
          globalSnapshot = {};

          forEachGlobalValue(function(name, value) {
            globalSnapshot[name] = value;
          });
        }

        // return function to retrieve global
        return function() {
          var globalValue;

          if (exports) {
            globalValue = getGlobalValue(exports);
          }
          else {
            globalValue = {};
            var singleGlobal;
            var multipleExports;

            forEachGlobalValue(function(name, value) {
              if (globalSnapshot[name] === value)
                return;
              if (typeof value == 'undefined')
                return;
              globalValue[name] = value;

              if (typeof singleGlobal != 'undefined') {
                if (!multipleExports && singleGlobal !== value)
                  multipleExports = true;
              }
              else {
                singleGlobal = value;
              }
            });
            globalValue = multipleExports ? globalValue : singleGlobal;
          }

          // revert globals
          if (oldGlobals) {
            for (var g in oldGlobals)
              __global[g] = oldGlobals[g];
          }
          __global.define = curDefine;

          return globalValue;
        };
      }
    }));
  };
});
/*
  SystemJS CommonJS Format
*/
(function() {
  // CJS Module Format
  // require('...') || exports[''] = ... || exports.asd = ... || module.exports = ...
  var cjsExportsRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])(exports\s*(\[['"]|\.)|module(\.exports|\['exports'\]|\["exports"\])\s*(\[['"]|[=,\.]))/;
  // RegEx adjusted from https://github.com/jbrantly/yabble/blob/master/lib/yabble.js#L339
  var cjsRequireRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g;
  var commentRegEx = /(^|[^\\])(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;

  var stringRegEx = /("[^"\\\n\r]*(\\.[^"\\\n\r]*)*"|'[^'\\\n\r]*(\\.[^'\\\n\r]*)*')/g;

  // used to support leading #!/usr/bin/env in scripts as supported in Node
  var hashBangRegEx = /^\#\!.*/;

  function getCJSDeps(source) {
    cjsRequireRegEx.lastIndex = commentRegEx.lastIndex = stringRegEx.lastIndex = 0;

    var deps = [];

    var match;

    // track string and comment locations for unminified source    
    var stringLocations = [], commentLocations = [];

    function inLocation(locations, match) {
      for (var i = 0; i < locations.length; i++)
        if (locations[i][0] < match.index && locations[i][1] > match.index)
          return true;
      return false;
    }

    if (source.length / source.split('\n').length < 200) {
      while (match = stringRegEx.exec(source))
        stringLocations.push([match.index, match.index + match[0].length]);
      
      while (match = commentRegEx.exec(source)) {
        // only track comments not starting in strings
        if (!inLocation(stringLocations, match))
          commentLocations.push([match.index, match.index + match[0].length]);
      }
    }

    while (match = cjsRequireRegEx.exec(source)) {
      // ensure we're not within a string or comment location
      if (!inLocation(stringLocations, match) && !inLocation(commentLocations, match)) {
        var dep = match[1].substr(1, match[1].length - 2);
        // skip cases like require('" + file + "')
        if (dep.match(/"|'/))
          continue;
        // trailing slash requires are removed as they don't map mains in SystemJS
        if (dep[dep.length - 1] == '/')
          dep = dep.substr(0, dep.length - 1);
        deps.push(dep);
      }
    }

    return deps;
  }

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      if (!load.metadata.format) {
        cjsExportsRegEx.lastIndex = 0;
        cjsRequireRegEx.lastIndex = 0;
        if (cjsRequireRegEx.exec(load.source) || cjsExportsRegEx.exec(load.source))
          load.metadata.format = 'cjs';
      }

      if (load.metadata.format == 'cjs') {
        var metaDeps = load.metadata.deps;
        var deps = load.metadata.cjsRequireDetection === false ? [] : getCJSDeps(load.source);

        for (var g in load.metadata.globals)
          if (load.metadata.globals[g])
            deps.push(load.metadata.globals[g]);

        var entry = createEntry();

        load.metadata.entry = entry;

        entry.deps = deps;
        entry.executingRequire = true;
        entry.execute = function(_require, exports, module) {
          function require(name) {
            if (name[name.length - 1] == '/')
              name = name.substr(0, name.length - 1);
            return _require.apply(this, arguments);
          }
          require.resolve = function(name) {
            return loader.get('@@cjs-helpers').requireResolve(name, module.id);
          };

          // ensure meta deps execute first
          if (!load.metadata.cjsDeferDepsExecute)
            for (var i = 0; i < metaDeps.length; i++)
              require(metaDeps[i]);

          var pathVars = loader.get('@@cjs-helpers').getPathVars(module.id);
          var __cjsWrapper = {
            exports: exports,
            args: [require, exports, module, pathVars.filename, pathVars.dirname, __global, __global]
          };

          var cjsWrapper = "(function(require, exports, module, __filename, __dirname, global, GLOBAL";

          // add metadata.globals to the wrapper arguments
          if (load.metadata.globals)
            for (var g in load.metadata.globals) {
              __cjsWrapper.args.push(require(load.metadata.globals[g]));
              cjsWrapper += ", " + g;
            }

          // disable AMD detection
          var define = __global.define;
          __global.define = undefined;
          __global.__cjsWrapper = __cjsWrapper;

          load.source = cjsWrapper + ") {" + load.source.replace(hashBangRegEx, '') + "\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);";

          __exec.call(loader, load);

          __global.__cjsWrapper = undefined;
          __global.define = define;
        };
      }

      return instantiate.call(loader, load);
    };
  });
})();
hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(loader);

    if (typeof window != 'undefined' && typeof document != 'undefined' && window.location)
      var windowOrigin = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');

    function stripOrigin(path) {
      if (path.substr(0, 8) == 'file:///')
        return path.substr(7 + !!isWindows);
      
      if (windowOrigin && path.substr(0, windowOrigin.length) == windowOrigin)
        return path.substr(windowOrigin.length);

      return path;
    }

    loader.set('@@cjs-helpers', loader.newModule({
      requireResolve: function(request, parentId) {
        return stripOrigin(loader.normalizeSync(request, parentId));
      },
      getPathVars: function(moduleId) {
        // remove any plugin syntax
        var pluginIndex = moduleId.lastIndexOf('!');
        var filename;
        if (pluginIndex != -1)
          filename = moduleId.substr(0, pluginIndex);
        else
          filename = moduleId;

        var dirname = filename.split('/');
        dirname.pop();
        dirname = dirname.join('/');

        return {
          filename: stripOrigin(filename),
          dirname: stripOrigin(dirname)
        };
      }
    }))
  };
});/*
 * AMD Helper function module
 * Separated into its own file as this is the part needed for full AMD support in SFX builds
 * NB since implementations have now diverged this can be merged back with amd.js
 */

hook('fetch', function(fetch) {
  return function(load) {
    // script load implies define global leak
    if (load.metadata.scriptLoad && isBrowser)
      __global.define = this.amdDefine;
    return fetch.call(this, load);
  };
});
 
hookConstructor(function(constructor) {
  return function() {
    var loader = this;
    constructor.call(this);

    var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
    var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
    var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";
    var fnBracketRegEx = /\(([^\)]*)\)/;
    var wsRegEx = /^\s+|\s+$/g;
    
    var requireRegExs = {};

    function getCJSDeps(source, requireIndex) {

      // remove comments
      source = source.replace(commentRegEx, '');

      // determine the require alias
      var params = source.match(fnBracketRegEx);
      var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

      // find or generate the regex for this requireAlias
      var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

      requireRegEx.lastIndex = 0;

      var deps = [];

      var match;
      while (match = requireRegEx.exec(source))
        deps.push(match[2] || match[3]);

      return deps;
    }

    /*
      AMD-compatible require
      To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
    */
    function require(names, callback, errback, referer) {
      // in amd, first arg can be a config object... we just ignore
      if (typeof names == 'object' && !(names instanceof Array))
        return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

      // amd require
      if (typeof names == 'string' && typeof callback == 'function')
        names = [names];
      if (names instanceof Array) {
        var dynamicRequires = [];
        for (var i = 0; i < names.length; i++)
          dynamicRequires.push(loader['import'](names[i], referer));
        Promise.all(dynamicRequires).then(function(modules) {
          if (callback)
            callback.apply(null, modules);
        }, errback);
      }

      // commonjs require
      else if (typeof names == 'string') {
        var defaultJSExtension = loader.defaultJSExtensions && names.substr(names.length - 3, 3) != '.js';
        var normalized = loader.decanonicalize(names, referer);
        if (defaultJSExtension && normalized.substr(normalized.length - 3, 3) == '.js')
          normalized = normalized.substr(0, normalized.length - 3);
        var module = loader.get(normalized);
        if (!module)
          throw new Error('Module not already loaded loading "' + names + '" as ' + normalized + (referer ? ' from "' + referer + '".' : '.'));
        return module.__useDefault ? module['default'] : module;
      }

      else
        throw new TypeError('Invalid require');
    }

    function define(name, deps, factory) {
      if (typeof name != 'string') {
        factory = deps;
        deps = name;
        name = null;
      }
      if (!(deps instanceof Array)) {
        factory = deps;
        deps = ['require', 'exports', 'module'].splice(0, factory.length);
      }

      if (typeof factory != 'function')
        factory = (function(factory) {
          return function() { return factory; }
        })(factory);

      // in IE8, a trailing comma becomes a trailing undefined entry
      if (deps[deps.length - 1] === undefined)
        deps.pop();

      // remove system dependencies
      var requireIndex, exportsIndex, moduleIndex;
      
      if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
        
        deps.splice(requireIndex, 1);

        // only trace cjs requires for non-named
        // named defines assume the trace has already been done
        if (!name)
          deps = deps.concat(getCJSDeps(factory.toString(), requireIndex));
      }

      if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
        deps.splice(exportsIndex, 1);
      
      if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
        deps.splice(moduleIndex, 1);

      function execute(req, exports, module) {
        var depValues = [];
        for (var i = 0; i < deps.length; i++)
          depValues.push(req(deps[i]));

        module.uri = module.id;

        module.config = function() {};

        // add back in system dependencies
        if (moduleIndex != -1)
          depValues.splice(moduleIndex, 0, module);
        
        if (exportsIndex != -1)
          depValues.splice(exportsIndex, 0, exports);
        
        if (requireIndex != -1) {
          function contextualRequire(names, callback, errback) {
            if (typeof names == 'string' && typeof callback != 'function')
              return req(names);
            return require.call(loader, names, callback, errback, module.id);
          }
          contextualRequire.toUrl = function(name) {
            // normalize without defaultJSExtensions
            var defaultJSExtension = loader.defaultJSExtensions && name.substr(name.length - 3, 3) != '.js';
            var url = loader.decanonicalize(name, module.id);
            if (defaultJSExtension && url.substr(url.length - 3, 3) == '.js')
              url = url.substr(0, url.length - 3);
            return url;
          };
          depValues.splice(requireIndex, 0, contextualRequire);
        }

        // set global require to AMD require
        var curRequire = __global.require;
        __global.require = require;

        var output = factory.apply(exportsIndex == -1 ? __global : exports, depValues);

        __global.require = curRequire;

        if (typeof output == 'undefined' && module)
          output = module.exports;

        if (typeof output != 'undefined')
          return output;
      }

      var entry = createEntry();
      entry.name = name && (loader.decanonicalize || loader.normalize).call(loader, name);
      entry.deps = deps;
      entry.execute = execute;

      loader.pushRegister_({
        amd: true,
        entry: entry
      });
    }
    define.amd = {};

    // reduction function to attach defines to a load record
    hook('reduceRegister_', function(reduceRegister) {
      return function(load, register) {
        // only handle AMD registers here
        if (!register || !register.amd)
          return reduceRegister.call(this, load, register);

        var curMeta = load && load.metadata;
        var entry = register.entry;

        if (curMeta) {
          if (!curMeta.format || curMeta.format == 'detect')
            curMeta.format = 'amd';
          else if (!entry.name && curMeta.format != 'amd')
            throw new Error('AMD define called while executing ' + curMeta.format + ' module ' + load.name);
        }

        // anonymous define
        if (!entry.name) {
          if (!curMeta)
            throw new TypeError('Unexpected anonymous AMD define.');

          if (curMeta.entry && !curMeta.entry.name)
            throw new Error('Multiple anonymous defines in module ' + load.name);
          
          curMeta.entry = entry;
        }
        // named define
        else {
          // if we don't have any other defines, 
          // then let this be an anonymous define
          // this is just to support single modules of the form:
          // define('jquery')
          // still loading anonymously
          // because it is done widely enough to be useful
          // as soon as there is more than one define, this gets removed though
          if (curMeta) {
            if (!curMeta.entry && !curMeta.bundle)
              curMeta.entry = entry;
            else if (curMeta.entry && curMeta.entry.name)
              curMeta.entry = undefined;

            // note this is now a bundle
            curMeta.bundle = true;
          }

          // define the module through the register registry
          if (!(entry.name in this.defined))
            this.defined[entry.name] = entry;
        }
      };
    });

    loader.amdDefine = define;
    loader.amdRequire = require;
  };
});/*
  SystemJS AMD Format
*/
(function() {
  // AMD Module Format Detection RegEx
  // define([.., .., ..], ...)
  // define(varName); || define(function(require, exports) {}); || define({})
  var amdRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/;

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      
      if (load.metadata.format == 'amd' || !load.metadata.format && load.source.match(amdRegEx)) {
        load.metadata.format = 'amd';
        
        if (!loader.builder && loader.execute !== false) {
          var curDefine = __global.define;
          __global.define = this.amdDefine;

          try {
            __exec.call(loader, load);
          }
          finally {
            __global.define = curDefine;
          }

          if (!load.metadata.entry && !load.metadata.bundle)
            throw new TypeError('AMD module ' + load.name + ' did not define');
        }
        else {
          load.metadata.execute = function() {
            return load.metadata.builderExecute.apply(this, arguments);
          };
        }
      }

      return instantiate.call(loader, load);
    };
  });

})();
/*
  SystemJS Loader Plugin Support

  Supports plugin loader syntax with "!", or via metadata.loader

  The plugin name is loaded as a module itself, and can override standard loader hooks
  for the plugin resource. See the plugin section of the systemjs readme.
*/

(function() {
  function getParentName(loader, parentName) {
    // if parent is a plugin, normalize against the parent plugin argument only
    if (parentName) {
      var parentPluginIndex;
      if (loader.pluginFirst) {
        if ((parentPluginIndex = parentName.lastIndexOf('!')) != -1)
          return parentName.substr(parentPluginIndex + 1);
      }
      else {
        if ((parentPluginIndex = parentName.indexOf('!')) != -1)
          return parentName.substr(0, parentPluginIndex);
      }

      return parentName;
    }
  }

  function parsePlugin(loader, name) {
    var argumentName;
    var pluginName;

    var pluginIndex = name.lastIndexOf('!');

    if (pluginIndex == -1)
      return;

    if (loader.pluginFirst) {
      argumentName = name.substr(pluginIndex + 1);
      pluginName = name.substr(0, pluginIndex);
    }
    else {
      argumentName = name.substr(0, pluginIndex);
      pluginName = name.substr(pluginIndex + 1) || argumentName.substr(argumentName.lastIndexOf('.') + 1);
    }

    return {
      argument: argumentName,
      plugin: pluginName
    };
  }

  // put name back together after parts have been normalized
  function combinePluginParts(loader, argumentName, pluginName, defaultExtension) {
    if (defaultExtension && argumentName.substr(argumentName.length - 3, 3) == '.js')
      argumentName = argumentName.substr(0, argumentName.length - 3);

    if (loader.pluginFirst) {
      return pluginName + '!' + argumentName;
    }
    else {
      return argumentName + '!' + pluginName;
    }
  }

  // note if normalize will add a default js extension
  // if so, remove for backwards compat
  // this is strange and sucks, but will be deprecated
  function checkDefaultExtension(loader, arg) {
    return loader.defaultJSExtensions && arg.substr(arg.length - 3, 3) != '.js'; 
  }

  function createNormalizeSync(normalizeSync) {
    return function(name, parentName, isPlugin) {
      var loader = this;
      
      parentName = getParentName(this, parentName);
      var parsed = parsePlugin(loader, name);

      if (!parsed)
        return normalizeSync.call(this, name, parentName, isPlugin);

      // if this is a plugin, normalize the plugin name and the argument
      var argumentName = loader.normalizeSync(parsed.argument, parentName, true);
      var pluginName = loader.normalizeSync(parsed.plugin, parentName, true);
      return combinePluginParts(loader, argumentName, pluginName, checkDefaultExtension(loader, parsed.argument));
    };
  }
  
  hook('decanonicalize', createNormalizeSync);
  hook('normalizeSync', createNormalizeSync);

  hook('normalize', function(normalize) {
    return function(name, parentName, isPlugin) {
      var loader = this;

      parentName = getParentName(this, parentName);

      var parsed = parsePlugin(loader, name);

      if (!parsed)
        return normalize.call(loader, name, parentName, isPlugin);

      return Promise.all([
        loader.normalize(parsed.argument, parentName, true),
        loader.normalize(parsed.plugin, parentName)
      ])
      .then(function(normalized) {
        return combinePluginParts(loader, normalized[0], normalized[1], checkDefaultExtension(loader, parsed.argument));
      });
    }
  });

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;

      var name = load.name;

      // plugin syntax
      var pluginSyntaxIndex;
      if (loader.pluginFirst) {
        if ((pluginSyntaxIndex = name.indexOf('!')) != -1) {
          load.metadata.loader = name.substr(0, pluginSyntaxIndex);
          load.name = name.substr(pluginSyntaxIndex + 1);
        }
      }
      else {
        if ((pluginSyntaxIndex = name.lastIndexOf('!')) != -1) {
          load.metadata.loader = name.substr(pluginSyntaxIndex + 1);
          load.name = name.substr(0, pluginSyntaxIndex);
        }
      }

      return locate.call(loader, load)
      .then(function(address) {
        if (pluginSyntaxIndex != -1 || !load.metadata.loader)
          return address;

        // normalize plugin relative to parent in locate here when
        // using plugin via loader metadata
        return loader.normalize(load.metadata.loader, load.name)
        .then(function(loaderNormalized) {
          load.metadata.loader = loaderNormalized;
          return address;
        });
      })
      .then(function(address) {
        var plugin = load.metadata.loader;

        if (!plugin)
          return address;

        // don't allow a plugin to load itself
        if (load.name == plugin)
          throw new Error('Plugin ' + plugin + ' cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.');

        // only fetch the plugin itself if this name isn't defined
        if (loader.defined && loader.defined[name])
          return address;

        var pluginLoader = loader.pluginLoader || loader;

        // load the plugin module and run standard locate
        return pluginLoader['import'](plugin)
        .then(function(loaderModule) {
          // store the plugin module itself on the metadata
          load.metadata.loaderModule = loaderModule;

          load.address = address;
          if (loaderModule.locate)
            return loaderModule.locate.call(loader, load);

          return address;
        });
      });
    };
  });

  hook('fetch', function(fetch) {
    return function(load) {
      var loader = this;
      if (load.metadata.loaderModule && load.metadata.loaderModule.fetch && load.metadata.format != 'defined') {
        load.metadata.scriptLoad = false;
        return load.metadata.loaderModule.fetch.call(loader, load, function(load) {
          return fetch.call(loader, load);
        });
      }
      else {
        return fetch.call(loader, load);
      }
    };
  });

  hook('translate', function(translate) {
    return function(load) {
      var loader = this;
      if (load.metadata.loaderModule && load.metadata.loaderModule.translate && load.metadata.format != 'defined') {
        return Promise.resolve(load.metadata.loaderModule.translate.call(loader, load)).then(function(result) {
          var sourceMap = load.metadata.sourceMap;

          // sanitize sourceMap if an object not a JSON string
          if (sourceMap) {
            if (typeof sourceMap != 'object')
              throw new Error('load.metadata.sourceMap must be set to an object.');

            var originalName = load.name.split('!')[0];
            
            // force set the filename of the original file
            sourceMap.file = originalName + '!transpiled';

            // force set the sources list if only one source
            if (!sourceMap.sources || sourceMap.sources.length <= 1)
              sourceMap.sources = [originalName];
          }

          // if running on file:/// URLs, sourcesContent is necessary
          // load.metadata.sourceMap.sourcesContent = [load.source];

          if (typeof result == 'string')
            load.source = result;
          else
            warn.call(this, 'Plugin ' + load.metadata.loader + ' should return the source in translate, instead of setting load.source directly. This support will be deprecated.');

          return translate.call(loader, load);
        });
      }
      else {
        return translate.call(loader, load);
      }
    };
  });

  hook('instantiate', function(instantiate) {
    return function(load) {
      var loader = this;
      var calledInstantiate = false;

      if (load.metadata.loaderModule && load.metadata.loaderModule.instantiate && !loader.builder && load.metadata.format != 'defined')
        return Promise.resolve(load.metadata.loaderModule.instantiate.call(loader, load, function(load) {
          if (calledInstantiate)
            throw new Error('Instantiate must only be called once.');
          calledInstantiate = true;
          return instantiate.call(loader, load);
        })).then(function(result) {
          if (calledInstantiate)
            return result;

          load.metadata.entry = createEntry();
          load.metadata.entry.execute = function() {
            return result;
          }
          load.metadata.entry.deps = load.metadata.deps;
          load.metadata.format = 'defined';
          return instantiate.call(loader, load);
        });
      else
        return instantiate.call(loader, load);
    };
  });

})();/*
 * Conditions Extension
 *
 *   Allows a condition module to alter the resolution of an import via syntax:
 *
 *     import $ from 'jquery/#{browser}';
 *
 *   Will first load the module 'browser' via `SystemJS.import('browser')` and 
 *   take the default export of that module.
 *   If the default export is not a string, an error is thrown.
 * 
 *   We then substitute the string into the require to get the conditional resolution
 *   enabling environment-specific variations like:
 * 
 *     import $ from 'jquery/ie'
 *     import $ from 'jquery/firefox'
 *     import $ from 'jquery/chrome'
 *     import $ from 'jquery/safari'
 *
 *   It can be useful for a condition module to define multiple conditions.
 *   This can be done via the `|` modifier to specify an export member expression:
 *
 *     import 'jquery/#{./browser.js|grade.version}'
 *
 *   Where the `grade` export `version` member in the `browser.js` module  is substituted.
 *
 *
 * Boolean Conditionals
 *
 *   For polyfill modules, that are used as imports but have no module value,
 *   a binary conditional allows a module not to be loaded at all if not needed:
 *
 *     import 'es5-shim#?./conditions.js|needs-es5shim'
 *
 *   These conditions can also be negated via:
 *     
 *     import 'es5-shim#?~./conditions.js|es6'
 *
 */

  function parseCondition(condition) {
    var conditionExport, conditionModule, negation;

    var negation = condition[0] == '~';
    var conditionExportIndex = condition.lastIndexOf('|');
    if (conditionExportIndex != -1) {
      conditionExport = condition.substr(conditionExportIndex + 1);
      conditionModule = condition.substr(negation, conditionExportIndex - negation) || '@system-env';
    }
    else {
      conditionExport = null;
      conditionModule = condition.substr(negation);
    }

    return {
      module: conditionModule,
      prop: conditionExport,
      negate: negation
    };
  }

  function serializeCondition(conditionObj) {
    return (conditionObj.negate ? '~' : '') + conditionObj.module + (conditionObj.prop ? '|' + conditionObj.prop : '');
  }

  function resolveCondition(conditionObj, parentName, bool) {
    return this['import'](conditionObj.module, parentName)
    .then(function(m) {
      if (conditionObj.prop)
        m = readMemberExpression(conditionObj.prop, m);
      else if (typeof m == 'object' && m + '' == 'Module')
        m = m['default'];

      if (bool && typeof m != 'boolean')
        throw new TypeError('Condition ' + serializeCondition(conditionObj) + ' did not resolve to a boolean.');

      return conditionObj.negate ? !m : m;
    });
  }

  var interpolationRegEx = /#\{[^\}]+\}/;
  function interpolateConditional(name, parentName) {
    // first we normalize the conditional
    var conditionalMatch = name.match(interpolationRegEx);

    if (!conditionalMatch)
      return Promise.resolve(name);

    var conditionObj = parseCondition(conditionalMatch[0].substr(2, conditionalMatch[0].length - 3));

    // in builds, return normalized conditional
    if (this.builder)
      return this['normalize'](conditionObj.module, parentName)
      .then(function(conditionModule) {
        conditionObj.module = conditionModule;
        return name.replace(interpolationRegEx, '#{' + serializeCondition(conditionObj) + '}');
      });

    return resolveCondition.call(this, conditionObj, parentName, false)
    .then(function(conditionValue) {
      if (typeof conditionValue !== 'string')
        throw new TypeError('The condition value for ' + name + ' doesn\'t resolve to a string.');

      if (conditionValue.indexOf('/') != -1)
        throw new TypeError('Unabled to interpolate conditional ' + name + (parentName ? ' in ' + parentName : '') + '\n\tThe condition value ' + conditionValue + ' cannot contain a "/" separator.');

      return name.replace(interpolationRegEx, conditionValue);
    });
  }

  function booleanConditional(name, parentName) {
    // first we normalize the conditional
    var booleanIndex = name.lastIndexOf('#?');

    if (booleanIndex == -1)
      return Promise.resolve(name);

    var conditionObj = parseCondition(name.substr(booleanIndex + 2));

    // in builds, return normalized conditional
    if (this.builder)
      return this['normalize'](conditionObj.module, parentName)
      .then(function(conditionModule) {
        conditionObj.module = conditionModule;
        return name.substr(0, booleanIndex) + '#?' + serializeCondition(conditionObj);
      });

    return resolveCondition.call(this, conditionObj, parentName, true)
    .then(function(conditionValue) {
      return conditionValue ? name.substr(0, booleanIndex) : '@empty';
    });
  }

  // normalizeSync does not parse conditionals at all although it could
  hook('normalize', function(normalize) {
    return function(name, parentName, parentAddress) {
      var loader = this;
      return booleanConditional.call(loader, name, parentName)
      .then(function(name) {
        return normalize.call(loader, name, parentName, parentAddress);
      })
      .then(function(normalized) {
        return interpolateConditional.call(loader, normalized, parentName);
      });
    };
  });
/*
 * Alias Extension
 *
 * Allows a module to be a plain copy of another module by module name
 *
 * SystemJS.meta['mybootstrapalias'] = { alias: 'bootstrap' };
 *
 */
(function() {
  // aliases
  hook('fetch', function(fetch) {
    return function(load) {
      var alias = load.metadata.alias;
      var aliasDeps = load.metadata.deps || [];
      if (alias) {
        load.metadata.format = 'defined';
        var entry = createEntry();
        this.defined[load.name] = entry;
        entry.declarative = true;
        entry.deps = aliasDeps.concat([alias]);
        entry.declare = function(_export) {
          return {
            setters: [function(module) {
              for (var p in module)
                _export(p, module[p]);
              if (module.__useDefault)
                entry.module.exports.__useDefault = true;
            }],
            execute: function() {}
          };
        };
        return '';
      }

      return fetch.call(this, load);
    };
  });
})();/*
 * Meta Extension
 *
 * Sets default metadata on a load record (load.metadata) from
 * loader.metadata via SystemJS.meta function.
 *
 *
 * Also provides an inline meta syntax for module meta in source.
 *
 * Eg:
 *
 * loader.meta({
 *   'my/module': { deps: ['jquery'] }
 *   'my/*': { format: 'amd' }
 * });
 *
 * Which in turn populates loader.metadata.
 *
 * load.metadata.deps and load.metadata.format will then be set
 * for 'my/module'
 *
 * The same meta could be set with a my/module.js file containing:
 *
 * my/module.js
 *   "format amd";
 *   "deps[] jquery";
 *   "globals.some value"
 *   console.log('this is my/module');
 *
 * Configuration meta always takes preference to inline meta.
 *
 * Multiple matches in wildcards are supported and ammend the meta.
 *
 *
 * The benefits of the function form is that paths are URL-normalized
 * supporting say
 *
 * loader.meta({ './app': { format: 'cjs' } });
 *
 * Instead of needing to set against the absolute URL (https://site.com/app.js)
 *
 */

(function() {

  hookConstructor(function(constructor) {
    return function() {
      this.meta = {};
      constructor.call(this);
    };
  });

  hook('locate', function(locate) {
    return function(load) {
      var meta = this.meta;
      var name = load.name;

      // NB for perf, maybe introduce a fast-path wildcard lookup cache here
      // which is checked first

      // apply wildcard metas
      var bestDepth = 0;
      var wildcardIndex;
      for (var module in meta) {
        wildcardIndex = module.indexOf('*');
        if (wildcardIndex === -1)
          continue;
        if (module.substr(0, wildcardIndex) === name.substr(0, wildcardIndex)
            && module.substr(wildcardIndex + 1) === name.substr(name.length - module.length + wildcardIndex + 1)) {
          var depth = module.split('/').length;
          if (depth > bestDepth)
            bestDepth = depth;
          extendMeta(load.metadata, meta[module], bestDepth != depth);
        }
      }

      // apply exact meta
      if (meta[name])
        extendMeta(load.metadata, meta[name]);

      return locate.call(this, load);
    };
  });

  // detect any meta header syntax
  // only set if not already set
  var metaRegEx = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/;
  var metaPartRegEx = /\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;

  function setMetaProperty(target, p, value) {
    var pParts = p.split('.');
    var curPart;
    while (pParts.length > 1) {
      curPart = pParts.shift();
      target = target[curPart] = target[curPart] || {};
    }
    curPart = pParts.shift();
    if (!(curPart in target))
      target[curPart] = value;
  }

  hook('translate', function(translate) {
    return function(load) {
      // NB meta will be post-translate pending transpiler conversion to plugins
      var meta = load.source.match(metaRegEx);
      if (meta) {
        var metaParts = meta[0].match(metaPartRegEx);

        for (var i = 0; i < metaParts.length; i++) {
          var curPart = metaParts[i];
          var len = curPart.length;

          var firstChar = curPart.substr(0, 1);
          if (curPart.substr(len - 1, 1) == ';')
            len--;

          if (firstChar != '"' && firstChar != "'")
            continue;

          var metaString = curPart.substr(1, curPart.length - 3);
          var metaName = metaString.substr(0, metaString.indexOf(' '));

          if (metaName) {
            var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);

            if (metaName.substr(metaName.length - 2, 2) == '[]') {
              metaName = metaName.substr(0, metaName.length - 2);
              load.metadata[metaName] = load.metadata[metaName] || [];
              load.metadata[metaName].push(metaValue);
            }
            else if (load.metadata[metaName] instanceof Array) {
              // temporary backwards compat for previous "deps" syntax
              warn.call(this, 'Module ' + load.name + ' contains deprecated "deps ' + metaValue + '" meta syntax.\nThis should be updated to "deps[] ' + metaValue + '" for pushing to array meta.');
              load.metadata[metaName].push(metaValue);
            }
            else {
              setMetaProperty(load.metadata, metaName, metaValue);
            }
          }
          else {
            load.metadata[metaString] = true;
          }
        }
      }

      return translate.call(this, load);
    };
  });
})();
/*
  System bundles

  Allows a bundle module to be specified which will be dynamically 
  loaded before trying to load a given module.

  For example:
  SystemJS.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']

  Will result in a load to "mybundle" whenever a load to "jquery"
  or "bootstrap/js/bootstrap" is made.

  In this way, the bundle becomes the request that provides the module
*/

(function() {
  // bundles support (just like RequireJS)
  // bundle name is module name of bundle itself
  // bundle is array of modules defined by the bundle
  // when a module in the bundle is requested, the bundle is loaded instead
  // of the form SystemJS.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']
  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.bundles = {};
      this._loader.loadedBundles = {};
    };
  });

  // assign bundle metadata for bundle loads
  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      var matched = false;

      if (!(load.name in loader.defined))
        for (var b in loader.bundles) {
          for (var i = 0; i < loader.bundles[b].length; i++) {
            var curModule = loader.bundles[b][i];

            if (curModule == load.name) {
              matched = true;
              break;
            }

            // wildcard in bundles does not include / boundaries
            if (curModule.indexOf('*') != -1) {
              var parts = curModule.split('*');
              if (parts.length != 2) {
                loader.bundles[b].splice(i--, 1);
                continue;
              }
              
              if (load.name.substring(0, parts[0].length) == parts[0] &&
                  load.name.substr(load.name.length - parts[1].length, parts[1].length) == parts[1] &&
                  load.name.substr(parts[0].length, load.name.length - parts[1].length - parts[0].length).indexOf('/') == -1) {
                matched = true;
                break;
              }
            }
          }

          if (matched)
            return loader['import'](b)
            .then(function() {
              return locate.call(loader, load);
            });
        }

      return locate.call(loader, load);
    };
  });
})();
/*
 * Dependency Tree Cache
 * 
 * Allows a build to pre-populate a dependency trace tree on the loader of 
 * the expected dependency tree, to be loaded upfront when requesting the
 * module, avoinding the n round trips latency of module loading, where 
 * n is the dependency tree depth.
 *
 * eg:
 * SystemJS.depCache = {
 *  'app': ['normalized', 'deps'],
 *  'normalized': ['another'],
 *  'deps': ['tree']
 * };
 * 
 * SystemJS.import('app') 
 * // simultaneously starts loading all of:
 * // 'normalized', 'deps', 'another', 'tree'
 * // before "app" source is even loaded
 *
 */

(function() {
  hookConstructor(function(constructor) {
    return function() {
      constructor.call(this);
      this.depCache = {};
    }
  });

  hook('locate', function(locate) {
    return function(load) {
      var loader = this;
      // load direct deps, in turn will pick up their trace trees
      var deps = loader.depCache[load.name];
      if (deps)
        for (var i = 0; i < deps.length; i++)
          loader['import'](deps[i], load.name);

      return locate.call(loader, load);
    };
  });
})();
  
System = new SystemJSLoader();

__global.SystemJS = System;
System.version = '0.19.27 Standard';
  // -- exporting --

  if (typeof exports === 'object')
    module.exports = Loader;

  __global.Reflect = __global.Reflect || {};
  __global.Reflect.Loader = __global.Reflect.Loader || Loader;
  __global.Reflect.global = __global.Reflect.global || __global;
  __global.LoaderPolyfill = Loader;

  if (!System) {
    System = new SystemLoader();
    System.constructor = SystemLoader;
  }

  if (typeof exports === 'object')
    module.exports = System;

  __global.System = System;

})(typeof self != 'undefined' ? self : global);}

// auto-load Promise polyfill if needed in the browser
var doPolyfill = typeof Promise === 'undefined';

// document.write
if (typeof document !== 'undefined') {
  var scripts = document.getElementsByTagName('script');
  $__curScript = scripts[scripts.length - 1];
  if (doPolyfill) {
    var curPath = $__curScript.src;
    var basePath = curPath.substr(0, curPath.lastIndexOf('/') + 1);
    window.systemJSBootstrap = bootstrap;
    document.write(
      '<' + 'script type="text/javascript" src="' + basePath + 'system-polyfills.js">' + '<' + '/script>'
    );
  }
  else {
    bootstrap();
  }
}
// importScripts
else if (typeof importScripts !== 'undefined') {
  var basePath = '';
  try {
    throw new Error('_');
  } catch (e) {
    e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/, function(m, url) {
      $__curScript = { src: url };
      basePath = url.replace(/\/[^\/]*$/, '/');
    });
  }
  if (doPolyfill)
    importScripts(basePath + 'system-polyfills.js');
  bootstrap();
}
else {
  $__curScript = typeof __filename != 'undefined' ? { src: __filename } : null;
  bootstrap();
}


})();
System.registerDynamic("node_modules/@angular/platform-browser-dynamic/core_private.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;
  exports.reflector = core_1.__core_private__.reflector;
  exports.Console = core_1.__core_private__.Console;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/title.js", ["../dom/dom_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var Title = (function() {
    function Title() {}
    Title.prototype.getTitle = function() {
      return dom_adapter_1.getDOM().getTitle();
    };
    Title.prototype.setTitle = function(newTitle) {
      dom_adapter_1.getDOM().setTitle(newTitle);
    };
    return Title;
  }());
  exports.Title = Title;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/browser.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var win = typeof window !== 'undefined' && window || {};
  exports.window = win;
  exports.document = win.document;
  exports.location = win.location;
  exports.gc = win['gc'] ? function() {
    return win['gc']();
  } : function() {
    return null;
  };
  exports.performance = win['performance'] ? win['performance'] : null;
  exports.Event = win['Event'];
  exports.MouseEvent = win['MouseEvent'];
  exports.KeyboardEvent = win['KeyboardEvent'];
  exports.EventTarget = win['EventTarget'];
  exports.History = win['History'];
  exports.Location = win['Location'];
  exports.EventListener = win['EventListener'];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/tools/common_tools.js", ["@angular/core", "../../dom/dom_adapter", "../../facade/browser", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../../dom/dom_adapter');
  var browser_1 = $__require('../../facade/browser');
  var lang_1 = $__require('../../facade/lang');
  var ChangeDetectionPerfRecord = (function() {
    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
      this.msPerTick = msPerTick;
      this.numTicks = numTicks;
    }
    return ChangeDetectionPerfRecord;
  }());
  exports.ChangeDetectionPerfRecord = ChangeDetectionPerfRecord;
  var AngularTools = (function() {
    function AngularTools(ref) {
      this.profiler = new AngularProfiler(ref);
    }
    return AngularTools;
  }());
  exports.AngularTools = AngularTools;
  var AngularProfiler = (function() {
    function AngularProfiler(ref) {
      this.appRef = ref.injector.get(core_1.ApplicationRef);
    }
    AngularProfiler.prototype.timeChangeDetection = function(config) {
      var record = lang_1.isPresent(config) && config['record'];
      var profileName = 'Change Detection';
      var isProfilerAvailable = lang_1.isPresent(browser_1.window.console.profile);
      if (record && isProfilerAvailable) {
        browser_1.window.console.profile(profileName);
      }
      var start = dom_adapter_1.getDOM().performanceNow();
      var numTicks = 0;
      while (numTicks < 5 || (dom_adapter_1.getDOM().performanceNow() - start) < 500) {
        this.appRef.tick();
        numTicks++;
      }
      var end = dom_adapter_1.getDOM().performanceNow();
      if (record && isProfilerAvailable) {
        browser_1.window.console.profileEnd(profileName);
      }
      var msPerTick = (end - start) / numTicks;
      browser_1.window.console.log("ran " + numTicks + " change detection cycles");
      browser_1.window.console.log(lang_1.NumberWrapper.toFixed(msPerTick, 2) + " ms per check");
      return new ChangeDetectionPerfRecord(msPerTick, numTicks);
    };
    return AngularProfiler;
  }());
  exports.AngularProfiler = AngularProfiler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/tools/tools.js", ["../../facade/lang", "./common_tools"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../../facade/lang');
  var common_tools_1 = $__require('./common_tools');
  var context = lang_1.global;
  function enableDebugTools(ref) {
    context.ng = new common_tools_1.AngularTools(ref);
    return ref;
  }
  exports.enableDebugTools = enableDebugTools;
  function disableDebugTools() {
    delete context.ng;
  }
  exports.disableDebugTools = disableDebugTools;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/debug/by.js", ["../../dom/dom_adapter", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var dom_adapter_1 = $__require('../../dom/dom_adapter');
  var lang_1 = $__require('../../facade/lang');
  var By = (function() {
    function By() {}
    By.all = function() {
      return function(debugElement) {
        return true;
      };
    };
    By.css = function(selector) {
      return function(debugElement) {
        return lang_1.isPresent(debugElement.nativeElement) ? dom_adapter_1.getDOM().elementMatches(debugElement.nativeElement, selector) : false;
      };
    };
    By.directive = function(type) {
      return function(debugElement) {
        return debugElement.providerTokens.indexOf(type) !== -1;
      };
    };
    return By;
  }());
  exports.By = By;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/worker/platform_location.js", ["@angular/common", "@angular/core", "../../facade/collection", "../../facade/exceptions", "../../facade/lang", "../shared/client_message_broker", "../shared/message_bus", "../shared/messaging_api", "../shared/serialized_types", "../shared/serializer", "./event_deserializer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var common_1 = $__require('@angular/common');
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var client_message_broker_1 = $__require('../shared/client_message_broker');
  var message_bus_1 = $__require('../shared/message_bus');
  var messaging_api_1 = $__require('../shared/messaging_api');
  var serialized_types_1 = $__require('../shared/serialized_types');
  var serializer_1 = $__require('../shared/serializer');
  var event_deserializer_1 = $__require('./event_deserializer');
  var WebWorkerPlatformLocation = (function(_super) {
    __extends(WebWorkerPlatformLocation, _super);
    function WebWorkerPlatformLocation(brokerFactory, bus, _serializer) {
      var _this = this;
      _super.call(this);
      this._serializer = _serializer;
      this._popStateListeners = [];
      this._hashChangeListeners = [];
      this._location = null;
      this._broker = brokerFactory.createMessageBroker(messaging_api_1.ROUTER_CHANNEL);
      this._channelSource = bus.from(messaging_api_1.ROUTER_CHANNEL);
      this._channelSource.subscribe({next: function(msg) {
          var listeners = null;
          if (collection_1.StringMapWrapper.contains(msg, 'event')) {
            var type = msg['event']['type'];
            if (lang_1.StringWrapper.equals(type, 'popstate')) {
              listeners = _this._popStateListeners;
            } else if (lang_1.StringWrapper.equals(type, 'hashchange')) {
              listeners = _this._hashChangeListeners;
            }
            if (listeners !== null) {
              var e_1 = event_deserializer_1.deserializeGenericEvent(msg['event']);
              _this._location = _this._serializer.deserialize(msg['location'], serialized_types_1.LocationType);
              listeners.forEach(function(fn) {
                return fn(e_1);
              });
            }
          }
        }});
    }
    WebWorkerPlatformLocation.prototype.init = function() {
      var _this = this;
      var args = new client_message_broker_1.UiArguments('getLocation');
      var locationPromise = this._broker.runOnService(args, serialized_types_1.LocationType);
      return locationPromise.then(function(val) {
        _this._location = val;
        return true;
      }, function(err) {
        throw new exceptions_1.BaseException(err);
      });
    };
    WebWorkerPlatformLocation.prototype.getBaseHrefFromDOM = function() {
      throw new exceptions_1.BaseException('Attempt to get base href from DOM from WebWorker. You must either provide a value for the APP_BASE_HREF token through DI or use the hash location strategy.');
    };
    WebWorkerPlatformLocation.prototype.onPopState = function(fn) {
      this._popStateListeners.push(fn);
    };
    WebWorkerPlatformLocation.prototype.onHashChange = function(fn) {
      this._hashChangeListeners.push(fn);
    };
    Object.defineProperty(WebWorkerPlatformLocation.prototype, "pathname", {
      get: function() {
        if (this._location === null) {
          return null;
        }
        return this._location.pathname;
      },
      set: function(newPath) {
        if (this._location === null) {
          throw new exceptions_1.BaseException('Attempt to set pathname before value is obtained from UI');
        }
        this._location.pathname = newPath;
        var fnArgs = [new client_message_broker_1.FnArg(newPath, serializer_1.PRIMITIVE)];
        var args = new client_message_broker_1.UiArguments('setPathname', fnArgs);
        this._broker.runOnService(args, null);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WebWorkerPlatformLocation.prototype, "search", {
      get: function() {
        if (this._location === null) {
          return null;
        }
        return this._location.search;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WebWorkerPlatformLocation.prototype, "hash", {
      get: function() {
        if (this._location === null) {
          return null;
        }
        return this._location.hash;
      },
      enumerable: true,
      configurable: true
    });
    WebWorkerPlatformLocation.prototype.pushState = function(state, title, url) {
      var fnArgs = [new client_message_broker_1.FnArg(state, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(title, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(url, serializer_1.PRIMITIVE)];
      var args = new client_message_broker_1.UiArguments('pushState', fnArgs);
      this._broker.runOnService(args, null);
    };
    WebWorkerPlatformLocation.prototype.replaceState = function(state, title, url) {
      var fnArgs = [new client_message_broker_1.FnArg(state, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(title, serializer_1.PRIMITIVE), new client_message_broker_1.FnArg(url, serializer_1.PRIMITIVE)];
      var args = new client_message_broker_1.UiArguments('replaceState', fnArgs);
      this._broker.runOnService(args, null);
    };
    WebWorkerPlatformLocation.prototype.forward = function() {
      var args = new client_message_broker_1.UiArguments('forward');
      this._broker.runOnService(args, null);
    };
    WebWorkerPlatformLocation.prototype.back = function() {
      var args = new client_message_broker_1.UiArguments('back');
      this._broker.runOnService(args, null);
    };
    WebWorkerPlatformLocation.decorators = [{type: core_1.Injectable}];
    WebWorkerPlatformLocation.ctorParameters = [{type: client_message_broker_1.ClientMessageBrokerFactory}, {type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}];
    return WebWorkerPlatformLocation;
  }(common_1.PlatformLocation));
  exports.WebWorkerPlatformLocation = WebWorkerPlatformLocation;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/worker/location_providers.js", ["@angular/common", "@angular/core", "./platform_location"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var common_1 = $__require('@angular/common');
  var core_1 = $__require('@angular/core');
  var platform_location_1 = $__require('./platform_location');
  exports.WORKER_APP_LOCATION_PROVIDERS = [{
    provide: common_1.PlatformLocation,
    useClass: platform_location_1.WebWorkerPlatformLocation
  }, {
    provide: core_1.APP_INITIALIZER,
    useFactory: appInitFnFactory,
    multi: true,
    deps: [common_1.PlatformLocation, core_1.NgZone]
  }];
  function appInitFnFactory(platformLocation, zone) {
    return function() {
      return zone.runGuarded(function() {
        return platformLocation.init();
      });
    };
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/ui/platform_location.js", ["@angular/core", "../../browser/location/browser_platform_location", "../../facade/lang", "../shared/message_bus", "../shared/messaging_api", "../shared/serialized_types", "../shared/serializer", "../shared/service_message_broker"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var browser_platform_location_1 = $__require('../../browser/location/browser_platform_location');
  var lang_1 = $__require('../../facade/lang');
  var message_bus_1 = $__require('../shared/message_bus');
  var messaging_api_1 = $__require('../shared/messaging_api');
  var serialized_types_1 = $__require('../shared/serialized_types');
  var serializer_1 = $__require('../shared/serializer');
  var service_message_broker_1 = $__require('../shared/service_message_broker');
  var MessageBasedPlatformLocation = (function() {
    function MessageBasedPlatformLocation(_brokerFactory, _platformLocation, bus, _serializer) {
      this._brokerFactory = _brokerFactory;
      this._platformLocation = _platformLocation;
      this._serializer = _serializer;
      this._platformLocation.onPopState(lang_1.FunctionWrapper.bind(this._sendUrlChangeEvent, this));
      this._platformLocation.onHashChange(lang_1.FunctionWrapper.bind(this._sendUrlChangeEvent, this));
      this._broker = this._brokerFactory.createMessageBroker(messaging_api_1.ROUTER_CHANNEL);
      this._channelSink = bus.to(messaging_api_1.ROUTER_CHANNEL);
    }
    MessageBasedPlatformLocation.prototype.start = function() {
      this._broker.registerMethod('getLocation', null, lang_1.FunctionWrapper.bind(this._getLocation, this), serialized_types_1.LocationType);
      this._broker.registerMethod('setPathname', [serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setPathname, this));
      this._broker.registerMethod('pushState', [serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._platformLocation.pushState, this._platformLocation));
      this._broker.registerMethod('replaceState', [serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._platformLocation.replaceState, this._platformLocation));
      this._broker.registerMethod('forward', null, lang_1.FunctionWrapper.bind(this._platformLocation.forward, this._platformLocation));
      this._broker.registerMethod('back', null, lang_1.FunctionWrapper.bind(this._platformLocation.back, this._platformLocation));
    };
    MessageBasedPlatformLocation.prototype._getLocation = function() {
      return Promise.resolve(this._platformLocation.location);
    };
    MessageBasedPlatformLocation.prototype._sendUrlChangeEvent = function(e) {
      var loc = this._serializer.serialize(this._platformLocation.location, serialized_types_1.LocationType);
      var serializedEvent = {'type': e.type};
      this._channelSink.emit({
        'event': serializedEvent,
        'location': loc
      });
    };
    MessageBasedPlatformLocation.prototype._setPathname = function(pathname) {
      this._platformLocation.pathname = pathname;
    };
    MessageBasedPlatformLocation.decorators = [{type: core_1.Injectable}];
    MessageBasedPlatformLocation.ctorParameters = [{type: service_message_broker_1.ServiceMessageBrokerFactory}, {type: browser_platform_location_1.BrowserPlatformLocation}, {type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}];
    return MessageBasedPlatformLocation;
  }());
  exports.MessageBasedPlatformLocation = MessageBasedPlatformLocation;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/ui/location_providers.js", ["@angular/core", "../../browser/location/browser_platform_location", "./platform_location"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var browser_platform_location_1 = $__require('../../browser/location/browser_platform_location');
  var platform_location_1 = $__require('./platform_location');
  exports.WORKER_UI_LOCATION_PROVIDERS = [platform_location_1.MessageBasedPlatformLocation, browser_platform_location_1.BrowserPlatformLocation, {
    provide: core_1.PLATFORM_INITIALIZER,
    useFactory: initUiLocation,
    multi: true,
    deps: [core_1.Injector]
  }];
  function initUiLocation(injector) {
    return function() {
      var zone = injector.get(core_1.NgZone);
      zone.runGuarded(function() {
        return injector.get(platform_location_1.MessageBasedPlatformLocation).start();
      });
    };
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/ui/event_serializer.js", ["../../facade/collection", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var MOUSE_EVENT_PROPERTIES = ['altKey', 'button', 'clientX', 'clientY', 'metaKey', 'movementX', 'movementY', 'offsetX', 'offsetY', 'region', 'screenX', 'screenY', 'shiftKey'];
  var KEYBOARD_EVENT_PROPERTIES = ['altkey', 'charCode', 'code', 'ctrlKey', 'isComposing', 'key', 'keyCode', 'location', 'metaKey', 'repeat', 'shiftKey', 'which'];
  var TRANSITION_EVENT_PROPERTIES = ['propertyName', 'elapsedTime', 'pseudoElement'];
  var EVENT_PROPERTIES = ['type', 'bubbles', 'cancelable'];
  var NODES_WITH_VALUE = new collection_1.Set(['input', 'select', 'option', 'button', 'li', 'meter', 'progress', 'param', 'textarea']);
  function serializeGenericEvent(e) {
    return serializeEvent(e, EVENT_PROPERTIES);
  }
  exports.serializeGenericEvent = serializeGenericEvent;
  function serializeEventWithTarget(e) {
    var serializedEvent = serializeEvent(e, EVENT_PROPERTIES);
    return addTarget(e, serializedEvent);
  }
  exports.serializeEventWithTarget = serializeEventWithTarget;
  function serializeMouseEvent(e) {
    return serializeEvent(e, MOUSE_EVENT_PROPERTIES);
  }
  exports.serializeMouseEvent = serializeMouseEvent;
  function serializeKeyboardEvent(e) {
    var serializedEvent = serializeEvent(e, KEYBOARD_EVENT_PROPERTIES);
    return addTarget(e, serializedEvent);
  }
  exports.serializeKeyboardEvent = serializeKeyboardEvent;
  function serializeTransitionEvent(e) {
    var serializedEvent = serializeEvent(e, TRANSITION_EVENT_PROPERTIES);
    return addTarget(e, serializedEvent);
  }
  exports.serializeTransitionEvent = serializeTransitionEvent;
  function addTarget(e, serializedEvent) {
    if (NODES_WITH_VALUE.has(e.target.tagName.toLowerCase())) {
      var target = e.target;
      serializedEvent['target'] = {'value': target.value};
      if (lang_1.isPresent(target.files)) {
        serializedEvent['target']['files'] = target.files;
      }
    }
    return serializedEvent;
  }
  function serializeEvent(e, properties) {
    var serialized = {};
    for (var i = 0; i < properties.length; i++) {
      var prop = properties[i];
      serialized[prop] = e[prop];
    }
    return serialized;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/ui/event_dispatcher.js", ["../../facade/exceptions", "../shared/serializer", "./event_serializer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../../facade/exceptions');
  var serializer_1 = $__require('../shared/serializer');
  var event_serializer_1 = $__require('./event_serializer');
  var EventDispatcher = (function() {
    function EventDispatcher(_sink, _serializer) {
      this._sink = _sink;
      this._serializer = _serializer;
    }
    EventDispatcher.prototype.dispatchRenderEvent = function(element, eventTarget, eventName, event) {
      var serializedEvent;
      switch (event.type) {
        case 'click':
        case 'mouseup':
        case 'mousedown':
        case 'dblclick':
        case 'contextmenu':
        case 'mouseenter':
        case 'mouseleave':
        case 'mousemove':
        case 'mouseout':
        case 'mouseover':
        case 'show':
          serializedEvent = event_serializer_1.serializeMouseEvent(event);
          break;
        case 'keydown':
        case 'keypress':
        case 'keyup':
          serializedEvent = event_serializer_1.serializeKeyboardEvent(event);
          break;
        case 'input':
        case 'change':
        case 'blur':
          serializedEvent = event_serializer_1.serializeEventWithTarget(event);
          break;
        case 'abort':
        case 'afterprint':
        case 'beforeprint':
        case 'cached':
        case 'canplay':
        case 'canplaythrough':
        case 'chargingchange':
        case 'chargingtimechange':
        case 'close':
        case 'dischargingtimechange':
        case 'DOMContentLoaded':
        case 'downloading':
        case 'durationchange':
        case 'emptied':
        case 'ended':
        case 'error':
        case 'fullscreenchange':
        case 'fullscreenerror':
        case 'invalid':
        case 'languagechange':
        case 'levelfchange':
        case 'loadeddata':
        case 'loadedmetadata':
        case 'obsolete':
        case 'offline':
        case 'online':
        case 'open':
        case 'orientatoinchange':
        case 'pause':
        case 'pointerlockchange':
        case 'pointerlockerror':
        case 'play':
        case 'playing':
        case 'ratechange':
        case 'readystatechange':
        case 'reset':
        case 'scroll':
        case 'seeked':
        case 'seeking':
        case 'stalled':
        case 'submit':
        case 'success':
        case 'suspend':
        case 'timeupdate':
        case 'updateready':
        case 'visibilitychange':
        case 'volumechange':
        case 'waiting':
          serializedEvent = event_serializer_1.serializeGenericEvent(event);
          break;
        case 'transitionend':
          serializedEvent = event_serializer_1.serializeTransitionEvent(event);
          break;
        default:
          throw new exceptions_1.BaseException(eventName + ' not supported on WebWorkers');
      }
      this._sink.emit({
        'element': this._serializer.serialize(element, serializer_1.RenderStoreObject),
        'eventName': eventName,
        'eventTarget': eventTarget,
        'event': serializedEvent
      });
      return false;
    };
    return EventDispatcher;
  }());
  exports.EventDispatcher = EventDispatcher;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/ui/renderer.js", ["@angular/core", "../../facade/lang", "../shared/message_bus", "../shared/messaging_api", "../shared/render_store", "../shared/serializer", "../shared/service_message_broker", "../ui/event_dispatcher"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../../facade/lang');
  var message_bus_1 = $__require('../shared/message_bus');
  var messaging_api_1 = $__require('../shared/messaging_api');
  var render_store_1 = $__require('../shared/render_store');
  var serializer_1 = $__require('../shared/serializer');
  var service_message_broker_1 = $__require('../shared/service_message_broker');
  var event_dispatcher_1 = $__require('../ui/event_dispatcher');
  var MessageBasedRenderer = (function() {
    function MessageBasedRenderer(_brokerFactory, _bus, _serializer, _renderStore, _rootRenderer) {
      this._brokerFactory = _brokerFactory;
      this._bus = _bus;
      this._serializer = _serializer;
      this._renderStore = _renderStore;
      this._rootRenderer = _rootRenderer;
    }
    MessageBasedRenderer.prototype.start = function() {
      var broker = this._brokerFactory.createMessageBroker(messaging_api_1.RENDERER_CHANNEL);
      this._bus.initChannel(messaging_api_1.EVENT_CHANNEL);
      this._eventDispatcher = new event_dispatcher_1.EventDispatcher(this._bus.to(messaging_api_1.EVENT_CHANNEL), this._serializer);
      broker.registerMethod('renderComponent', [core_1.RenderComponentType, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._renderComponent, this));
      broker.registerMethod('selectRootElement', [serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._selectRootElement, this));
      broker.registerMethod('createElement', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createElement, this));
      broker.registerMethod('createViewRoot', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createViewRoot, this));
      broker.registerMethod('createTemplateAnchor', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createTemplateAnchor, this));
      broker.registerMethod('createText', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._createText, this));
      broker.registerMethod('projectNodes', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._projectNodes, this));
      broker.registerMethod('attachViewAfter', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._attachViewAfter, this));
      broker.registerMethod('detachView', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._detachView, this));
      broker.registerMethod('destroyView', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._destroyView, this));
      broker.registerMethod('setElementProperty', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementProperty, this));
      broker.registerMethod('setElementAttribute', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementAttribute, this));
      broker.registerMethod('setBindingDebugInfo', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setBindingDebugInfo, this));
      broker.registerMethod('setElementClass', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementClass, this));
      broker.registerMethod('setElementStyle', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setElementStyle, this));
      broker.registerMethod('invokeElementMethod', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._invokeElementMethod, this));
      broker.registerMethod('setText', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._setText, this));
      broker.registerMethod('listen', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._listen, this));
      broker.registerMethod('listenGlobal', [serializer_1.RenderStoreObject, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE, serializer_1.PRIMITIVE], lang_1.FunctionWrapper.bind(this._listenGlobal, this));
      broker.registerMethod('listenDone', [serializer_1.RenderStoreObject, serializer_1.RenderStoreObject], lang_1.FunctionWrapper.bind(this._listenDone, this));
    };
    MessageBasedRenderer.prototype._renderComponent = function(renderComponentType, rendererId) {
      var renderer = this._rootRenderer.renderComponent(renderComponentType);
      this._renderStore.store(renderer, rendererId);
    };
    MessageBasedRenderer.prototype._selectRootElement = function(renderer, selector, elId) {
      this._renderStore.store(renderer.selectRootElement(selector, null), elId);
    };
    MessageBasedRenderer.prototype._createElement = function(renderer, parentElement, name, elId) {
      this._renderStore.store(renderer.createElement(parentElement, name, null), elId);
    };
    MessageBasedRenderer.prototype._createViewRoot = function(renderer, hostElement, elId) {
      var viewRoot = renderer.createViewRoot(hostElement);
      if (this._renderStore.serialize(hostElement) !== elId) {
        this._renderStore.store(viewRoot, elId);
      }
    };
    MessageBasedRenderer.prototype._createTemplateAnchor = function(renderer, parentElement, elId) {
      this._renderStore.store(renderer.createTemplateAnchor(parentElement, null), elId);
    };
    MessageBasedRenderer.prototype._createText = function(renderer, parentElement, value, elId) {
      this._renderStore.store(renderer.createText(parentElement, value, null), elId);
    };
    MessageBasedRenderer.prototype._projectNodes = function(renderer, parentElement, nodes) {
      renderer.projectNodes(parentElement, nodes);
    };
    MessageBasedRenderer.prototype._attachViewAfter = function(renderer, node, viewRootNodes) {
      renderer.attachViewAfter(node, viewRootNodes);
    };
    MessageBasedRenderer.prototype._detachView = function(renderer, viewRootNodes) {
      renderer.detachView(viewRootNodes);
    };
    MessageBasedRenderer.prototype._destroyView = function(renderer, hostElement, viewAllNodes) {
      renderer.destroyView(hostElement, viewAllNodes);
      for (var i = 0; i < viewAllNodes.length; i++) {
        this._renderStore.remove(viewAllNodes[i]);
      }
    };
    MessageBasedRenderer.prototype._setElementProperty = function(renderer, renderElement, propertyName, propertyValue) {
      renderer.setElementProperty(renderElement, propertyName, propertyValue);
    };
    MessageBasedRenderer.prototype._setElementAttribute = function(renderer, renderElement, attributeName, attributeValue) {
      renderer.setElementAttribute(renderElement, attributeName, attributeValue);
    };
    MessageBasedRenderer.prototype._setBindingDebugInfo = function(renderer, renderElement, propertyName, propertyValue) {
      renderer.setBindingDebugInfo(renderElement, propertyName, propertyValue);
    };
    MessageBasedRenderer.prototype._setElementClass = function(renderer, renderElement, className, isAdd) {
      renderer.setElementClass(renderElement, className, isAdd);
    };
    MessageBasedRenderer.prototype._setElementStyle = function(renderer, renderElement, styleName, styleValue) {
      renderer.setElementStyle(renderElement, styleName, styleValue);
    };
    MessageBasedRenderer.prototype._invokeElementMethod = function(renderer, renderElement, methodName, args) {
      renderer.invokeElementMethod(renderElement, methodName, args);
    };
    MessageBasedRenderer.prototype._setText = function(renderer, renderNode, text) {
      renderer.setText(renderNode, text);
    };
    MessageBasedRenderer.prototype._listen = function(renderer, renderElement, eventName, unlistenId) {
      var _this = this;
      var unregisterCallback = renderer.listen(renderElement, eventName, function(event) {
        return _this._eventDispatcher.dispatchRenderEvent(renderElement, null, eventName, event);
      });
      this._renderStore.store(unregisterCallback, unlistenId);
    };
    MessageBasedRenderer.prototype._listenGlobal = function(renderer, eventTarget, eventName, unlistenId) {
      var _this = this;
      var unregisterCallback = renderer.listenGlobal(eventTarget, eventName, function(event) {
        return _this._eventDispatcher.dispatchRenderEvent(null, eventTarget, eventName, event);
      });
      this._renderStore.store(unregisterCallback, unlistenId);
    };
    MessageBasedRenderer.prototype._listenDone = function(renderer, unlistenCallback) {
      unlistenCallback();
    };
    MessageBasedRenderer.decorators = [{type: core_1.Injectable}];
    MessageBasedRenderer.ctorParameters = [{type: service_message_broker_1.ServiceMessageBrokerFactory}, {type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}, {type: render_store_1.RenderStore}, {type: core_1.RootRenderer}];
    return MessageBasedRenderer;
  }());
  exports.MessageBasedRenderer = MessageBasedRenderer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/worker_render.js", ["@angular/core", "../core_private", "./browser", "./browser/browser_adapter", "./browser/testability", "./dom/animation_driver", "./dom/dom_adapter", "./dom/dom_renderer", "./dom/dom_tokens", "./dom/events/dom_events", "./dom/events/event_manager", "./dom/events/hammer_gestures", "./dom/events/key_events", "./dom/shared_styles_host", "./facade/exceptions", "./web_workers/shared/api", "./web_workers/shared/client_message_broker", "./web_workers/shared/message_bus", "./web_workers/shared/post_message_bus", "./web_workers/shared/render_store", "./web_workers/shared/serializer", "./web_workers/shared/service_message_broker", "./web_workers/ui/renderer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var browser_1 = $__require('./browser');
  var browser_adapter_1 = $__require('./browser/browser_adapter');
  var testability_1 = $__require('./browser/testability');
  var animation_driver_1 = $__require('./dom/animation_driver');
  var dom_adapter_1 = $__require('./dom/dom_adapter');
  var dom_renderer_1 = $__require('./dom/dom_renderer');
  var dom_tokens_1 = $__require('./dom/dom_tokens');
  var dom_events_1 = $__require('./dom/events/dom_events');
  var event_manager_1 = $__require('./dom/events/event_manager');
  var hammer_gestures_1 = $__require('./dom/events/hammer_gestures');
  var key_events_1 = $__require('./dom/events/key_events');
  var shared_styles_host_1 = $__require('./dom/shared_styles_host');
  var exceptions_1 = $__require('./facade/exceptions');
  var api_1 = $__require('./web_workers/shared/api');
  var client_message_broker_1 = $__require('./web_workers/shared/client_message_broker');
  var message_bus_1 = $__require('./web_workers/shared/message_bus');
  var post_message_bus_1 = $__require('./web_workers/shared/post_message_bus');
  var render_store_1 = $__require('./web_workers/shared/render_store');
  var serializer_1 = $__require('./web_workers/shared/serializer');
  var service_message_broker_1 = $__require('./web_workers/shared/service_message_broker');
  var renderer_1 = $__require('./web_workers/ui/renderer');
  var WebWorkerInstance = (function() {
    function WebWorkerInstance() {}
    WebWorkerInstance.prototype.init = function(worker, bus) {
      this.worker = worker;
      this.bus = bus;
    };
    WebWorkerInstance.decorators = [{type: core_1.Injectable}];
    return WebWorkerInstance;
  }());
  exports.WebWorkerInstance = WebWorkerInstance;
  exports.WORKER_SCRIPT = new core_1.OpaqueToken('WebWorkerScript');
  exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE = new core_1.OpaqueToken('WorkerRenderStartableMsgService');
  exports._WORKER_UI_PLATFORM_PROVIDERS = [{
    provide: core_1.NgZone,
    useFactory: createNgZone,
    deps: []
  }, renderer_1.MessageBasedRenderer, {
    provide: exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE,
    useExisting: renderer_1.MessageBasedRenderer,
    multi: true
  }, browser_1.BROWSER_SANITIZATION_PROVIDERS, {
    provide: core_1.ExceptionHandler,
    useFactory: _exceptionHandler,
    deps: []
  }, {
    provide: dom_tokens_1.DOCUMENT,
    useFactory: _document,
    deps: []
  }, {
    provide: event_manager_1.EVENT_MANAGER_PLUGINS,
    useClass: dom_events_1.DomEventsPlugin,
    multi: true
  }, {
    provide: event_manager_1.EVENT_MANAGER_PLUGINS,
    useClass: key_events_1.KeyEventsPlugin,
    multi: true
  }, {
    provide: event_manager_1.EVENT_MANAGER_PLUGINS,
    useClass: hammer_gestures_1.HammerGesturesPlugin,
    multi: true
  }, {
    provide: hammer_gestures_1.HAMMER_GESTURE_CONFIG,
    useClass: hammer_gestures_1.HammerGestureConfig
  }, {
    provide: dom_renderer_1.DomRootRenderer,
    useClass: dom_renderer_1.DomRootRenderer_
  }, {
    provide: core_1.RootRenderer,
    useExisting: dom_renderer_1.DomRootRenderer
  }, {
    provide: shared_styles_host_1.SharedStylesHost,
    useExisting: shared_styles_host_1.DomSharedStylesHost
  }, {
    provide: service_message_broker_1.ServiceMessageBrokerFactory,
    useClass: service_message_broker_1.ServiceMessageBrokerFactory_
  }, {
    provide: client_message_broker_1.ClientMessageBrokerFactory,
    useClass: client_message_broker_1.ClientMessageBrokerFactory_
  }, {
    provide: animation_driver_1.AnimationDriver,
    useFactory: _resolveDefaultAnimationDriver
  }, serializer_1.Serializer, {
    provide: api_1.ON_WEB_WORKER,
    useValue: false
  }, render_store_1.RenderStore, shared_styles_host_1.DomSharedStylesHost, core_1.Testability, event_manager_1.EventManager, WebWorkerInstance, {
    provide: core_1.PLATFORM_INITIALIZER,
    useFactory: initWebWorkerRenderPlatform,
    multi: true,
    deps: [core_1.Injector]
  }, {
    provide: message_bus_1.MessageBus,
    useFactory: messageBusFactory,
    deps: [WebWorkerInstance]
  }];
  exports.WORKER_UI_PLATFORM_PROVIDERS = [core_1.PLATFORM_COMMON_PROVIDERS, exports._WORKER_UI_PLATFORM_PROVIDERS];
  exports.WORKER_UI_APPLICATION_PROVIDERS = [];
  function initializeGenericWorkerRenderer(injector) {
    var bus = injector.get(message_bus_1.MessageBus);
    var zone = injector.get(core_1.NgZone);
    bus.attachToZone(zone);
    var services = injector.get(exports.WORKER_UI_STARTABLE_MESSAGING_SERVICE);
    zone.runGuarded(function() {
      services.forEach(function(svc) {
        svc.start();
      });
    });
  }
  function messageBusFactory(instance) {
    return instance.bus;
  }
  function initWebWorkerRenderPlatform(injector) {
    return function() {
      browser_adapter_1.BrowserDomAdapter.makeCurrent();
      core_private_1.wtfInit();
      testability_1.BrowserGetTestability.init();
      var scriptUri;
      try {
        scriptUri = injector.get(exports.WORKER_SCRIPT);
      } catch (e) {
        throw new exceptions_1.BaseException('You must provide your WebWorker\'s initialization script with the WORKER_SCRIPT token');
      }
      var instance = injector.get(WebWorkerInstance);
      spawnWebWorker(scriptUri, instance);
      initializeGenericWorkerRenderer(injector);
    };
  }
  exports.platformWorkerUi = core_1.createPlatformFactory(core_1.platformCore, 'workerUi', exports._WORKER_UI_PLATFORM_PROVIDERS);
  exports.workerUiPlatform = exports.platformWorkerUi;
  function _exceptionHandler() {
    return new core_1.ExceptionHandler(dom_adapter_1.getDOM());
  }
  function _document() {
    return dom_adapter_1.getDOM().defaultDoc();
  }
  function createNgZone() {
    return new core_1.NgZone({enableLongStackTrace: core_1.isDevMode()});
  }
  function spawnWebWorker(uri, instance) {
    var webWorker = new Worker(uri);
    var sink = new post_message_bus_1.PostMessageBusSink(webWorker);
    var source = new post_message_bus_1.PostMessageBusSource(webWorker);
    var bus = new post_message_bus_1.PostMessageBus(sink, source);
    instance.init(webWorker, bus);
  }
  function _resolveDefaultAnimationDriver() {
    return animation_driver_1.AnimationDriver.NOOP;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/api.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.ON_WEB_WORKER = new core_1.OpaqueToken('WebWorker.onWebWorker');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/async.js", ["rxjs/Subject", "rxjs/Observable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subject_1 = $__require('rxjs/Subject');
  var Observable_1 = $__require('rxjs/Observable');
  exports.Observable = Observable_1.Observable;
  var Subject_2 = $__require('rxjs/Subject');
  exports.Subject = Subject_2.Subject;
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = false;
      }
      _super.call(this);
      this.__isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.next = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(Subject_1.Subject));
  exports.EventEmitter = EventEmitter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/post_message_bus.js", ["@angular/core", "../../facade/async", "../../facade/collection", "../../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var PostMessageBusSink = (function() {
    function PostMessageBusSink(_postMessageTarget) {
      this._postMessageTarget = _postMessageTarget;
      this._channels = collection_1.StringMapWrapper.create();
      this._messageBuffer = [];
    }
    PostMessageBusSink.prototype.attachToZone = function(zone) {
      var _this = this;
      this._zone = zone;
      this._zone.runOutsideAngular(function() {
        _this._zone.onStable.subscribe({next: function() {
            _this._handleOnEventDone();
          }});
      });
    };
    PostMessageBusSink.prototype.initChannel = function(channel, runInZone) {
      var _this = this;
      if (runInZone === void 0) {
        runInZone = true;
      }
      if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
        throw new exceptions_1.BaseException(channel + " has already been initialized");
      }
      var emitter = new async_1.EventEmitter(false);
      var channelInfo = new _Channel(emitter, runInZone);
      this._channels[channel] = channelInfo;
      emitter.subscribe(function(data) {
        var message = {
          channel: channel,
          message: data
        };
        if (runInZone) {
          _this._messageBuffer.push(message);
        } else {
          _this._sendMessages([message]);
        }
      });
    };
    PostMessageBusSink.prototype.to = function(channel) {
      if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
        return this._channels[channel].emitter;
      } else {
        throw new exceptions_1.BaseException(channel + " is not set up. Did you forget to call initChannel?");
      }
    };
    PostMessageBusSink.prototype._handleOnEventDone = function() {
      if (this._messageBuffer.length > 0) {
        this._sendMessages(this._messageBuffer);
        this._messageBuffer = [];
      }
    };
    PostMessageBusSink.prototype._sendMessages = function(messages) {
      this._postMessageTarget.postMessage(messages);
    };
    return PostMessageBusSink;
  }());
  exports.PostMessageBusSink = PostMessageBusSink;
  var PostMessageBusSource = (function() {
    function PostMessageBusSource(eventTarget) {
      var _this = this;
      this._channels = collection_1.StringMapWrapper.create();
      if (eventTarget) {
        eventTarget.addEventListener('message', function(ev) {
          return _this._handleMessages(ev);
        });
      } else {
        var workerScope = self;
        workerScope.addEventListener('message', function(ev) {
          return _this._handleMessages(ev);
        });
      }
    }
    PostMessageBusSource.prototype.attachToZone = function(zone) {
      this._zone = zone;
    };
    PostMessageBusSource.prototype.initChannel = function(channel, runInZone) {
      if (runInZone === void 0) {
        runInZone = true;
      }
      if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
        throw new exceptions_1.BaseException(channel + " has already been initialized");
      }
      var emitter = new async_1.EventEmitter(false);
      var channelInfo = new _Channel(emitter, runInZone);
      this._channels[channel] = channelInfo;
    };
    PostMessageBusSource.prototype.from = function(channel) {
      if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
        return this._channels[channel].emitter;
      } else {
        throw new exceptions_1.BaseException(channel + " is not set up. Did you forget to call initChannel?");
      }
    };
    PostMessageBusSource.prototype._handleMessages = function(ev) {
      var messages = ev.data;
      for (var i = 0; i < messages.length; i++) {
        this._handleMessage(messages[i]);
      }
    };
    PostMessageBusSource.prototype._handleMessage = function(data) {
      var channel = data.channel;
      if (collection_1.StringMapWrapper.contains(this._channels, channel)) {
        var channelInfo = this._channels[channel];
        if (channelInfo.runInZone) {
          this._zone.run(function() {
            channelInfo.emitter.emit(data.message);
          });
        } else {
          channelInfo.emitter.emit(data.message);
        }
      }
    };
    return PostMessageBusSource;
  }());
  exports.PostMessageBusSource = PostMessageBusSource;
  var PostMessageBus = (function() {
    function PostMessageBus(sink, source) {
      this.sink = sink;
      this.source = source;
    }
    PostMessageBus.prototype.attachToZone = function(zone) {
      this.source.attachToZone(zone);
      this.sink.attachToZone(zone);
    };
    PostMessageBus.prototype.initChannel = function(channel, runInZone) {
      if (runInZone === void 0) {
        runInZone = true;
      }
      this.source.initChannel(channel, runInZone);
      this.sink.initChannel(channel, runInZone);
    };
    PostMessageBus.prototype.from = function(channel) {
      return this.source.from(channel);
    };
    PostMessageBus.prototype.to = function(channel) {
      return this.sink.to(channel);
    };
    PostMessageBus.decorators = [{type: core_1.Injectable}];
    PostMessageBus.ctorParameters = [{type: PostMessageBusSink}, {type: PostMessageBusSource}];
    return PostMessageBus;
  }());
  exports.PostMessageBus = PostMessageBus;
  var _Channel = (function() {
    function _Channel(emitter, runInZone) {
      this.emitter = emitter;
      this.runInZone = runInZone;
    }
    return _Channel;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/service_message_broker.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "../shared/message_bus", "../shared/serializer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var message_bus_1 = $__require('../shared/message_bus');
  var serializer_1 = $__require('../shared/serializer');
  var ServiceMessageBrokerFactory = (function() {
    function ServiceMessageBrokerFactory() {}
    return ServiceMessageBrokerFactory;
  }());
  exports.ServiceMessageBrokerFactory = ServiceMessageBrokerFactory;
  var ServiceMessageBrokerFactory_ = (function(_super) {
    __extends(ServiceMessageBrokerFactory_, _super);
    function ServiceMessageBrokerFactory_(_messageBus, _serializer) {
      _super.call(this);
      this._messageBus = _messageBus;
      this._serializer = _serializer;
    }
    ServiceMessageBrokerFactory_.prototype.createMessageBroker = function(channel, runInZone) {
      if (runInZone === void 0) {
        runInZone = true;
      }
      this._messageBus.initChannel(channel, runInZone);
      return new ServiceMessageBroker_(this._messageBus, this._serializer, channel);
    };
    ServiceMessageBrokerFactory_.decorators = [{type: core_1.Injectable}];
    ServiceMessageBrokerFactory_.ctorParameters = [{type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}];
    return ServiceMessageBrokerFactory_;
  }(ServiceMessageBrokerFactory));
  exports.ServiceMessageBrokerFactory_ = ServiceMessageBrokerFactory_;
  var ServiceMessageBroker = (function() {
    function ServiceMessageBroker() {}
    return ServiceMessageBroker;
  }());
  exports.ServiceMessageBroker = ServiceMessageBroker;
  var ServiceMessageBroker_ = (function(_super) {
    __extends(ServiceMessageBroker_, _super);
    function ServiceMessageBroker_(messageBus, _serializer, channel) {
      var _this = this;
      _super.call(this);
      this._serializer = _serializer;
      this.channel = channel;
      this._methods = new collection_1.Map();
      this._sink = messageBus.to(channel);
      var source = messageBus.from(channel);
      source.subscribe({next: function(message) {
          return _this._handleMessage(message);
        }});
    }
    ServiceMessageBroker_.prototype.registerMethod = function(methodName, signature, method, returnType) {
      var _this = this;
      this._methods.set(methodName, function(message) {
        var serializedArgs = message.args;
        var numArgs = signature === null ? 0 : signature.length;
        var deserializedArgs = collection_1.ListWrapper.createFixedSize(numArgs);
        for (var i = 0; i < numArgs; i++) {
          var serializedArg = serializedArgs[i];
          deserializedArgs[i] = _this._serializer.deserialize(serializedArg, signature[i]);
        }
        var promise = lang_1.FunctionWrapper.apply(method, deserializedArgs);
        if (lang_1.isPresent(returnType) && lang_1.isPresent(promise)) {
          _this._wrapWebWorkerPromise(message.id, promise, returnType);
        }
      });
    };
    ServiceMessageBroker_.prototype._handleMessage = function(map) {
      var message = new ReceivedMessage(map);
      if (this._methods.has(message.method)) {
        this._methods.get(message.method)(message);
      }
    };
    ServiceMessageBroker_.prototype._wrapWebWorkerPromise = function(id, promise, type) {
      var _this = this;
      promise.then(function(result) {
        _this._sink.emit({
          'type': 'result',
          'value': _this._serializer.serialize(result, type),
          'id': id
        });
      });
    };
    return ServiceMessageBroker_;
  }(ServiceMessageBroker));
  exports.ServiceMessageBroker_ = ServiceMessageBroker_;
  var ReceivedMessage = (function() {
    function ReceivedMessage(data) {
      this.method = data['method'];
      this.args = data['args'];
      this.id = data['id'];
      this.type = data['type'];
    }
    return ReceivedMessage;
  }());
  exports.ReceivedMessage = ReceivedMessage;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/client_message_broker.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "./message_bus", "./serializer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var message_bus_1 = $__require('./message_bus');
  var serializer_1 = $__require('./serializer');
  var ClientMessageBrokerFactory = (function() {
    function ClientMessageBrokerFactory() {}
    return ClientMessageBrokerFactory;
  }());
  exports.ClientMessageBrokerFactory = ClientMessageBrokerFactory;
  var ClientMessageBrokerFactory_ = (function(_super) {
    __extends(ClientMessageBrokerFactory_, _super);
    function ClientMessageBrokerFactory_(_messageBus, _serializer) {
      _super.call(this);
      this._messageBus = _messageBus;
      this._serializer = _serializer;
    }
    ClientMessageBrokerFactory_.prototype.createMessageBroker = function(channel, runInZone) {
      if (runInZone === void 0) {
        runInZone = true;
      }
      this._messageBus.initChannel(channel, runInZone);
      return new ClientMessageBroker_(this._messageBus, this._serializer, channel);
    };
    ClientMessageBrokerFactory_.decorators = [{type: core_1.Injectable}];
    ClientMessageBrokerFactory_.ctorParameters = [{type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}];
    return ClientMessageBrokerFactory_;
  }(ClientMessageBrokerFactory));
  exports.ClientMessageBrokerFactory_ = ClientMessageBrokerFactory_;
  var ClientMessageBroker = (function() {
    function ClientMessageBroker() {}
    return ClientMessageBroker;
  }());
  exports.ClientMessageBroker = ClientMessageBroker;
  var ClientMessageBroker_ = (function(_super) {
    __extends(ClientMessageBroker_, _super);
    function ClientMessageBroker_(messageBus, _serializer, channel) {
      var _this = this;
      _super.call(this);
      this.channel = channel;
      this._pending = new Map();
      this._sink = messageBus.to(channel);
      this._serializer = _serializer;
      var source = messageBus.from(channel);
      source.subscribe({next: function(message) {
          return _this._handleMessage(message);
        }});
    }
    ClientMessageBroker_.prototype._generateMessageId = function(name) {
      var time = lang_1.stringify(lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now()));
      var iteration = 0;
      var id = name + time + lang_1.stringify(iteration);
      while (lang_1.isPresent(this._pending[id])) {
        id = "" + name + time + iteration;
        iteration++;
      }
      return id;
    };
    ClientMessageBroker_.prototype.runOnService = function(args, returnType) {
      var _this = this;
      var fnArgs = [];
      if (lang_1.isPresent(args.args)) {
        args.args.forEach(function(argument) {
          if (argument.type != null) {
            fnArgs.push(_this._serializer.serialize(argument.value, argument.type));
          } else {
            fnArgs.push(argument.value);
          }
        });
      }
      var promise;
      var id = null;
      if (returnType != null) {
        var completer_1;
        promise = new Promise(function(resolve, reject) {
          completer_1 = {
            resolve: resolve,
            reject: reject
          };
        });
        id = this._generateMessageId(args.method);
        this._pending.set(id, completer_1);
        promise.catch(function(err) {
          lang_1.print(err);
          completer_1.reject(err);
        });
        promise = promise.then(function(value) {
          if (_this._serializer == null) {
            return value;
          } else {
            return _this._serializer.deserialize(value, returnType);
          }
        });
      } else {
        promise = null;
      }
      var message = {
        'method': args.method,
        'args': fnArgs
      };
      if (id != null) {
        message['id'] = id;
      }
      this._sink.emit(message);
      return promise;
    };
    ClientMessageBroker_.prototype._handleMessage = function(message) {
      var data = new MessageData(message);
      if (lang_1.StringWrapper.equals(data.type, 'result') || lang_1.StringWrapper.equals(data.type, 'error')) {
        var id = data.id;
        if (this._pending.has(id)) {
          if (lang_1.StringWrapper.equals(data.type, 'result')) {
            this._pending.get(id).resolve(data.value);
          } else {
            this._pending.get(id).reject(data.value);
          }
          this._pending.delete(id);
        }
      }
    };
    return ClientMessageBroker_;
  }(ClientMessageBroker));
  exports.ClientMessageBroker_ = ClientMessageBroker_;
  var MessageData = (function() {
    function MessageData(data) {
      this.type = collection_1.StringMapWrapper.get(data, 'type');
      this.id = this._getValueIfPresent(data, 'id');
      this.value = this._getValueIfPresent(data, 'value');
    }
    MessageData.prototype._getValueIfPresent = function(data, key) {
      if (collection_1.StringMapWrapper.contains(data, key)) {
        return collection_1.StringMapWrapper.get(data, key);
      } else {
        return null;
      }
    };
    return MessageData;
  }());
  var FnArg = (function() {
    function FnArg(value, type) {
      this.value = value;
      this.type = type;
    }
    return FnArg;
  }());
  exports.FnArg = FnArg;
  var UiArguments = (function() {
    function UiArguments(method, args) {
      this.method = method;
      this.args = args;
    }
    return UiArguments;
  }());
  exports.UiArguments = UiArguments;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/message_bus.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var MessageBus = (function() {
    function MessageBus() {}
    return MessageBus;
  }());
  exports.MessageBus = MessageBus;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/messaging_api.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.RENDERER_CHANNEL = 'ng-Renderer';
  exports.EVENT_CHANNEL = 'ng-Events';
  exports.ROUTER_CHANNEL = 'ng-Router';
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/render_store.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var RenderStore = (function() {
    function RenderStore() {
      this._nextIndex = 0;
      this._lookupById = new Map();
      this._lookupByObject = new Map();
    }
    RenderStore.prototype.allocateId = function() {
      return this._nextIndex++;
    };
    RenderStore.prototype.store = function(obj, id) {
      this._lookupById.set(id, obj);
      this._lookupByObject.set(obj, id);
    };
    RenderStore.prototype.remove = function(obj) {
      var index = this._lookupByObject.get(obj);
      this._lookupByObject.delete(obj);
      this._lookupById.delete(index);
    };
    RenderStore.prototype.deserialize = function(id) {
      if (id == null) {
        return null;
      }
      if (!this._lookupById.has(id)) {
        return null;
      }
      return this._lookupById.get(id);
    };
    RenderStore.prototype.serialize = function(obj) {
      if (obj == null) {
        return null;
      }
      return this._lookupByObject.get(obj);
    };
    RenderStore.decorators = [{type: core_1.Injectable}];
    RenderStore.ctorParameters = [];
    return RenderStore;
  }());
  exports.RenderStore = RenderStore;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/serialized_types.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var LocationType = (function() {
    function LocationType(href, protocol, host, hostname, port, pathname, search, hash, origin) {
      this.href = href;
      this.protocol = protocol;
      this.host = host;
      this.hostname = hostname;
      this.port = port;
      this.pathname = pathname;
      this.search = search;
      this.hash = hash;
      this.origin = origin;
    }
    return LocationType;
  }());
  exports.LocationType = LocationType;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/shared/serializer.js", ["@angular/core", "../../../core_private", "../../facade/exceptions", "../../facade/lang", "./render_store", "./serialized_types"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../../core_private');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var render_store_1 = $__require('./render_store');
  var serialized_types_1 = $__require('./serialized_types');
  exports.PRIMITIVE = String;
  var Serializer = (function() {
    function Serializer(_renderStore) {
      this._renderStore = _renderStore;
    }
    Serializer.prototype.serialize = function(obj, type) {
      var _this = this;
      if (!lang_1.isPresent(obj)) {
        return null;
      }
      if (lang_1.isArray(obj)) {
        return obj.map(function(v) {
          return _this.serialize(v, type);
        });
      }
      if (type == exports.PRIMITIVE) {
        return obj;
      }
      if (type == RenderStoreObject) {
        return this._renderStore.serialize(obj);
      } else if (type === core_1.RenderComponentType) {
        return this._serializeRenderComponentType(obj);
      } else if (type === core_1.ViewEncapsulation) {
        return lang_1.serializeEnum(obj);
      } else if (type === serialized_types_1.LocationType) {
        return this._serializeLocation(obj);
      } else {
        throw new exceptions_1.BaseException('No serializer for ' + type.toString());
      }
    };
    Serializer.prototype.deserialize = function(map, type, data) {
      var _this = this;
      if (!lang_1.isPresent(map)) {
        return null;
      }
      if (lang_1.isArray(map)) {
        var obj = [];
        map.forEach(function(val) {
          return obj.push(_this.deserialize(val, type, data));
        });
        return obj;
      }
      if (type == exports.PRIMITIVE) {
        return map;
      }
      if (type == RenderStoreObject) {
        return this._renderStore.deserialize(map);
      } else if (type === core_1.RenderComponentType) {
        return this._deserializeRenderComponentType(map);
      } else if (type === core_1.ViewEncapsulation) {
        return core_private_1.VIEW_ENCAPSULATION_VALUES[map];
      } else if (type === serialized_types_1.LocationType) {
        return this._deserializeLocation(map);
      } else {
        throw new exceptions_1.BaseException('No deserializer for ' + type.toString());
      }
    };
    Serializer.prototype._serializeLocation = function(loc) {
      return {
        'href': loc.href,
        'protocol': loc.protocol,
        'host': loc.host,
        'hostname': loc.hostname,
        'port': loc.port,
        'pathname': loc.pathname,
        'search': loc.search,
        'hash': loc.hash,
        'origin': loc.origin
      };
    };
    Serializer.prototype._deserializeLocation = function(loc) {
      return new serialized_types_1.LocationType(loc['href'], loc['protocol'], loc['host'], loc['hostname'], loc['port'], loc['pathname'], loc['search'], loc['hash'], loc['origin']);
    };
    Serializer.prototype._serializeRenderComponentType = function(obj) {
      return {
        'id': obj.id,
        'templateUrl': obj.templateUrl,
        'slotCount': obj.slotCount,
        'encapsulation': this.serialize(obj.encapsulation, core_1.ViewEncapsulation),
        'styles': this.serialize(obj.styles, exports.PRIMITIVE)
      };
    };
    Serializer.prototype._deserializeRenderComponentType = function(map) {
      return new core_1.RenderComponentType(map['id'], map['templateUrl'], map['slotCount'], this.deserialize(map['encapsulation'], core_1.ViewEncapsulation), this.deserialize(map['styles'], exports.PRIMITIVE), {});
    };
    Serializer.decorators = [{type: core_1.Injectable}];
    Serializer.ctorParameters = [{type: render_store_1.RenderStore}];
    return Serializer;
  }());
  exports.Serializer = Serializer;
  var RenderStoreObject = (function() {
    function RenderStoreObject() {}
    return RenderStoreObject;
  }());
  exports.RenderStoreObject = RenderStoreObject;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/worker/event_deserializer.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function deserializeGenericEvent(serializedEvent) {
    return serializedEvent;
  }
  exports.deserializeGenericEvent = deserializeGenericEvent;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/worker/renderer.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "../shared/client_message_broker", "../shared/message_bus", "../shared/messaging_api", "../shared/render_store", "../shared/serializer", "./event_deserializer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var client_message_broker_1 = $__require('../shared/client_message_broker');
  var message_bus_1 = $__require('../shared/message_bus');
  var messaging_api_1 = $__require('../shared/messaging_api');
  var render_store_1 = $__require('../shared/render_store');
  var serializer_1 = $__require('../shared/serializer');
  var event_deserializer_1 = $__require('./event_deserializer');
  var WebWorkerRootRenderer = (function() {
    function WebWorkerRootRenderer(messageBrokerFactory, bus, _serializer, _renderStore) {
      var _this = this;
      this._serializer = _serializer;
      this._renderStore = _renderStore;
      this.globalEvents = new NamedEventEmitter();
      this._componentRenderers = new Map();
      this._messageBroker = messageBrokerFactory.createMessageBroker(messaging_api_1.RENDERER_CHANNEL);
      bus.initChannel(messaging_api_1.EVENT_CHANNEL);
      var source = bus.from(messaging_api_1.EVENT_CHANNEL);
      source.subscribe({next: function(message) {
          return _this._dispatchEvent(message);
        }});
    }
    WebWorkerRootRenderer.prototype._dispatchEvent = function(message) {
      var eventName = message['eventName'];
      var target = message['eventTarget'];
      var event = event_deserializer_1.deserializeGenericEvent(message['event']);
      if (lang_1.isPresent(target)) {
        this.globalEvents.dispatchEvent(eventNameWithTarget(target, eventName), event);
      } else {
        var element = this._serializer.deserialize(message['element'], serializer_1.RenderStoreObject);
        element.events.dispatchEvent(eventName, event);
      }
    };
    WebWorkerRootRenderer.prototype.renderComponent = function(componentType) {
      var result = this._componentRenderers.get(componentType.id);
      if (lang_1.isBlank(result)) {
        result = new WebWorkerRenderer(this, componentType);
        this._componentRenderers.set(componentType.id, result);
        var id = this._renderStore.allocateId();
        this._renderStore.store(result, id);
        this.runOnService('renderComponent', [new client_message_broker_1.FnArg(componentType, core_1.RenderComponentType), new client_message_broker_1.FnArg(result, serializer_1.RenderStoreObject)]);
      }
      return result;
    };
    WebWorkerRootRenderer.prototype.runOnService = function(fnName, fnArgs) {
      var args = new client_message_broker_1.UiArguments(fnName, fnArgs);
      this._messageBroker.runOnService(args, null);
    };
    WebWorkerRootRenderer.prototype.allocateNode = function() {
      var result = new WebWorkerRenderNode();
      var id = this._renderStore.allocateId();
      this._renderStore.store(result, id);
      return result;
    };
    WebWorkerRootRenderer.prototype.allocateId = function() {
      return this._renderStore.allocateId();
    };
    WebWorkerRootRenderer.prototype.destroyNodes = function(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        this._renderStore.remove(nodes[i]);
      }
    };
    WebWorkerRootRenderer.decorators = [{type: core_1.Injectable}];
    WebWorkerRootRenderer.ctorParameters = [{type: client_message_broker_1.ClientMessageBrokerFactory}, {type: message_bus_1.MessageBus}, {type: serializer_1.Serializer}, {type: render_store_1.RenderStore}];
    return WebWorkerRootRenderer;
  }());
  exports.WebWorkerRootRenderer = WebWorkerRootRenderer;
  var WebWorkerRenderer = (function() {
    function WebWorkerRenderer(_rootRenderer, _componentType) {
      this._rootRenderer = _rootRenderer;
      this._componentType = _componentType;
    }
    WebWorkerRenderer.prototype._runOnService = function(fnName, fnArgs) {
      var fnArgsWithRenderer = [new client_message_broker_1.FnArg(this, serializer_1.RenderStoreObject)].concat(fnArgs);
      this._rootRenderer.runOnService(fnName, fnArgsWithRenderer);
    };
    WebWorkerRenderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {
      var node = this._rootRenderer.allocateNode();
      this._runOnService('selectRootElement', [new client_message_broker_1.FnArg(selectorOrNode, null), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
      return node;
    };
    WebWorkerRenderer.prototype.createElement = function(parentElement, name, debugInfo) {
      var node = this._rootRenderer.allocateNode();
      this._runOnService('createElement', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(name, null), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
      return node;
    };
    WebWorkerRenderer.prototype.createViewRoot = function(hostElement) {
      var viewRoot = this._componentType.encapsulation === core_1.ViewEncapsulation.Native ? this._rootRenderer.allocateNode() : hostElement;
      this._runOnService('createViewRoot', [new client_message_broker_1.FnArg(hostElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewRoot, serializer_1.RenderStoreObject)]);
      return viewRoot;
    };
    WebWorkerRenderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {
      var node = this._rootRenderer.allocateNode();
      this._runOnService('createTemplateAnchor', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
      return node;
    };
    WebWorkerRenderer.prototype.createText = function(parentElement, value, debugInfo) {
      var node = this._rootRenderer.allocateNode();
      this._runOnService('createText', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(value, null), new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject)]);
      return node;
    };
    WebWorkerRenderer.prototype.projectNodes = function(parentElement, nodes) {
      this._runOnService('projectNodes', [new client_message_broker_1.FnArg(parentElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(nodes, serializer_1.RenderStoreObject)]);
    };
    WebWorkerRenderer.prototype.attachViewAfter = function(node, viewRootNodes) {
      this._runOnService('attachViewAfter', [new client_message_broker_1.FnArg(node, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewRootNodes, serializer_1.RenderStoreObject)]);
    };
    WebWorkerRenderer.prototype.detachView = function(viewRootNodes) {
      this._runOnService('detachView', [new client_message_broker_1.FnArg(viewRootNodes, serializer_1.RenderStoreObject)]);
    };
    WebWorkerRenderer.prototype.destroyView = function(hostElement, viewAllNodes) {
      this._runOnService('destroyView', [new client_message_broker_1.FnArg(hostElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(viewAllNodes, serializer_1.RenderStoreObject)]);
      this._rootRenderer.destroyNodes(viewAllNodes);
    };
    WebWorkerRenderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      this._runOnService('setElementProperty', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(propertyName, null), new client_message_broker_1.FnArg(propertyValue, null)]);
    };
    WebWorkerRenderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {
      this._runOnService('setElementAttribute', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(attributeName, null), new client_message_broker_1.FnArg(attributeValue, null)]);
    };
    WebWorkerRenderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {
      this._runOnService('setBindingDebugInfo', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(propertyName, null), new client_message_broker_1.FnArg(propertyValue, null)]);
    };
    WebWorkerRenderer.prototype.setElementClass = function(renderElement, className, isAdd) {
      this._runOnService('setElementClass', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(className, null), new client_message_broker_1.FnArg(isAdd, null)]);
    };
    WebWorkerRenderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      this._runOnService('setElementStyle', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(styleName, null), new client_message_broker_1.FnArg(styleValue, null)]);
    };
    WebWorkerRenderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      this._runOnService('invokeElementMethod', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(methodName, null), new client_message_broker_1.FnArg(args, null)]);
    };
    WebWorkerRenderer.prototype.setText = function(renderNode, text) {
      this._runOnService('setText', [new client_message_broker_1.FnArg(renderNode, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(text, null)]);
    };
    WebWorkerRenderer.prototype.listen = function(renderElement, name, callback) {
      var _this = this;
      renderElement.events.listen(name, callback);
      var unlistenCallbackId = this._rootRenderer.allocateId();
      this._runOnService('listen', [new client_message_broker_1.FnArg(renderElement, serializer_1.RenderStoreObject), new client_message_broker_1.FnArg(name, null), new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
      return function() {
        renderElement.events.unlisten(name, callback);
        _this._runOnService('listenDone', [new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
      };
    };
    WebWorkerRenderer.prototype.listenGlobal = function(target, name, callback) {
      var _this = this;
      this._rootRenderer.globalEvents.listen(eventNameWithTarget(target, name), callback);
      var unlistenCallbackId = this._rootRenderer.allocateId();
      this._runOnService('listenGlobal', [new client_message_broker_1.FnArg(target, null), new client_message_broker_1.FnArg(name, null), new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
      return function() {
        _this._rootRenderer.globalEvents.unlisten(eventNameWithTarget(target, name), callback);
        _this._runOnService('listenDone', [new client_message_broker_1.FnArg(unlistenCallbackId, null)]);
      };
    };
    WebWorkerRenderer.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing) {
      return null;
    };
    return WebWorkerRenderer;
  }());
  exports.WebWorkerRenderer = WebWorkerRenderer;
  var NamedEventEmitter = (function() {
    function NamedEventEmitter() {}
    NamedEventEmitter.prototype._getListeners = function(eventName) {
      if (lang_1.isBlank(this._listeners)) {
        this._listeners = new Map();
      }
      var listeners = this._listeners.get(eventName);
      if (lang_1.isBlank(listeners)) {
        listeners = [];
        this._listeners.set(eventName, listeners);
      }
      return listeners;
    };
    NamedEventEmitter.prototype.listen = function(eventName, callback) {
      this._getListeners(eventName).push(callback);
    };
    NamedEventEmitter.prototype.unlisten = function(eventName, callback) {
      collection_1.ListWrapper.remove(this._getListeners(eventName), callback);
    };
    NamedEventEmitter.prototype.dispatchEvent = function(eventName, event) {
      var listeners = this._getListeners(eventName);
      for (var i = 0; i < listeners.length; i++) {
        listeners[i](event);
      }
    };
    return NamedEventEmitter;
  }());
  exports.NamedEventEmitter = NamedEventEmitter;
  function eventNameWithTarget(target, eventName) {
    return target + ":" + eventName;
  }
  var WebWorkerRenderNode = (function() {
    function WebWorkerRenderNode() {
      this.events = new NamedEventEmitter();
    }
    return WebWorkerRenderNode;
  }());
  exports.WebWorkerRenderNode = WebWorkerRenderNode;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/web_workers/worker/worker_adapter.js", ["../../dom/dom_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var dom_adapter_1 = $__require('../../dom/dom_adapter');
  var WorkerDomAdapter = (function(_super) {
    __extends(WorkerDomAdapter, _super);
    function WorkerDomAdapter() {
      _super.apply(this, arguments);
    }
    WorkerDomAdapter.makeCurrent = function() {
      dom_adapter_1.setRootDomAdapter(new WorkerDomAdapter());
    };
    WorkerDomAdapter.prototype.logError = function(error) {
      if (console.error) {
        console.error(error);
      } else {
        console.log(error);
      }
    };
    WorkerDomAdapter.prototype.log = function(error) {
      console.log(error);
    };
    WorkerDomAdapter.prototype.logGroup = function(error) {
      if (console.group) {
        console.group(error);
        this.logError(error);
      } else {
        console.log(error);
      }
    };
    WorkerDomAdapter.prototype.logGroupEnd = function() {
      if (console.groupEnd) {
        console.groupEnd();
      }
    };
    WorkerDomAdapter.prototype.hasProperty = function(element, name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setProperty = function(el, name, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getProperty = function(el, name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.invoke = function(el, methodName, args) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getXHR = function() {
      throw 'not implemented';
    };
    Object.defineProperty(WorkerDomAdapter.prototype, "attrToPropMap", {
      get: function() {
        throw 'not implemented';
      },
      set: function(value) {
        throw 'not implemented';
      },
      enumerable: true,
      configurable: true
    });
    WorkerDomAdapter.prototype.parse = function(templateHtml) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.query = function(selector) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.querySelector = function(el, selector) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.querySelectorAll = function(el, selector) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.on = function(el, evt, listener) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.onAndCancel = function(el, evt, listener) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.dispatchEvent = function(el, evt) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createMouseEvent = function(eventType) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createEvent = function(eventType) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.preventDefault = function(evt) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isPrevented = function(evt) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getInnerHTML = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getTemplateContent = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getOuterHTML = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.nodeName = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.nodeValue = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.type = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.content = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.firstChild = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.nextSibling = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.parentElement = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.childNodes = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.childNodesAsList = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.clearNodes = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.appendChild = function(el, node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.removeChild = function(el, node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.replaceChild = function(el, newNode, oldNode) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.remove = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.insertBefore = function(el, node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.insertAllBefore = function(el, nodes) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.insertAfter = function(el, node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setInnerHTML = function(el, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getText = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setText = function(el, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getValue = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setValue = function(el, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getChecked = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setChecked = function(el, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createComment = function(text) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createTemplate = function(html) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createElement = function(tagName, doc) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createElementNS = function(ns, tagName, doc) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createTextNode = function(text, doc) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createStyleElement = function(css, doc) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createShadowRoot = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getShadowRoot = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getHost = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getDistributedNodes = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.clone = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getElementsByClassName = function(element, name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getElementsByTagName = function(element, name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.classList = function(element) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.addClass = function(element, className) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.removeClass = function(element, className) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.hasClass = function(element, className) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setStyle = function(element, styleName, styleValue) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.removeStyle = function(element, styleName) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getStyle = function(element, styleName) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.tagName = function(element) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.attributeMap = function(element) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.hasAttribute = function(element, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getAttribute = function(element, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getAttributeNS = function(element, ns, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setAttribute = function(element, name, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.removeAttribute = function(element, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.removeAttributeNS = function(element, ns, attribute) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.templateAwareRoot = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.createHtmlDocument = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.defaultDoc = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getBoundingClientRect = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getTitle = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setTitle = function(newTitle) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.elementMatches = function(n, selector) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isTemplateElement = function(el) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isTextNode = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isCommentNode = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isElementNode = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.hasShadowRoot = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.isShadowRoot = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.importIntoDoc = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.adoptNode = function(node) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getHref = function(element) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getEventKey = function(event) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.resolveAndSetHref = function(element, baseUrl, href) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.supportsDOMEvents = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.supportsNativeShadowDOM = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getGlobalEventTarget = function(target) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getHistory = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getLocation = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getBaseHref = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.resetBaseElement = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getUserAgent = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setData = function(element, name, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getComputedStyle = function(element) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getData = function(element, name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setGlobalVar = function(name, value) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.requestAnimationFrame = function(callback) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.cancelAnimationFrame = function(id) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.performanceNow = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getAnimationPrefix = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.getTransitionEnd = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.supportsAnimation = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.supportsWebAnimation = function() {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.supportsCookies = function() {
      return false;
    };
    WorkerDomAdapter.prototype.getCookie = function(name) {
      throw 'not implemented';
    };
    WorkerDomAdapter.prototype.setCookie = function(name, value) {
      throw 'not implemented';
    };
    return WorkerDomAdapter;
  }(dom_adapter_1.DomAdapter));
  exports.WorkerDomAdapter = WorkerDomAdapter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/worker_app.js", ["@angular/common", "@angular/core", "./browser", "./facade/lang", "./web_workers/shared/api", "./web_workers/shared/client_message_broker", "./web_workers/shared/message_bus", "./web_workers/shared/post_message_bus", "./web_workers/shared/render_store", "./web_workers/shared/serializer", "./web_workers/shared/service_message_broker", "./web_workers/worker/renderer", "./web_workers/worker/worker_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var common_1 = $__require('@angular/common');
  var core_1 = $__require('@angular/core');
  var browser_1 = $__require('./browser');
  var lang_1 = $__require('./facade/lang');
  var api_1 = $__require('./web_workers/shared/api');
  var client_message_broker_1 = $__require('./web_workers/shared/client_message_broker');
  var message_bus_1 = $__require('./web_workers/shared/message_bus');
  var post_message_bus_1 = $__require('./web_workers/shared/post_message_bus');
  var render_store_1 = $__require('./web_workers/shared/render_store');
  var serializer_1 = $__require('./web_workers/shared/serializer');
  var service_message_broker_1 = $__require('./web_workers/shared/service_message_broker');
  var renderer_1 = $__require('./web_workers/worker/renderer');
  var worker_adapter_1 = $__require('./web_workers/worker/worker_adapter');
  var PrintLogger = (function() {
    function PrintLogger() {
      this.log = lang_1.print;
      this.logError = lang_1.print;
      this.logGroup = lang_1.print;
    }
    PrintLogger.prototype.logGroupEnd = function() {};
    return PrintLogger;
  }());
  exports.WORKER_APP_PLATFORM_PROVIDERS = core_1.PLATFORM_COMMON_PROVIDERS;
  exports.WORKER_APP_APPLICATION_PROVIDERS = [];
  exports.platformWorkerApp = core_1.createPlatformFactory(core_1.platformCore, 'workerApp');
  exports.workerAppPlatform = exports.platformWorkerApp;
  function _exceptionHandler() {
    return new core_1.ExceptionHandler(new PrintLogger());
  }
  var _postMessage = {postMessage: function(message, transferrables) {
      postMessage(message, transferrables);
    }};
  function createMessageBus(zone) {
    var sink = new post_message_bus_1.PostMessageBusSink(_postMessage);
    var source = new post_message_bus_1.PostMessageBusSource();
    var bus = new post_message_bus_1.PostMessageBus(sink, source);
    bus.attachToZone(zone);
    return bus;
  }
  function setupWebWorker() {
    worker_adapter_1.WorkerDomAdapter.makeCurrent();
  }
  var WorkerAppModule = (function() {
    function WorkerAppModule() {}
    WorkerAppModule.decorators = [{
      type: core_1.NgModule,
      args: [{
        providers: [common_1.FORM_PROVIDERS, browser_1.BROWSER_SANITIZATION_PROVIDERS, serializer_1.Serializer, {
          provide: client_message_broker_1.ClientMessageBrokerFactory,
          useClass: client_message_broker_1.ClientMessageBrokerFactory_
        }, {
          provide: service_message_broker_1.ServiceMessageBrokerFactory,
          useClass: service_message_broker_1.ServiceMessageBrokerFactory_
        }, renderer_1.WebWorkerRootRenderer, {
          provide: core_1.RootRenderer,
          useExisting: renderer_1.WebWorkerRootRenderer
        }, {
          provide: api_1.ON_WEB_WORKER,
          useValue: true
        }, render_store_1.RenderStore, {
          provide: core_1.ExceptionHandler,
          useFactory: _exceptionHandler,
          deps: []
        }, {
          provide: message_bus_1.MessageBus,
          useFactory: createMessageBus,
          deps: [core_1.NgZone]
        }, {
          provide: core_1.APP_INITIALIZER,
          useValue: setupWebWorker,
          multi: true
        }],
        exports: [common_1.CommonModule, core_1.ApplicationModule]
      }]
    }];
    return WorkerAppModule;
  }());
  exports.WorkerAppModule = WorkerAppModule;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/web_animations_player.js", ["@angular/core", "../facade/collection", "../facade/lang", "./dom_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var dom_adapter_1 = $__require('./dom_adapter');
  var WebAnimationsPlayer = (function() {
    function WebAnimationsPlayer(element, keyframes, options) {
      this.element = element;
      this.keyframes = keyframes;
      this.options = options;
      this._subscriptions = [];
      this._finished = false;
      this._initialized = false;
      this._started = false;
      this.parentPlayer = null;
      this._duration = options['duration'];
    }
    WebAnimationsPlayer.prototype._onFinish = function() {
      if (!this._finished) {
        this._finished = true;
        if (!lang_1.isPresent(this.parentPlayer)) {
          this.destroy();
        }
        this._subscriptions.forEach(function(fn) {
          return fn();
        });
        this._subscriptions = [];
      }
    };
    WebAnimationsPlayer.prototype.init = function() {
      var _this = this;
      if (this._initialized)
        return;
      this._initialized = true;
      var keyframes = this.keyframes.map(function(styles) {
        var formattedKeyframe = {};
        collection_1.StringMapWrapper.forEach(styles, function(value, prop) {
          formattedKeyframe[prop] = value == core_1.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;
        });
        return formattedKeyframe;
      });
      this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
      this.reset();
      this._player.onfinish = function() {
        return _this._onFinish();
      };
    };
    WebAnimationsPlayer.prototype._triggerWebAnimation = function(element, keyframes, options) {
      return element.animate(keyframes, options);
    };
    WebAnimationsPlayer.prototype.onDone = function(fn) {
      this._subscriptions.push(fn);
    };
    WebAnimationsPlayer.prototype.play = function() {
      this.init();
      this._player.play();
    };
    WebAnimationsPlayer.prototype.pause = function() {
      this.init();
      this._player.pause();
    };
    WebAnimationsPlayer.prototype.finish = function() {
      this.init();
      this._onFinish();
      this._player.finish();
    };
    WebAnimationsPlayer.prototype.reset = function() {
      this._player.cancel();
    };
    WebAnimationsPlayer.prototype.restart = function() {
      this.reset();
      this.play();
    };
    WebAnimationsPlayer.prototype.hasStarted = function() {
      return this._started;
    };
    WebAnimationsPlayer.prototype.destroy = function() {
      this.reset();
      this._onFinish();
    };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
      get: function() {
        return this._duration;
      },
      enumerable: true,
      configurable: true
    });
    WebAnimationsPlayer.prototype.setPosition = function(p) {
      this._player.currentTime = p * this.totalTime;
    };
    WebAnimationsPlayer.prototype.getPosition = function() {
      return this._player.currentTime / this.totalTime;
    };
    return WebAnimationsPlayer;
  }());
  exports.WebAnimationsPlayer = WebAnimationsPlayer;
  function _computeStyle(element, prop) {
    return dom_adapter_1.getDOM().getComputedStyle(element)[prop];
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/web_animations_driver.js", ["@angular/core", "../facade/collection", "../facade/lang", "./util", "./web_animations_player"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var util_1 = $__require('./util');
  var web_animations_player_1 = $__require('./web_animations_player');
  var WebAnimationsDriver = (function() {
    function WebAnimationsDriver() {}
    WebAnimationsDriver.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing) {
      var formattedSteps = [];
      var startingStyleLookup = {};
      if (lang_1.isPresent(startingStyles) && startingStyles.styles.length > 0) {
        startingStyleLookup = _populateStyles(element, startingStyles, {});
        startingStyleLookup['offset'] = 0;
        formattedSteps.push(startingStyleLookup);
      }
      keyframes.forEach(function(keyframe) {
        var data = _populateStyles(element, keyframe.styles, startingStyleLookup);
        data['offset'] = keyframe.offset;
        formattedSteps.push(data);
      });
      if (formattedSteps.length == 1) {
        var start = formattedSteps[0];
        start['offset'] = null;
        formattedSteps = [start, start];
      }
      var playerOptions = {
        'duration': duration,
        'delay': delay,
        'fill': 'both'
      };
      if (easing) {
        playerOptions['easing'] = easing;
      }
      return new web_animations_player_1.WebAnimationsPlayer(element, formattedSteps, playerOptions);
    };
    return WebAnimationsDriver;
  }());
  exports.WebAnimationsDriver = WebAnimationsDriver;
  function _populateStyles(element, styles, defaultStyles) {
    var data = {};
    styles.styles.forEach(function(entry) {
      collection_1.StringMapWrapper.forEach(entry, function(val, prop) {
        var formattedProp = util_1.dashCaseToCamelCase(prop);
        data[formattedProp] = val == core_1.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
      });
    });
    collection_1.StringMapWrapper.forEach(defaultStyles, function(value, prop) {
      if (!lang_1.isPresent(data[prop])) {
        data[prop] = value;
      }
    });
    return data;
  }
  function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
    var unit = '';
    if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
      if (lang_1.isNumber(val)) {
        unit = 'px';
      } else if (_findDimensionalSuffix(val.toString()).length == 0) {
        throw new core_1.BaseException('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
      }
    }
    return unit;
  }
  var _$0 = 48;
  var _$9 = 57;
  var _$PERIOD = 46;
  function _findDimensionalSuffix(value) {
    for (var i = 0; i < value.length; i++) {
      var c = lang_1.StringWrapper.charCodeAt(value, i);
      if ((c >= _$0 && c <= _$9) || c == _$PERIOD)
        continue;
      return value.substring(i, value.length);
    }
    return '';
  }
  function _isPixelDimensionStyle(prop) {
    switch (prop) {
      case 'width':
      case 'height':
      case 'minWidth':
      case 'minHeight':
      case 'maxWidth':
      case 'maxHeight':
      case 'left':
      case 'top':
      case 'bottom':
      case 'right':
      case 'fontSize':
      case 'outlineWidth':
      case 'outlineOffset':
      case 'paddingTop':
      case 'paddingLeft':
      case 'paddingBottom':
      case 'paddingRight':
      case 'marginTop':
      case 'marginLeft':
      case 'marginBottom':
      case 'marginRight':
      case 'borderRadius':
      case 'borderWidth':
      case 'borderTopWidth':
      case 'borderLeftWidth':
      case 'borderRightWidth':
      case 'borderBottomWidth':
      case 'textIndent':
        return true;
      default:
        return false;
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/generic_browser_adapter.js", ["../dom/dom_adapter", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var GenericBrowserDomAdapter = (function(_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
      var _this = this;
      _super.call(this);
      this._animationPrefix = null;
      this._transitionEnd = null;
      try {
        var element = this.createElement('div', this.defaultDoc());
        if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {
          this._animationPrefix = '';
        } else {
          var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
          for (var i = 0; i < domPrefixes.length; i++) {
            if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
              this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
              break;
            }
          }
        }
        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        collection_1.StringMapWrapper.forEach(transEndEventNames, function(value, key) {
          if (lang_1.isPresent(_this.getStyle(element, key))) {
            _this._transitionEnd = value;
          }
        });
      } catch (e) {
        this._animationPrefix = null;
        this._transitionEnd = null;
      }
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function(el) {
      return el.getDistributedNodes();
    };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function(el, baseUrl, href) {
      el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function() {
      return true;
    };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function() {
      return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function() {
      return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : '';
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function() {
      return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : '';
    };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function() {
      return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);
    };
    return GenericBrowserDomAdapter;
  }(dom_adapter_1.DomAdapter));
  exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/browser_adapter.js", ["../dom/dom_adapter", "../facade/collection", "../facade/lang", "./generic_browser_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var generic_browser_adapter_1 = $__require('./generic_browser_adapter');
  var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DOM_KEY_LOCATION_NUMPAD = 3;
  var _keyMap = {
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
  };
  var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
  };
  var BrowserDomAdapter = (function(_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
      _super.apply(this, arguments);
    }
    BrowserDomAdapter.prototype.parse = function(templateHtml) {
      throw new Error('parse not implemented');
    };
    BrowserDomAdapter.makeCurrent = function() {
      dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter());
    };
    BrowserDomAdapter.prototype.hasProperty = function(element, name) {
      return name in element;
    };
    BrowserDomAdapter.prototype.setProperty = function(el, name, value) {
      el[name] = value;
    };
    BrowserDomAdapter.prototype.getProperty = function(el, name) {
      return el[name];
    };
    BrowserDomAdapter.prototype.invoke = function(el, methodName, args) {
      el[methodName].apply(el, args);
    };
    BrowserDomAdapter.prototype.logError = function(error) {
      if (window.console.error) {
        window.console.error(error);
      } else {
        window.console.log(error);
      }
    };
    BrowserDomAdapter.prototype.log = function(error) {
      window.console.log(error);
    };
    BrowserDomAdapter.prototype.logGroup = function(error) {
      if (window.console.group) {
        window.console.group(error);
        this.logError(error);
      } else {
        window.console.log(error);
      }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function() {
      if (window.console.groupEnd) {
        window.console.groupEnd();
      }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return _attrToPropMap;
      },
      enumerable: true,
      configurable: true
    });
    BrowserDomAdapter.prototype.query = function(selector) {
      return document.querySelector(selector);
    };
    BrowserDomAdapter.prototype.querySelector = function(el, selector) {
      return el.querySelector(selector);
    };
    BrowserDomAdapter.prototype.querySelectorAll = function(el, selector) {
      return el.querySelectorAll(selector);
    };
    BrowserDomAdapter.prototype.on = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
    };
    BrowserDomAdapter.prototype.onAndCancel = function(el, evt, listener) {
      el.addEventListener(evt, listener, false);
      return function() {
        el.removeEventListener(evt, listener, false);
      };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function(el, evt) {
      el.dispatchEvent(evt);
    };
    BrowserDomAdapter.prototype.createMouseEvent = function(eventType) {
      var evt = document.createEvent('MouseEvent');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function(eventType) {
      var evt = document.createEvent('Event');
      evt.initEvent(eventType, true, true);
      return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function(evt) {
      evt.preventDefault();
      evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function(evt) {
      return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function(el) {
      return el.innerHTML;
    };
    BrowserDomAdapter.prototype.getTemplateContent = function(el) {
      return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
    };
    BrowserDomAdapter.prototype.getOuterHTML = function(el) {
      return el.outerHTML;
    };
    BrowserDomAdapter.prototype.nodeName = function(node) {
      return node.nodeName;
    };
    BrowserDomAdapter.prototype.nodeValue = function(node) {
      return node.nodeValue;
    };
    BrowserDomAdapter.prototype.type = function(node) {
      return node.type;
    };
    BrowserDomAdapter.prototype.content = function(node) {
      if (this.hasProperty(node, 'content')) {
        return node.content;
      } else {
        return node;
      }
    };
    BrowserDomAdapter.prototype.firstChild = function(el) {
      return el.firstChild;
    };
    BrowserDomAdapter.prototype.nextSibling = function(el) {
      return el.nextSibling;
    };
    BrowserDomAdapter.prototype.parentElement = function(el) {
      return el.parentNode;
    };
    BrowserDomAdapter.prototype.childNodes = function(el) {
      return el.childNodes;
    };
    BrowserDomAdapter.prototype.childNodesAsList = function(el) {
      var childNodes = el.childNodes;
      var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
      for (var i = 0; i < childNodes.length; i++) {
        res[i] = childNodes[i];
      }
      return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
    };
    BrowserDomAdapter.prototype.appendChild = function(el, node) {
      el.appendChild(node);
    };
    BrowserDomAdapter.prototype.removeChild = function(el, node) {
      el.removeChild(node);
    };
    BrowserDomAdapter.prototype.replaceChild = function(el, newChild, oldChild) {
      el.replaceChild(newChild, oldChild);
    };
    BrowserDomAdapter.prototype.remove = function(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function(el, node) {
      el.parentNode.insertBefore(node, el);
    };
    BrowserDomAdapter.prototype.insertAllBefore = function(el, nodes) {
      nodes.forEach(function(n) {
        return el.parentNode.insertBefore(n, el);
      });
    };
    BrowserDomAdapter.prototype.insertAfter = function(el, node) {
      el.parentNode.insertBefore(node, el.nextSibling);
    };
    BrowserDomAdapter.prototype.setInnerHTML = function(el, value) {
      el.innerHTML = value;
    };
    BrowserDomAdapter.prototype.getText = function(el) {
      return el.textContent;
    };
    BrowserDomAdapter.prototype.setText = function(el, value) {
      el.textContent = value;
    };
    BrowserDomAdapter.prototype.getValue = function(el) {
      return el.value;
    };
    BrowserDomAdapter.prototype.setValue = function(el, value) {
      el.value = value;
    };
    BrowserDomAdapter.prototype.getChecked = function(el) {
      return el.checked;
    };
    BrowserDomAdapter.prototype.setChecked = function(el, value) {
      el.checked = value;
    };
    BrowserDomAdapter.prototype.createComment = function(text) {
      return document.createComment(text);
    };
    BrowserDomAdapter.prototype.createTemplate = function(html) {
      var t = document.createElement('template');
      t.innerHTML = html;
      return t;
    };
    BrowserDomAdapter.prototype.createElement = function(tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createElementNS = function(ns, tagName, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createElementNS(ns, tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function(text, doc) {
      if (doc === void 0) {
        doc = document;
      }
      return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function(attrName, attrValue, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var el = doc.createElement('SCRIPT');
      el.setAttribute(attrName, attrValue);
      return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function(css, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var style = doc.createElement('style');
      this.appendChild(style, this.createTextNode(css));
      return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function(el) {
      return el.createShadowRoot();
    };
    BrowserDomAdapter.prototype.getShadowRoot = function(el) {
      return el.shadowRoot;
    };
    BrowserDomAdapter.prototype.getHost = function(el) {
      return el.host;
    };
    BrowserDomAdapter.prototype.clone = function(node) {
      return node.cloneNode(true);
    };
    BrowserDomAdapter.prototype.getElementsByClassName = function(element, name) {
      return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function(element, name) {
      return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function(element) {
      return Array.prototype.slice.call(element.classList, 0);
    };
    BrowserDomAdapter.prototype.addClass = function(element, className) {
      element.classList.add(className);
    };
    BrowserDomAdapter.prototype.removeClass = function(element, className) {
      element.classList.remove(className);
    };
    BrowserDomAdapter.prototype.hasClass = function(element, className) {
      return element.classList.contains(className);
    };
    BrowserDomAdapter.prototype.setStyle = function(element, styleName, styleValue) {
      element.style[styleName] = styleValue;
    };
    BrowserDomAdapter.prototype.removeStyle = function(element, stylename) {
      element.style[stylename] = null;
    };
    BrowserDomAdapter.prototype.getStyle = function(element, stylename) {
      return element.style[stylename];
    };
    BrowserDomAdapter.prototype.hasStyle = function(element, styleName, styleValue) {
      if (styleValue === void 0) {
        styleValue = null;
      }
      var value = this.getStyle(element, styleName) || '';
      return styleValue ? value == styleValue : value.length > 0;
    };
    BrowserDomAdapter.prototype.tagName = function(element) {
      return element.tagName;
    };
    BrowserDomAdapter.prototype.attributeMap = function(element) {
      var res = new Map();
      var elAttrs = element.attributes;
      for (var i = 0; i < elAttrs.length; i++) {
        var attrib = elAttrs[i];
        res.set(attrib.name, attrib.value);
      }
      return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function(element, attribute) {
      return element.hasAttribute(attribute);
    };
    BrowserDomAdapter.prototype.hasAttributeNS = function(element, ns, attribute) {
      return element.hasAttributeNS(ns, attribute);
    };
    BrowserDomAdapter.prototype.getAttribute = function(element, attribute) {
      return element.getAttribute(attribute);
    };
    BrowserDomAdapter.prototype.getAttributeNS = function(element, ns, name) {
      return element.getAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.setAttribute = function(element, name, value) {
      element.setAttribute(name, value);
    };
    BrowserDomAdapter.prototype.setAttributeNS = function(element, ns, name, value) {
      element.setAttributeNS(ns, name, value);
    };
    BrowserDomAdapter.prototype.removeAttribute = function(element, attribute) {
      element.removeAttribute(attribute);
    };
    BrowserDomAdapter.prototype.removeAttributeNS = function(element, ns, name) {
      element.removeAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.templateAwareRoot = function(el) {
      return this.isTemplateElement(el) ? this.content(el) : el;
    };
    BrowserDomAdapter.prototype.createHtmlDocument = function() {
      return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.defaultDoc = function() {
      return document;
    };
    BrowserDomAdapter.prototype.getBoundingClientRect = function(el) {
      try {
        return el.getBoundingClientRect();
      } catch (e) {
        return {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    };
    BrowserDomAdapter.prototype.getTitle = function() {
      return document.title;
    };
    BrowserDomAdapter.prototype.setTitle = function(newTitle) {
      document.title = newTitle || '';
    };
    BrowserDomAdapter.prototype.elementMatches = function(n, selector) {
      var matches = false;
      if (n instanceof HTMLElement) {
        if (n.matches) {
          matches = n.matches(selector);
        } else if (n.msMatchesSelector) {
          matches = n.msMatchesSelector(selector);
        } else if (n.webkitMatchesSelector) {
          matches = n.webkitMatchesSelector(selector);
        }
      }
      return matches;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function(el) {
      return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
    };
    BrowserDomAdapter.prototype.isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    BrowserDomAdapter.prototype.isCommentNode = function(node) {
      return node.nodeType === Node.COMMENT_NODE;
    };
    BrowserDomAdapter.prototype.isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    BrowserDomAdapter.prototype.hasShadowRoot = function(node) {
      return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot);
    };
    BrowserDomAdapter.prototype.isShadowRoot = function(node) {
      return node instanceof DocumentFragment;
    };
    BrowserDomAdapter.prototype.importIntoDoc = function(node) {
      var toImport = node;
      if (this.isTemplateElement(node)) {
        toImport = this.content(node);
      }
      return document.importNode(toImport, true);
    };
    BrowserDomAdapter.prototype.adoptNode = function(node) {
      return document.adoptNode(node);
    };
    BrowserDomAdapter.prototype.getHref = function(el) {
      return el.href;
    };
    BrowserDomAdapter.prototype.getEventKey = function(event) {
      var key = event.key;
      if (lang_1.isBlank(key)) {
        key = event.keyIdentifier;
        if (lang_1.isBlank(key)) {
          return 'Unidentified';
        }
        if (key.startsWith('U+')) {
          key = String.fromCharCode(parseInt(key.substring(2), 16));
          if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
            key = _chromeNumKeyPadMap[key];
          }
        }
      }
      if (_keyMap.hasOwnProperty(key)) {
        key = _keyMap[key];
      }
      return key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function(target) {
      if (target == 'window') {
        return window;
      } else if (target == 'document') {
        return document;
      } else if (target == 'body') {
        return document.body;
      }
    };
    BrowserDomAdapter.prototype.getHistory = function() {
      return window.history;
    };
    BrowserDomAdapter.prototype.getLocation = function() {
      return window.location;
    };
    BrowserDomAdapter.prototype.getBaseHref = function() {
      var href = getBaseElementHref();
      if (lang_1.isBlank(href)) {
        return null;
      }
      return relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function() {
      baseElement = null;
    };
    BrowserDomAdapter.prototype.getUserAgent = function() {
      return window.navigator.userAgent;
    };
    BrowserDomAdapter.prototype.setData = function(element, name, value) {
      this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function(element, name) {
      return this.getAttribute(element, 'data-' + name);
    };
    BrowserDomAdapter.prototype.getComputedStyle = function(element) {
      return getComputedStyle(element);
    };
    BrowserDomAdapter.prototype.setGlobalVar = function(path, value) {
      lang_1.setValueOnPath(lang_1.global, path, value);
    };
    BrowserDomAdapter.prototype.requestAnimationFrame = function(callback) {
      return window.requestAnimationFrame(callback);
    };
    BrowserDomAdapter.prototype.cancelAnimationFrame = function(id) {
      window.cancelAnimationFrame(id);
    };
    BrowserDomAdapter.prototype.supportsWebAnimation = function() {
      return lang_1.isFunction(Element.prototype['animate']);
    };
    BrowserDomAdapter.prototype.performanceNow = function() {
      if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {
        return window.performance.now();
      } else {
        return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
      }
    };
    BrowserDomAdapter.prototype.supportsCookies = function() {
      return true;
    };
    BrowserDomAdapter.prototype.getCookie = function(name) {
      return parseCookieValue(document.cookie, name);
    };
    BrowserDomAdapter.prototype.setCookie = function(name, value) {
      document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
    };
    return BrowserDomAdapter;
  }(generic_browser_adapter_1.GenericBrowserDomAdapter));
  exports.BrowserDomAdapter = BrowserDomAdapter;
  var baseElement = null;
  function getBaseElementHref() {
    if (lang_1.isBlank(baseElement)) {
      baseElement = document.querySelector('base');
      if (lang_1.isBlank(baseElement)) {
        return null;
      }
    }
    return baseElement.getAttribute('href');
  }
  var urlParsingNode = null;
  function relativePath(url) {
    if (lang_1.isBlank(urlParsingNode)) {
      urlParsingNode = document.createElement('a');
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
  }
  function parseCookieValue(cookieStr, name) {
    name = encodeURIComponent(name);
    for (var _i = 0,
        _a = cookieStr.split(';'); _i < _a.length; _i++) {
      var cookie = _a[_i];
      var eqIndex = cookie.indexOf('=');
      var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)],
          cookieName = _b[0],
          cookieValue = _b[1];
      if (cookieName.trim() === name) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  }
  exports.parseCookieValue = parseCookieValue;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/common_directives.js", ["./directives"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var directives_1 = $__require('./directives');
  exports.COMMON_DIRECTIVES = [directives_1.CORE_DIRECTIVES];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/async_pipe.js", ["@angular/core", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var ObservableStrategy = (function() {
    function ObservableStrategy() {}
    ObservableStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return async.subscribe({
        next: updateLatestValue,
        error: function(e) {
          throw e;
        }
      });
    };
    ObservableStrategy.prototype.dispose = function(subscription) {
      subscription.unsubscribe();
    };
    ObservableStrategy.prototype.onDestroy = function(subscription) {
      subscription.unsubscribe();
    };
    return ObservableStrategy;
  }());
  var PromiseStrategy = (function() {
    function PromiseStrategy() {}
    PromiseStrategy.prototype.createSubscription = function(async, updateLatestValue) {
      return async.then(updateLatestValue, function(e) {
        throw e;
      });
    };
    PromiseStrategy.prototype.dispose = function(subscription) {};
    PromiseStrategy.prototype.onDestroy = function(subscription) {};
    return PromiseStrategy;
  }());
  var _promiseStrategy = new PromiseStrategy();
  var _observableStrategy = new ObservableStrategy();
  var __unused;
  var AsyncPipe = (function() {
    function AsyncPipe(_ref) {
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
      this._strategy = null;
      this._ref = _ref;
    }
    AsyncPipe.prototype.ngOnDestroy = function() {
      if (lang_1.isPresent(this._subscription)) {
        this._dispose();
      }
    };
    AsyncPipe.prototype.transform = function(obj) {
      if (lang_1.isBlank(this._obj)) {
        if (lang_1.isPresent(obj)) {
          this._subscribe(obj);
        }
        this._latestReturnedValue = this._latestValue;
        return this._latestValue;
      }
      if (obj !== this._obj) {
        this._dispose();
        return this.transform(obj);
      }
      if (this._latestValue === this._latestReturnedValue) {
        return this._latestReturnedValue;
      } else {
        this._latestReturnedValue = this._latestValue;
        return core_1.WrappedValue.wrap(this._latestValue);
      }
    };
    AsyncPipe.prototype._subscribe = function(obj) {
      var _this = this;
      this._obj = obj;
      this._strategy = this._selectStrategy(obj);
      this._subscription = this._strategy.createSubscription(obj, function(value) {
        return _this._updateLatestValue(obj, value);
      });
    };
    AsyncPipe.prototype._selectStrategy = function(obj) {
      if (lang_1.isPromise(obj)) {
        return _promiseStrategy;
      } else if (obj.subscribe) {
        return _observableStrategy;
      } else {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
      }
    };
    AsyncPipe.prototype._dispose = function() {
      this._strategy.dispose(this._subscription);
      this._latestValue = null;
      this._latestReturnedValue = null;
      this._subscription = null;
      this._obj = null;
    };
    AsyncPipe.prototype._updateLatestValue = function(async, value) {
      if (async === this._obj) {
        this._latestValue = value;
        this._ref.markForCheck();
      }
    };
    AsyncPipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'async',
        pure: false
      }]
    }];
    AsyncPipe.ctorParameters = [{type: core_1.ChangeDetectorRef}];
    return AsyncPipe;
  }());
  exports.AsyncPipe = AsyncPipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/common_pipes.js", ["./async_pipe", "./date_pipe", "./i18n_plural_pipe", "./i18n_select_pipe", "./json_pipe", "./lowercase_pipe", "./number_pipe", "./replace_pipe", "./slice_pipe", "./uppercase_pipe"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var async_pipe_1 = $__require('./async_pipe');
  var date_pipe_1 = $__require('./date_pipe');
  var i18n_plural_pipe_1 = $__require('./i18n_plural_pipe');
  var i18n_select_pipe_1 = $__require('./i18n_select_pipe');
  var json_pipe_1 = $__require('./json_pipe');
  var lowercase_pipe_1 = $__require('./lowercase_pipe');
  var number_pipe_1 = $__require('./number_pipe');
  var replace_pipe_1 = $__require('./replace_pipe');
  var slice_pipe_1 = $__require('./slice_pipe');
  var uppercase_pipe_1 = $__require('./uppercase_pipe');
  exports.COMMON_PIPES = [async_pipe_1.AsyncPipe, uppercase_pipe_1.UpperCasePipe, lowercase_pipe_1.LowerCasePipe, json_pipe_1.JsonPipe, slice_pipe_1.SlicePipe, number_pipe_1.DecimalPipe, number_pipe_1.PercentPipe, number_pipe_1.CurrencyPipe, date_pipe_1.DatePipe, replace_pipe_1.ReplacePipe, i18n_plural_pipe_1.I18nPluralPipe, i18n_select_pipe_1.I18nSelectPipe];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/date_pipe.js", ["@angular/core", "../facade/collection", "../facade/intl", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var intl_1 = $__require('../facade/intl');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var defaultLocale = 'en-US';
  var DatePipe = (function() {
    function DatePipe() {}
    DatePipe.prototype.transform = function(value, pattern) {
      if (pattern === void 0) {
        pattern = 'mediumDate';
      }
      if (lang_1.isBlank(value))
        return null;
      if (!this.supports(value)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
      }
      if (lang_1.NumberWrapper.isNumeric(value)) {
        value = lang_1.DateWrapper.fromMillis(lang_1.NumberWrapper.parseInt(value, 10));
      } else if (lang_1.isString(value)) {
        value = lang_1.DateWrapper.fromISOString(value);
      }
      if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
        pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
      }
      return intl_1.DateFormatter.format(value, defaultLocale, pattern);
    };
    DatePipe.prototype.supports = function(obj) {
      if (lang_1.isDate(obj) || lang_1.NumberWrapper.isNumeric(obj)) {
        return true;
      }
      if (lang_1.isString(obj) && lang_1.isDate(lang_1.DateWrapper.fromISOString(obj))) {
        return true;
      }
      return false;
    };
    DatePipe._ALIASES = {
      'medium': 'yMMMdjms',
      'short': 'yMdjm',
      'fullDate': 'yMMMMEEEEd',
      'longDate': 'yMMMMd',
      'mediumDate': 'yMMMd',
      'shortDate': 'yMd',
      'mediumTime': 'jms',
      'shortTime': 'jm'
    };
    DatePipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'date',
        pure: true
      }]
    }];
    return DatePipe;
  }());
  exports.DatePipe = DatePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/i18n_plural_pipe.js", ["@angular/core", "../facade/lang", "../localization", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var localization_1 = $__require('../localization');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var _INTERPOLATION_REGEXP = /#/g;
  var I18nPluralPipe = (function() {
    function I18nPluralPipe(_localization) {
      this._localization = _localization;
    }
    I18nPluralPipe.prototype.transform = function(value, pluralMap) {
      if (lang_1.isBlank(value))
        return '';
      if (!lang_1.isStringMap(pluralMap)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nPluralPipe, pluralMap);
      }
      var key = localization_1.getPluralCategory(value, Object.keys(pluralMap), this._localization);
      return lang_1.StringWrapper.replaceAll(pluralMap[key], _INTERPOLATION_REGEXP, value.toString());
    };
    I18nPluralPipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'i18nPlural',
        pure: true
      }]
    }];
    I18nPluralPipe.ctorParameters = [{type: localization_1.NgLocalization}];
    return I18nPluralPipe;
  }());
  exports.I18nPluralPipe = I18nPluralPipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/i18n_select_pipe.js", ["@angular/core", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var I18nSelectPipe = (function() {
    function I18nSelectPipe() {}
    I18nSelectPipe.prototype.transform = function(value, mapping) {
      if (lang_1.isBlank(value))
        return '';
      if (!lang_1.isStringMap(mapping)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nSelectPipe, mapping);
      }
      return mapping.hasOwnProperty(value) ? mapping[value] : '';
    };
    I18nSelectPipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'i18nSelect',
        pure: true
      }]
    }];
    return I18nSelectPipe;
  }());
  exports.I18nSelectPipe = I18nSelectPipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/json_pipe.js", ["@angular/core", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var JsonPipe = (function() {
    function JsonPipe() {}
    JsonPipe.prototype.transform = function(value) {
      return lang_1.Json.stringify(value);
    };
    JsonPipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'json',
        pure: false
      }]
    }];
    return JsonPipe;
  }());
  exports.JsonPipe = JsonPipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/lowercase_pipe.js", ["@angular/core", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var LowerCasePipe = (function() {
    function LowerCasePipe() {}
    LowerCasePipe.prototype.transform = function(value) {
      if (lang_1.isBlank(value))
        return value;
      if (!lang_1.isString(value)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
      }
      return value.toLowerCase();
    };
    LowerCasePipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'lowercase'}]
    }];
    return LowerCasePipe;
  }());
  exports.LowerCasePipe = LowerCasePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/intl.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(NumberFormatStyle) {
    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
  })(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
  var NumberFormatStyle = exports.NumberFormatStyle;
  var NumberFormatter = (function() {
    function NumberFormatter() {}
    NumberFormatter.format = function(num, locale, style, _a) {
      var _b = _a === void 0 ? {} : _a,
          minimumIntegerDigits = _b.minimumIntegerDigits,
          minimumFractionDigits = _b.minimumFractionDigits,
          maximumFractionDigits = _b.maximumFractionDigits,
          currency = _b.currency,
          _c = _b.currencyAsSymbol,
          currencyAsSymbol = _c === void 0 ? false : _c;
      var options = {
        minimumIntegerDigits: minimumIntegerDigits,
        minimumFractionDigits: minimumFractionDigits,
        maximumFractionDigits: maximumFractionDigits,
        style: NumberFormatStyle[style].toLowerCase()
      };
      if (style == NumberFormatStyle.Currency) {
        options.currency = currency;
        options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
      }
      return new Intl.NumberFormat(locale, options).format(num);
    };
    return NumberFormatter;
  }());
  exports.NumberFormatter = NumberFormatter;
  var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
  var PATTERN_ALIASES = {
    yMMMdjms: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1), digitCondition('second', 1)])),
    yMdjm: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1)])),
    yMMMMEEEEd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4), digitCondition('day', 1)])),
    yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
    yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
    yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
    jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
    jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
  };
  var DATE_FORMATS = {
    yyyy: datePartGetterFactory(digitCondition('year', 4)),
    yy: datePartGetterFactory(digitCondition('year', 2)),
    y: datePartGetterFactory(digitCondition('year', 1)),
    MMMM: datePartGetterFactory(nameCondition('month', 4)),
    MMM: datePartGetterFactory(nameCondition('month', 3)),
    MM: datePartGetterFactory(digitCondition('month', 2)),
    M: datePartGetterFactory(digitCondition('month', 1)),
    LLLL: datePartGetterFactory(nameCondition('month', 4)),
    dd: datePartGetterFactory(digitCondition('day', 2)),
    d: datePartGetterFactory(digitCondition('day', 1)),
    HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
    H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
    hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
    h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    jj: datePartGetterFactory(digitCondition('hour', 2)),
    j: datePartGetterFactory(digitCondition('hour', 1)),
    mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
    m: datePartGetterFactory(digitCondition('minute', 1)),
    ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
    s: datePartGetterFactory(digitCondition('second', 1)),
    sss: datePartGetterFactory(digitCondition('second', 3)),
    EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
    EEE: datePartGetterFactory(nameCondition('weekday', 3)),
    EE: datePartGetterFactory(nameCondition('weekday', 2)),
    E: datePartGetterFactory(nameCondition('weekday', 1)),
    a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
    Z: timeZoneGetter('short'),
    z: timeZoneGetter('long'),
    ww: datePartGetterFactory({}),
    w: datePartGetterFactory({}),
    G: datePartGetterFactory(nameCondition('era', 1)),
    GG: datePartGetterFactory(nameCondition('era', 2)),
    GGG: datePartGetterFactory(nameCondition('era', 3)),
    GGGG: datePartGetterFactory(nameCondition('era', 4))
  };
  function digitModifier(inner) {
    return function(date, locale) {
      var result = inner(date, locale);
      return result.length == 1 ? '0' + result : result;
    };
  }
  function hourClockExtracter(inner) {
    return function(date, locale) {
      var result = inner(date, locale);
      return result.split(' ')[1];
    };
  }
  function hourExtracter(inner) {
    return function(date, locale) {
      var result = inner(date, locale);
      return result.split(' ')[0];
    };
  }
  function timeZoneGetter(timezone) {
    var format = {
      hour: '2-digit',
      hour12: false,
      timeZoneName: timezone
    };
    return function(date, locale) {
      var result = new Intl.DateTimeFormat(locale, format).format(date);
      return result ? result.substring(3) : '';
    };
  }
  function hour12Modify(options, value) {
    options.hour12 = value;
    return options;
  }
  function digitCondition(prop, len) {
    var result = {};
    result[prop] = len == 2 ? '2-digit' : 'numeric';
    return result;
  }
  function nameCondition(prop, len) {
    var result = {};
    result[prop] = len < 4 ? 'short' : 'long';
    return result;
  }
  function combine(options) {
    var result = {};
    options.forEach(function(option) {
      Object.assign(result, option);
    });
    return result;
  }
  function datePartGetterFactory(ret) {
    return function(date, locale) {
      return new Intl.DateTimeFormat(locale, ret).format(date);
    };
  }
  var datePartsFormatterCache = new Map();
  function dateFormatter(format, date, locale) {
    var text = '';
    var match;
    var fn;
    var parts = [];
    if (PATTERN_ALIASES[format]) {
      return PATTERN_ALIASES[format](date, locale);
    }
    if (datePartsFormatterCache.has(format)) {
      parts = datePartsFormatterCache.get(format);
    } else {
      var matches = DATE_FORMATS_SPLIT.exec(format);
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      datePartsFormatterCache.set(format, parts);
    }
    parts.forEach(function(part) {
      fn = DATE_FORMATS[part];
      text += fn ? fn(date, locale) : part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
    });
    return text;
  }
  var slice = [].slice;
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  var DateFormatter = (function() {
    function DateFormatter() {}
    DateFormatter.format = function(date, locale, pattern) {
      return dateFormatter(pattern, date, locale);
    };
    return DateFormatter;
  }());
  exports.DateFormatter = DateFormatter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/number_pipe.js", ["@angular/core", "../facade/intl", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var intl_1 = $__require('../facade/intl');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var defaultLocale = 'en-US';
  var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/;
  function formatNumber(pipe, value, style, digits, currency, currencyAsSymbol) {
    if (currency === void 0) {
      currency = null;
    }
    if (currencyAsSymbol === void 0) {
      currencyAsSymbol = false;
    }
    if (lang_1.isBlank(value))
      return null;
    value = lang_1.isString(value) && lang_1.NumberWrapper.isNumeric(value) ? +value : value;
    if (!lang_1.isNumber(value)) {
      throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(pipe, value);
    }
    var minInt;
    var minFraction;
    var maxFraction;
    if (style !== intl_1.NumberFormatStyle.Currency) {
      minInt = 1;
      minFraction = 0;
      maxFraction = 3;
    }
    if (lang_1.isPresent(digits)) {
      var parts = digits.match(_NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(digits + " is not a valid digit info for number pipes");
      }
      if (lang_1.isPresent(parts[1])) {
        minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
      }
      if (lang_1.isPresent(parts[3])) {
        minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
      }
      if (lang_1.isPresent(parts[5])) {
        maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
      }
    }
    return intl_1.NumberFormatter.format(value, defaultLocale, style, {
      minimumIntegerDigits: minInt,
      minimumFractionDigits: minFraction,
      maximumFractionDigits: maxFraction,
      currency: currency,
      currencyAsSymbol: currencyAsSymbol
    });
  }
  var DecimalPipe = (function() {
    function DecimalPipe() {}
    DecimalPipe.prototype.transform = function(value, digits) {
      if (digits === void 0) {
        digits = null;
      }
      return formatNumber(DecimalPipe, value, intl_1.NumberFormatStyle.Decimal, digits);
    };
    DecimalPipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'number'}]
    }];
    return DecimalPipe;
  }());
  exports.DecimalPipe = DecimalPipe;
  var PercentPipe = (function() {
    function PercentPipe() {}
    PercentPipe.prototype.transform = function(value, digits) {
      if (digits === void 0) {
        digits = null;
      }
      return formatNumber(PercentPipe, value, intl_1.NumberFormatStyle.Percent, digits);
    };
    PercentPipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'percent'}]
    }];
    return PercentPipe;
  }());
  exports.PercentPipe = PercentPipe;
  var CurrencyPipe = (function() {
    function CurrencyPipe() {}
    CurrencyPipe.prototype.transform = function(value, currencyCode, symbolDisplay, digits) {
      if (currencyCode === void 0) {
        currencyCode = 'USD';
      }
      if (symbolDisplay === void 0) {
        symbolDisplay = false;
      }
      if (digits === void 0) {
        digits = null;
      }
      return formatNumber(CurrencyPipe, value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    CurrencyPipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'currency'}]
    }];
    return CurrencyPipe;
  }());
  exports.CurrencyPipe = CurrencyPipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/replace_pipe.js", ["@angular/core", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var ReplacePipe = (function() {
    function ReplacePipe() {}
    ReplacePipe.prototype.transform = function(value, pattern, replacement) {
      if (lang_1.isBlank(value)) {
        return value;
      }
      if (!this._supportedInput(value)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, value);
      }
      var input = value.toString();
      if (!this._supportedPattern(pattern)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, pattern);
      }
      if (!this._supportedReplacement(replacement)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, replacement);
      }
      if (lang_1.isFunction(replacement)) {
        var rgxPattern = lang_1.isString(pattern) ? new RegExp(pattern, 'g') : pattern;
        return lang_1.StringWrapper.replaceAllMapped(input, rgxPattern, replacement);
      }
      if (pattern instanceof RegExp) {
        return lang_1.StringWrapper.replaceAll(input, pattern, replacement);
      }
      return lang_1.StringWrapper.replace(input, pattern, replacement);
    };
    ReplacePipe.prototype._supportedInput = function(input) {
      return lang_1.isString(input) || lang_1.isNumber(input);
    };
    ReplacePipe.prototype._supportedPattern = function(pattern) {
      return lang_1.isString(pattern) || pattern instanceof RegExp;
    };
    ReplacePipe.prototype._supportedReplacement = function(replacement) {
      return lang_1.isString(replacement) || lang_1.isFunction(replacement);
    };
    ReplacePipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'replace'}]
    }];
    return ReplacePipe;
  }());
  exports.ReplacePipe = ReplacePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/slice_pipe.js", ["@angular/core", "../facade/collection", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var SlicePipe = (function() {
    function SlicePipe() {}
    SlicePipe.prototype.transform = function(value, start, end) {
      if (end === void 0) {
        end = null;
      }
      if (lang_1.isBlank(value))
        return value;
      if (!this.supports(value)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);
      }
      if (lang_1.isString(value)) {
        return lang_1.StringWrapper.slice(value, start, end);
      }
      return collection_1.ListWrapper.slice(value, start, end);
    };
    SlicePipe.prototype.supports = function(obj) {
      return lang_1.isString(obj) || lang_1.isArray(obj);
    };
    SlicePipe.decorators = [{
      type: core_1.Pipe,
      args: [{
        name: 'slice',
        pure: false
      }]
    }];
    return SlicePipe;
  }());
  exports.SlicePipe = SlicePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/invalid_pipe_argument_exception.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var InvalidPipeArgumentException = (function(_super) {
    __extends(InvalidPipeArgumentException, _super);
    function InvalidPipeArgumentException(type, value) {
      _super.call(this, "Invalid argument '" + value + "' for pipe '" + lang_1.stringify(type) + "'");
    }
    return InvalidPipeArgumentException;
  }(exceptions_1.BaseException));
  exports.InvalidPipeArgumentException = InvalidPipeArgumentException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes/uppercase_pipe.js", ["@angular/core", "../facade/lang", "./invalid_pipe_argument_exception"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var invalid_pipe_argument_exception_1 = $__require('./invalid_pipe_argument_exception');
  var UpperCasePipe = (function() {
    function UpperCasePipe() {}
    UpperCasePipe.prototype.transform = function(value) {
      if (lang_1.isBlank(value))
        return value;
      if (!lang_1.isString(value)) {
        throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
      }
      return value.toUpperCase();
    };
    UpperCasePipe.decorators = [{
      type: core_1.Pipe,
      args: [{name: 'uppercase'}]
    }];
    return UpperCasePipe;
  }());
  exports.UpperCasePipe = UpperCasePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/pipes.js", ["./pipes/async_pipe", "./pipes/common_pipes", "./pipes/date_pipe", "./pipes/i18n_plural_pipe", "./pipes/i18n_select_pipe", "./pipes/json_pipe", "./pipes/lowercase_pipe", "./pipes/number_pipe", "./pipes/replace_pipe", "./pipes/slice_pipe", "./pipes/uppercase_pipe"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var async_pipe_1 = $__require('./pipes/async_pipe');
  exports.AsyncPipe = async_pipe_1.AsyncPipe;
  var common_pipes_1 = $__require('./pipes/common_pipes');
  exports.COMMON_PIPES = common_pipes_1.COMMON_PIPES;
  var date_pipe_1 = $__require('./pipes/date_pipe');
  exports.DatePipe = date_pipe_1.DatePipe;
  var i18n_plural_pipe_1 = $__require('./pipes/i18n_plural_pipe');
  exports.I18nPluralPipe = i18n_plural_pipe_1.I18nPluralPipe;
  var i18n_select_pipe_1 = $__require('./pipes/i18n_select_pipe');
  exports.I18nSelectPipe = i18n_select_pipe_1.I18nSelectPipe;
  var json_pipe_1 = $__require('./pipes/json_pipe');
  exports.JsonPipe = json_pipe_1.JsonPipe;
  var lowercase_pipe_1 = $__require('./pipes/lowercase_pipe');
  exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
  var number_pipe_1 = $__require('./pipes/number_pipe');
  exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
  exports.DecimalPipe = number_pipe_1.DecimalPipe;
  exports.PercentPipe = number_pipe_1.PercentPipe;
  var replace_pipe_1 = $__require('./pipes/replace_pipe');
  exports.ReplacePipe = replace_pipe_1.ReplacePipe;
  var slice_pipe_1 = $__require('./pipes/slice_pipe');
  exports.SlicePipe = slice_pipe_1.SlicePipe;
  var uppercase_pipe_1 = $__require('./pipes/uppercase_pipe');
  exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/core_directives.js", ["./ng_class", "./ng_for", "./ng_if", "./ng_plural", "./ng_style", "./ng_switch", "./ng_template_outlet"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ng_class_1 = $__require('./ng_class');
  var ng_for_1 = $__require('./ng_for');
  var ng_if_1 = $__require('./ng_if');
  var ng_plural_1 = $__require('./ng_plural');
  var ng_style_1 = $__require('./ng_style');
  var ng_switch_1 = $__require('./ng_switch');
  var ng_template_outlet_1 = $__require('./ng_template_outlet');
  exports.CORE_DIRECTIVES = [ng_class_1.NgClass, ng_for_1.NgFor, ng_if_1.NgIf, ng_template_outlet_1.NgTemplateOutlet, ng_style_1.NgStyle, ng_switch_1.NgSwitch, ng_switch_1.NgSwitchCase, ng_switch_1.NgSwitchDefault, ng_plural_1.NgPlural, ng_plural_1.NgPluralCase];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_class.js", ["@angular/core", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var NgClass = (function() {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
      this._iterableDiffers = _iterableDiffers;
      this._keyValueDiffers = _keyValueDiffers;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
      this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "initialClasses", {
      set: function(v) {
        this._applyInitialClasses(true);
        this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
        this._applyInitialClasses(false);
        this._applyClasses(this._rawClass, false);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgClass.prototype, "ngClass", {
      set: function(v) {
        this._cleanupClasses(this._rawClass);
        if (lang_1.isString(v)) {
          v = v.split(' ');
        }
        this._rawClass = v;
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        if (lang_1.isPresent(v)) {
          if (collection_1.isListLikeIterable(v)) {
            this._iterableDiffer = this._iterableDiffers.find(v).create(null);
          } else {
            this._keyValueDiffer = this._keyValueDiffers.find(v).create(null);
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    NgClass.prototype.ngDoCheck = function() {
      if (lang_1.isPresent(this._iterableDiffer)) {
        var changes = this._iterableDiffer.diff(this._rawClass);
        if (lang_1.isPresent(changes)) {
          this._applyIterableChanges(changes);
        }
      }
      if (lang_1.isPresent(this._keyValueDiffer)) {
        var changes = this._keyValueDiffer.diff(this._rawClass);
        if (lang_1.isPresent(changes)) {
          this._applyKeyValueChanges(changes);
        }
      }
    };
    NgClass.prototype._cleanupClasses = function(rawClassVal) {
      this._applyClasses(rawClassVal, true);
      this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        _this._toggleClass(record.key, record.currentValue);
      });
      changes.forEachRemovedItem(function(record) {
        if (record.previousValue) {
          _this._toggleClass(record.key, false);
        }
      });
    };
    NgClass.prototype._applyIterableChanges = function(changes) {
      var _this = this;
      changes.forEachAddedItem(function(record) {
        _this._toggleClass(record.item, true);
      });
      changes.forEachRemovedItem(function(record) {
        _this._toggleClass(record.item, false);
      });
    };
    NgClass.prototype._applyInitialClasses = function(isCleanup) {
      var _this = this;
      this._initialClasses.forEach(function(className) {
        return _this._toggleClass(className, !isCleanup);
      });
    };
    NgClass.prototype._applyClasses = function(rawClassVal, isCleanup) {
      var _this = this;
      if (lang_1.isPresent(rawClassVal)) {
        if (lang_1.isArray(rawClassVal)) {
          rawClassVal.forEach(function(className) {
            return _this._toggleClass(className, !isCleanup);
          });
        } else if (rawClassVal instanceof Set) {
          rawClassVal.forEach(function(className) {
            return _this._toggleClass(className, !isCleanup);
          });
        } else {
          collection_1.StringMapWrapper.forEach(rawClassVal, function(expVal, className) {
            if (lang_1.isPresent(expVal))
              _this._toggleClass(className, !isCleanup);
          });
        }
      }
    };
    NgClass.prototype._toggleClass = function(className, enabled) {
      className = className.trim();
      if (className.length > 0) {
        if (className.indexOf(' ') > -1) {
          var classes = className.split(/\s+/g);
          for (var i = 0,
              len = classes.length; i < len; i++) {
            this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
          }
        } else {
          this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
        }
      }
    };
    NgClass.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngClass]'}]
    }];
    NgClass.ctorParameters = [{type: core_1.IterableDiffers}, {type: core_1.KeyValueDiffers}, {type: core_1.ElementRef}, {type: core_1.Renderer}];
    NgClass.propDecorators = {
      'initialClasses': [{
        type: core_1.Input,
        args: ['class']
      }],
      'ngClass': [{type: core_1.Input}]
    };
    return NgClass;
  }());
  exports.NgClass = NgClass;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_for.js", ["@angular/core", "../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var NgForRow = (function() {
    function NgForRow($implicit, index, count) {
      this.$implicit = $implicit;
      this.index = index;
      this.count = count;
    }
    Object.defineProperty(NgForRow.prototype, "first", {
      get: function() {
        return this.index === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "last", {
      get: function() {
        return this.index === this.count - 1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "even", {
      get: function() {
        return this.index % 2 === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "odd", {
      get: function() {
        return !this.even;
      },
      enumerable: true,
      configurable: true
    });
    return NgForRow;
  }());
  exports.NgForRow = NgForRow;
  var NgFor = (function() {
    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
      this._viewContainer = _viewContainer;
      this._templateRef = _templateRef;
      this._iterableDiffers = _iterableDiffers;
      this._cdr = _cdr;
    }
    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
      set: function(value) {
        if (lang_1.isPresent(value)) {
          this._templateRef = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    NgFor.prototype.ngOnChanges = function(changes) {
      if ('ngForOf' in changes) {
        var value = changes['ngForOf'].currentValue;
        if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
          try {
            this._differ = this._iterableDiffers.find(value).create(this._cdr, this.ngForTrackBy);
          } catch (e) {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + value + "' of type '" + lang_1.getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
          }
        }
      }
    };
    NgFor.prototype.ngDoCheck = function() {
      if (lang_1.isPresent(this._differ)) {
        var changes = this._differ.diff(this.ngForOf);
        if (lang_1.isPresent(changes))
          this._applyChanges(changes);
      }
    };
    NgFor.prototype._applyChanges = function(changes) {
      var _this = this;
      var insertTuples = [];
      changes.forEachOperation(function(item, adjustedPreviousIndex, currentIndex) {
        if (item.previousIndex == null) {
          var view = _this._viewContainer.createEmbeddedView(_this._templateRef, new NgForRow(null, null, null), currentIndex);
          var tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        } else if (currentIndex == null) {
          _this._viewContainer.remove(adjustedPreviousIndex);
        } else {
          var view = _this._viewContainer.get(adjustedPreviousIndex);
          _this._viewContainer.move(view, currentIndex);
          var tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        }
      });
      for (var i = 0; i < insertTuples.length; i++) {
        this._perViewChange(insertTuples[i].view, insertTuples[i].record);
      }
      for (var i = 0,
          ilen = this._viewContainer.length; i < ilen; i++) {
        var viewRef = this._viewContainer.get(i);
        viewRef.context.index = i;
        viewRef.context.count = ilen;
      }
      changes.forEachIdentityChange(function(record) {
        var viewRef = _this._viewContainer.get(record.currentIndex);
        viewRef.context.$implicit = record.item;
      });
    };
    NgFor.prototype._perViewChange = function(view, record) {
      view.context.$implicit = record.item;
    };
    NgFor.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngFor][ngForOf]'}]
    }];
    NgFor.ctorParameters = [{type: core_1.ViewContainerRef}, {type: core_1.TemplateRef}, {type: core_1.IterableDiffers}, {type: core_1.ChangeDetectorRef}];
    NgFor.propDecorators = {
      'ngForOf': [{type: core_1.Input}],
      'ngForTrackBy': [{type: core_1.Input}],
      'ngForTemplate': [{type: core_1.Input}]
    };
    return NgFor;
  }());
  exports.NgFor = NgFor;
  var RecordViewTuple = (function() {
    function RecordViewTuple(record, view) {
      this.record = record;
      this.view = view;
    }
    return RecordViewTuple;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_if.js", ["@angular/core", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var NgIf = (function() {
    function NgIf(_viewContainer, _templateRef) {
      this._viewContainer = _viewContainer;
      this._templateRef = _templateRef;
      this._prevCondition = null;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
      set: function(newCondition) {
        if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
          this._prevCondition = true;
          this._viewContainer.createEmbeddedView(this._templateRef);
        } else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
          this._prevCondition = false;
          this._viewContainer.clear();
        }
      },
      enumerable: true,
      configurable: true
    });
    NgIf.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngIf]'}]
    }];
    NgIf.ctorParameters = [{type: core_1.ViewContainerRef}, {type: core_1.TemplateRef}];
    NgIf.propDecorators = {'ngIf': [{type: core_1.Input}]};
    return NgIf;
  }());
  exports.NgIf = NgIf;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_plural.js", ["@angular/core", "../facade/lang", "../localization", "./ng_switch"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var localization_1 = $__require('../localization');
  var ng_switch_1 = $__require('./ng_switch');
  var NgPlural = (function() {
    function NgPlural(_localization) {
      this._localization = _localization;
      this._caseViews = {};
    }
    Object.defineProperty(NgPlural.prototype, "ngPlural", {
      set: function(value) {
        this._switchValue = value;
        this._updateView();
      },
      enumerable: true,
      configurable: true
    });
    NgPlural.prototype.addCase = function(value, switchView) {
      this._caseViews[value] = switchView;
    };
    NgPlural.prototype._updateView = function() {
      this._clearViews();
      var key = localization_1.getPluralCategory(this._switchValue, Object.keys(this._caseViews), this._localization);
      this._activateView(this._caseViews[key]);
    };
    NgPlural.prototype._clearViews = function() {
      if (lang_1.isPresent(this._activeView))
        this._activeView.destroy();
    };
    NgPlural.prototype._activateView = function(view) {
      if (!lang_1.isPresent(view))
        return;
      this._activeView = view;
      this._activeView.create();
    };
    NgPlural.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngPlural]'}]
    }];
    NgPlural.ctorParameters = [{type: localization_1.NgLocalization}];
    NgPlural.propDecorators = {'ngPlural': [{type: core_1.Input}]};
    return NgPlural;
  }());
  exports.NgPlural = NgPlural;
  var NgPluralCase = (function() {
    function NgPluralCase(value, template, viewContainer, ngPlural) {
      this.value = value;
      ngPlural.addCase(value, new ng_switch_1.SwitchView(viewContainer, template));
    }
    NgPluralCase.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngPluralCase]'}]
    }];
    NgPluralCase.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Attribute,
        args: ['ngPluralCase']
      }]
    }, {type: core_1.TemplateRef}, {type: core_1.ViewContainerRef}, {
      type: NgPlural,
      decorators: [{type: core_1.Host}]
    }];
    return NgPluralCase;
  }());
  exports.NgPluralCase = NgPluralCase;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_style.js", ["@angular/core", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var NgStyle = (function() {
    function NgStyle(_differs, _ngEl, _renderer) {
      this._differs = _differs;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "ngStyle", {
      set: function(v) {
        this._ngStyle = v;
        if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
          this._differ = this._differs.find(this._ngStyle).create(null);
        }
      },
      enumerable: true,
      configurable: true
    });
    NgStyle.prototype.ngDoCheck = function() {
      if (lang_1.isPresent(this._differ)) {
        var changes = this._differ.diff(this._ngStyle);
        if (lang_1.isPresent(changes)) {
          this._applyChanges(changes);
        }
      }
    };
    NgStyle.prototype._applyChanges = function(changes) {
      var _this = this;
      changes.forEachRemovedItem(function(record) {
        _this._setStyle(record.key, null);
      });
      changes.forEachAddedItem(function(record) {
        _this._setStyle(record.key, record.currentValue);
      });
      changes.forEachChangedItem(function(record) {
        _this._setStyle(record.key, record.currentValue);
      });
    };
    NgStyle.prototype._setStyle = function(name, val) {
      var nameParts = name.split('.');
      var nameToSet = nameParts[0];
      var valToSet = lang_1.isPresent(val) && nameParts.length === 2 ? "" + val + nameParts[1] : val;
      this._renderer.setElementStyle(this._ngEl.nativeElement, nameToSet, valToSet);
    };
    NgStyle.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngStyle]'}]
    }];
    NgStyle.ctorParameters = [{type: core_1.KeyValueDiffers}, {type: core_1.ElementRef}, {type: core_1.Renderer}];
    NgStyle.propDecorators = {'ngStyle': [{type: core_1.Input}]};
    return NgStyle;
  }());
  exports.NgStyle = NgStyle;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_switch.js", ["@angular/core", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var _CASE_DEFAULT = new Object();
  var _warned = false;
  var SwitchView = (function() {
    function SwitchView(_viewContainerRef, _templateRef) {
      this._viewContainerRef = _viewContainerRef;
      this._templateRef = _templateRef;
    }
    SwitchView.prototype.create = function() {
      this._viewContainerRef.createEmbeddedView(this._templateRef);
    };
    SwitchView.prototype.destroy = function() {
      this._viewContainerRef.clear();
    };
    return SwitchView;
  }());
  exports.SwitchView = SwitchView;
  var NgSwitch = (function() {
    function NgSwitch() {
      this._useDefault = false;
      this._valueViews = new Map();
      this._activeViews = [];
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
      set: function(value) {
        this._emptyAllActiveViews();
        this._useDefault = false;
        var views = this._valueViews.get(value);
        if (lang_1.isBlank(views)) {
          this._useDefault = true;
          views = lang_1.normalizeBlank(this._valueViews.get(_CASE_DEFAULT));
        }
        this._activateViews(views);
        this._switchValue = value;
      },
      enumerable: true,
      configurable: true
    });
    NgSwitch.prototype._onCaseValueChanged = function(oldCase, newCase, view) {
      this._deregisterView(oldCase, view);
      this._registerView(newCase, view);
      if (oldCase === this._switchValue) {
        view.destroy();
        collection_1.ListWrapper.remove(this._activeViews, view);
      } else if (newCase === this._switchValue) {
        if (this._useDefault) {
          this._useDefault = false;
          this._emptyAllActiveViews();
        }
        view.create();
        this._activeViews.push(view);
      }
      if (this._activeViews.length === 0 && !this._useDefault) {
        this._useDefault = true;
        this._activateViews(this._valueViews.get(_CASE_DEFAULT));
      }
    };
    NgSwitch.prototype._emptyAllActiveViews = function() {
      var activeContainers = this._activeViews;
      for (var i = 0; i < activeContainers.length; i++) {
        activeContainers[i].destroy();
      }
      this._activeViews = [];
    };
    NgSwitch.prototype._activateViews = function(views) {
      if (lang_1.isPresent(views)) {
        for (var i = 0; i < views.length; i++) {
          views[i].create();
        }
        this._activeViews = views;
      }
    };
    NgSwitch.prototype._registerView = function(value, view) {
      var views = this._valueViews.get(value);
      if (lang_1.isBlank(views)) {
        views = [];
        this._valueViews.set(value, views);
      }
      views.push(view);
    };
    NgSwitch.prototype._deregisterView = function(value, view) {
      if (value === _CASE_DEFAULT)
        return;
      var views = this._valueViews.get(value);
      if (views.length == 1) {
        this._valueViews.delete(value);
      } else {
        collection_1.ListWrapper.remove(views, view);
      }
    };
    NgSwitch.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngSwitch]'}]
    }];
    NgSwitch.propDecorators = {'ngSwitch': [{type: core_1.Input}]};
    return NgSwitch;
  }());
  exports.NgSwitch = NgSwitch;
  var NgSwitchCase = (function() {
    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
      this._value = _CASE_DEFAULT;
      this._switch = ngSwitch;
      this._view = new SwitchView(viewContainer, templateRef);
    }
    Object.defineProperty(NgSwitchCase.prototype, "ngSwitchCase", {
      set: function(value) {
        this._switch._onCaseValueChanged(this._value, value, this._view);
        this._value = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgSwitchCase.prototype, "ngSwitchWhen", {
      set: function(value) {
        if (!_warned) {
          _warned = true;
          console.warn('*ngSwitchWhen is deprecated and will be removed. Use *ngSwitchCase instead');
        }
        this._switch._onCaseValueChanged(this._value, value, this._view);
        this._value = value;
      },
      enumerable: true,
      configurable: true
    });
    NgSwitchCase.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngSwitchCase],[ngSwitchWhen]'}]
    }];
    NgSwitchCase.ctorParameters = [{type: core_1.ViewContainerRef}, {type: core_1.TemplateRef}, {
      type: NgSwitch,
      decorators: [{type: core_1.Host}]
    }];
    NgSwitchCase.propDecorators = {
      'ngSwitchCase': [{type: core_1.Input}],
      'ngSwitchWhen': [{type: core_1.Input}]
    };
    return NgSwitchCase;
  }());
  exports.NgSwitchCase = NgSwitchCase;
  var NgSwitchDefault = (function() {
    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
      sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
    }
    NgSwitchDefault.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngSwitchDefault]'}]
    }];
    NgSwitchDefault.ctorParameters = [{type: core_1.ViewContainerRef}, {type: core_1.TemplateRef}, {
      type: NgSwitch,
      decorators: [{type: core_1.Host}]
    }];
    return NgSwitchDefault;
  }());
  exports.NgSwitchDefault = NgSwitchDefault;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives/ng_template_outlet.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var NgTemplateOutlet = (function() {
    function NgTemplateOutlet(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
    }
    Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
      set: function(context) {
        this._context = context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
      set: function(templateRef) {
        this._templateRef = templateRef;
      },
      enumerable: true,
      configurable: true
    });
    NgTemplateOutlet.prototype.ngOnChanges = function() {
      if (this._viewRef) {
        this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
      }
      if (this._templateRef) {
        this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
      }
    };
    NgTemplateOutlet.decorators = [{
      type: core_1.Directive,
      args: [{selector: '[ngTemplateOutlet]'}]
    }];
    NgTemplateOutlet.ctorParameters = [{type: core_1.ViewContainerRef}];
    NgTemplateOutlet.propDecorators = {
      'ngOutletContext': [{type: core_1.Input}],
      'ngTemplateOutlet': [{type: core_1.Input}]
    };
    return NgTemplateOutlet;
  }());
  exports.NgTemplateOutlet = NgTemplateOutlet;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/directives.js", ["./directives/core_directives", "./directives/ng_class", "./directives/ng_for", "./directives/ng_if", "./directives/ng_plural", "./directives/ng_style", "./directives/ng_switch", "./directives/ng_template_outlet"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_directives_1 = $__require('./directives/core_directives');
  exports.CORE_DIRECTIVES = core_directives_1.CORE_DIRECTIVES;
  var ng_class_1 = $__require('./directives/ng_class');
  exports.NgClass = ng_class_1.NgClass;
  var ng_for_1 = $__require('./directives/ng_for');
  exports.NgFor = ng_for_1.NgFor;
  var ng_if_1 = $__require('./directives/ng_if');
  exports.NgIf = ng_if_1.NgIf;
  var ng_plural_1 = $__require('./directives/ng_plural');
  exports.NgPlural = ng_plural_1.NgPlural;
  exports.NgPluralCase = ng_plural_1.NgPluralCase;
  var ng_style_1 = $__require('./directives/ng_style');
  exports.NgStyle = ng_style_1.NgStyle;
  var ng_switch_1 = $__require('./directives/ng_switch');
  exports.NgSwitch = ng_switch_1.NgSwitch;
  exports.NgSwitchCase = ng_switch_1.NgSwitchCase;
  exports.NgSwitchDefault = ng_switch_1.NgSwitchDefault;
  var ng_template_outlet_1 = $__require('./directives/ng_template_outlet');
  exports.NgTemplateOutlet = ng_template_outlet_1.NgTemplateOutlet;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives.js", ["./directives/checkbox_value_accessor", "./directives/default_value_accessor", "./directives/ng_control_group", "./directives/ng_control_name", "./directives/ng_control_status", "./directives/ng_form", "./directives/ng_form_control", "./directives/ng_form_model", "./directives/ng_model", "./directives/number_value_accessor", "./directives/radio_control_value_accessor", "./directives/select_control_value_accessor", "./directives/select_multiple_control_value_accessor", "./directives/validators", "./directives/ng_control"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var checkbox_value_accessor_1 = $__require('./directives/checkbox_value_accessor');
  var default_value_accessor_1 = $__require('./directives/default_value_accessor');
  var ng_control_group_1 = $__require('./directives/ng_control_group');
  var ng_control_name_1 = $__require('./directives/ng_control_name');
  var ng_control_status_1 = $__require('./directives/ng_control_status');
  var ng_form_1 = $__require('./directives/ng_form');
  var ng_form_control_1 = $__require('./directives/ng_form_control');
  var ng_form_model_1 = $__require('./directives/ng_form_model');
  var ng_model_1 = $__require('./directives/ng_model');
  var number_value_accessor_1 = $__require('./directives/number_value_accessor');
  var radio_control_value_accessor_1 = $__require('./directives/radio_control_value_accessor');
  var select_control_value_accessor_1 = $__require('./directives/select_control_value_accessor');
  var select_multiple_control_value_accessor_1 = $__require('./directives/select_multiple_control_value_accessor');
  var validators_1 = $__require('./directives/validators');
  var checkbox_value_accessor_2 = $__require('./directives/checkbox_value_accessor');
  exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
  var default_value_accessor_2 = $__require('./directives/default_value_accessor');
  exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
  var ng_control_1 = $__require('./directives/ng_control');
  exports.NgControl = ng_control_1.NgControl;
  var ng_control_group_2 = $__require('./directives/ng_control_group');
  exports.NgControlGroup = ng_control_group_2.NgControlGroup;
  var ng_control_name_2 = $__require('./directives/ng_control_name');
  exports.NgControlName = ng_control_name_2.NgControlName;
  var ng_control_status_2 = $__require('./directives/ng_control_status');
  exports.NgControlStatus = ng_control_status_2.NgControlStatus;
  var ng_form_2 = $__require('./directives/ng_form');
  exports.NgForm = ng_form_2.NgForm;
  var ng_form_control_2 = $__require('./directives/ng_form_control');
  exports.NgFormControl = ng_form_control_2.NgFormControl;
  var ng_form_model_2 = $__require('./directives/ng_form_model');
  exports.NgFormModel = ng_form_model_2.NgFormModel;
  var ng_model_2 = $__require('./directives/ng_model');
  exports.NgModel = ng_model_2.NgModel;
  var number_value_accessor_2 = $__require('./directives/number_value_accessor');
  exports.NumberValueAccessor = number_value_accessor_2.NumberValueAccessor;
  var radio_control_value_accessor_2 = $__require('./directives/radio_control_value_accessor');
  exports.RadioButtonState = radio_control_value_accessor_2.RadioButtonState;
  exports.RadioControlValueAccessor = radio_control_value_accessor_2.RadioControlValueAccessor;
  var select_control_value_accessor_2 = $__require('./directives/select_control_value_accessor');
  exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
  exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
  var select_multiple_control_value_accessor_2 = $__require('./directives/select_multiple_control_value_accessor');
  exports.NgSelectMultipleOption = select_multiple_control_value_accessor_2.NgSelectMultipleOption;
  exports.SelectMultipleControlValueAccessor = select_multiple_control_value_accessor_2.SelectMultipleControlValueAccessor;
  var validators_2 = $__require('./directives/validators');
  exports.MaxLengthValidator = validators_2.MaxLengthValidator;
  exports.MinLengthValidator = validators_2.MinLengthValidator;
  exports.PatternValidator = validators_2.PatternValidator;
  exports.RequiredValidator = validators_2.RequiredValidator;
  exports.FORM_DIRECTIVES = [ng_control_name_1.NgControlName, ng_control_group_1.NgControlGroup, ng_form_control_1.NgFormControl, ng_model_1.NgModel, ng_form_model_1.NgFormModel, ng_form_1.NgForm, select_control_value_accessor_1.NgSelectOption, select_multiple_control_value_accessor_1.NgSelectMultipleOption, default_value_accessor_1.DefaultValueAccessor, number_value_accessor_1.NumberValueAccessor, checkbox_value_accessor_1.CheckboxControlValueAccessor, select_control_value_accessor_1.SelectControlValueAccessor, select_multiple_control_value_accessor_1.SelectMultipleControlValueAccessor, radio_control_value_accessor_1.RadioControlValueAccessor, ng_control_status_1.NgControlStatus, validators_1.RequiredValidator, validators_1.MinLengthValidator, validators_1.MaxLengthValidator, validators_1.PatternValidator];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/form_builder.js", ["@angular/core", "../facade/collection", "../facade/lang", "./model"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var model_1 = $__require('./model');
  var FormBuilder = (function() {
    function FormBuilder() {}
    FormBuilder.prototype.group = function(controlsConfig, extra) {
      if (extra === void 0) {
        extra = null;
      }
      var controls = this._reduceControls(controlsConfig);
      var optionals = (lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'optionals') : null);
      var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'validator') : null;
      var asyncValidator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, 'asyncValidator') : null;
      return new model_1.ControlGroup(controls, optionals, validator, asyncValidator);
    };
    FormBuilder.prototype.control = function(value, validator, asyncValidator) {
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      return new model_1.Control(value, validator, asyncValidator);
    };
    FormBuilder.prototype.array = function(controlsConfig, validator, asyncValidator) {
      var _this = this;
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      var controls = controlsConfig.map(function(c) {
        return _this._createControl(c);
      });
      return new model_1.ControlArray(controls, validator, asyncValidator);
    };
    FormBuilder.prototype._reduceControls = function(controlsConfig) {
      var _this = this;
      var controls = {};
      collection_1.StringMapWrapper.forEach(controlsConfig, function(controlConfig, controlName) {
        controls[controlName] = _this._createControl(controlConfig);
      });
      return controls;
    };
    FormBuilder.prototype._createControl = function(controlConfig) {
      if (controlConfig instanceof model_1.Control || controlConfig instanceof model_1.ControlGroup || controlConfig instanceof model_1.ControlArray) {
        return controlConfig;
      } else if (lang_1.isArray(controlConfig)) {
        var value = controlConfig[0];
        var validator = controlConfig.length > 1 ? controlConfig[1] : null;
        var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
        return this.control(value, validator, asyncValidator);
      } else {
        return this.control(controlConfig);
      }
    };
    FormBuilder.decorators = [{type: core_1.Injectable}];
    return FormBuilder;
  }());
  exports.FormBuilder = FormBuilder;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_control_group.js", ["@angular/core", "../validators", "./control_container", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var validators_1 = $__require('../validators');
  var control_container_1 = $__require('./control_container');
  var shared_1 = $__require('./shared');
  exports.controlGroupProvider = {
    provide: control_container_1.ControlContainer,
    useExisting: core_1.forwardRef(function() {
      return NgControlGroup;
    })
  };
  var NgControlGroup = (function(_super) {
    __extends(NgControlGroup, _super);
    function NgControlGroup(parent, _validators, _asyncValidators) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this._parent = parent;
    }
    NgControlGroup.prototype.ngOnInit = function() {
      this.formDirective.addControlGroup(this);
    };
    NgControlGroup.prototype.ngOnDestroy = function() {
      this.formDirective.removeControlGroup(this);
    };
    Object.defineProperty(NgControlGroup.prototype, "control", {
      get: function() {
        return this.formDirective.getControlGroup(this);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "path", {
      get: function() {
        return shared_1.controlPath(this.name, this._parent);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
      get: function() {
        return this._parent.formDirective;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "validator", {
      get: function() {
        return shared_1.composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "asyncValidator", {
      get: function() {
        return shared_1.composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    NgControlGroup.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngControlGroup]',
        providers: [exports.controlGroupProvider],
        inputs: ['name: ngControlGroup'],
        exportAs: 'ngForm'
      }]
    }];
    NgControlGroup.ctorParameters = [{
      type: control_container_1.ControlContainer,
      decorators: [{type: core_1.Host}, {type: core_1.SkipSelf}]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }];
    return NgControlGroup;
  }(control_container_1.ControlContainer));
  exports.NgControlGroup = NgControlGroup;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_control_name.js", ["@angular/core", "../../facade/async", "../validators", "./control_container", "./control_value_accessor", "./ng_control", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var validators_1 = $__require('../validators');
  var control_container_1 = $__require('./control_container');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  var ng_control_1 = $__require('./ng_control');
  var shared_1 = $__require('./shared');
  exports.controlNameBinding = {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function() {
      return NgControlName;
    })
  };
  var NgControlName = (function(_super) {
    __extends(NgControlName, _super);
    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._parent = _parent;
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this.update = new async_1.EventEmitter();
      this._added = false;
      this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgControlName.prototype.ngOnChanges = function(changes) {
      if (!this._added) {
        this.formDirective.addControl(this);
        this._added = true;
      }
      if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
        this.viewModel = this.model;
        this.formDirective.updateModel(this, this.model);
      }
    };
    NgControlName.prototype.ngOnDestroy = function() {
      this.formDirective.removeControl(this);
    };
    NgControlName.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    };
    Object.defineProperty(NgControlName.prototype, "path", {
      get: function() {
        return shared_1.controlPath(this.name, this._parent);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "formDirective", {
      get: function() {
        return this._parent.formDirective;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "validator", {
      get: function() {
        return shared_1.composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "asyncValidator", {
      get: function() {
        return shared_1.composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "control", {
      get: function() {
        return this.formDirective.getControl(this);
      },
      enumerable: true,
      configurable: true
    });
    NgControlName.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngControl]',
        providers: [exports.controlNameBinding],
        inputs: ['name: ngControl', 'model: ngModel'],
        outputs: ['update: ngModelChange'],
        exportAs: 'ngForm'
      }]
    }];
    NgControlName.ctorParameters = [{
      type: control_container_1.ControlContainer,
      decorators: [{type: core_1.Host}, {type: core_1.SkipSelf}]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [control_value_accessor_1.NG_VALUE_ACCESSOR]
      }]
    }];
    return NgControlName;
  }(ng_control_1.NgControl));
  exports.NgControlName = NgControlName;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_control_status.js", ["@angular/core", "../../facade/lang", "./ng_control"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../../facade/lang');
  var ng_control_1 = $__require('./ng_control');
  var NgControlStatus = (function() {
    function NgControlStatus(cd) {
      this._cd = cd;
    }
    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
      get: function() {
        return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
      },
      enumerable: true,
      configurable: true
    });
    NgControlStatus.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngControl],[ngModel],[ngFormControl]',
        host: {
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }]
    }];
    NgControlStatus.ctorParameters = [{
      type: ng_control_1.NgControl,
      decorators: [{type: core_1.Self}]
    }];
    return NgControlStatus;
  }());
  exports.NgControlStatus = NgControlStatus;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_form.js", ["@angular/core", "../../facade/async", "../../facade/collection", "../../facade/lang", "../model", "../validators", "./control_container", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var model_1 = $__require('../model');
  var validators_1 = $__require('../validators');
  var control_container_1 = $__require('./control_container');
  var shared_1 = $__require('./shared');
  exports.formDirectiveProvider = {
    provide: control_container_1.ControlContainer,
    useExisting: core_1.forwardRef(function() {
      return NgForm;
    })
  };
  var _formWarningDisplayed = false;
  var resolvedPromise = Promise.resolve(null);
  var NgForm = (function(_super) {
    __extends(NgForm, _super);
    function NgForm(validators, asyncValidators) {
      _super.call(this);
      this._submitted = false;
      this.ngSubmit = new async_1.EventEmitter();
      this._displayWarning();
      this.form = new model_1.ControlGroup({}, null, shared_1.composeValidators(validators), shared_1.composeAsyncValidators(asyncValidators));
    }
    NgForm.prototype._displayWarning = function() {
      if (!_formWarningDisplayed) {
        _formWarningDisplayed = true;
        console.warn("\n      *It looks like you're using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/preview\n    ");
      }
    };
    Object.defineProperty(NgForm.prototype, "submitted", {
      get: function() {
        return this._submitted;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "formDirective", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
      get: function() {
        return this.form.controls;
      },
      enumerable: true,
      configurable: true
    });
    NgForm.prototype.addControl = function(dir) {
      var _this = this;
      resolvedPromise.then(function() {
        var container = _this._findContainer(dir.path);
        var ctrl = new model_1.Control();
        shared_1.setUpControl(ctrl, dir);
        container.registerControl(dir.name, ctrl);
        ctrl.updateValueAndValidity({emitEvent: false});
      });
    };
    NgForm.prototype.getControl = function(dir) {
      return this.form.find(dir.path);
    };
    NgForm.prototype.removeControl = function(dir) {
      var _this = this;
      resolvedPromise.then(function() {
        var container = _this._findContainer(dir.path);
        if (lang_1.isPresent(container)) {
          container.removeControl(dir.name);
        }
      });
    };
    NgForm.prototype.addControlGroup = function(dir) {
      var _this = this;
      resolvedPromise.then(function() {
        var container = _this._findContainer(dir.path);
        var group = new model_1.ControlGroup({});
        shared_1.setUpControlGroup(group, dir);
        container.registerControl(dir.name, group);
        group.updateValueAndValidity({emitEvent: false});
      });
    };
    NgForm.prototype.removeControlGroup = function(dir) {
      var _this = this;
      resolvedPromise.then(function() {
        var container = _this._findContainer(dir.path);
        if (lang_1.isPresent(container)) {
          container.removeControl(dir.name);
        }
      });
    };
    NgForm.prototype.getControlGroup = function(dir) {
      return this.form.find(dir.path);
    };
    NgForm.prototype.updateModel = function(dir, value) {
      var _this = this;
      resolvedPromise.then(function() {
        var ctrl = _this.form.find(dir.path);
        ctrl.updateValue(value);
      });
    };
    NgForm.prototype.onSubmit = function() {
      this._submitted = true;
      this.ngSubmit.emit(null);
      return false;
    };
    NgForm.prototype._findContainer = function(path) {
      path.pop();
      return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
    };
    NgForm.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',
        providers: [exports.formDirectiveProvider],
        host: {'(submit)': 'onSubmit()'},
        outputs: ['ngSubmit'],
        exportAs: 'ngForm'
      }]
    }];
    NgForm.ctorParameters = [{
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }];
    return NgForm;
  }(control_container_1.ControlContainer));
  exports.NgForm = NgForm;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_form_control.js", ["@angular/core", "../../facade/async", "../../facade/collection", "../validators", "./control_value_accessor", "./ng_control", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var collection_1 = $__require('../../facade/collection');
  var validators_1 = $__require('../validators');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  var ng_control_1 = $__require('./ng_control');
  var shared_1 = $__require('./shared');
  exports.formControlBinding = {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function() {
      return NgFormControl;
    })
  };
  var NgFormControl = (function(_super) {
    __extends(NgFormControl, _super);
    function NgFormControl(_validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this.update = new async_1.EventEmitter();
      this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgFormControl.prototype.ngOnChanges = function(changes) {
      if (this._isControlChanged(changes)) {
        shared_1.setUpControl(this.form, this);
        this.form.updateValueAndValidity({emitEvent: false});
      }
      if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
        this.form.updateValue(this.model);
        this.viewModel = this.model;
      }
    };
    Object.defineProperty(NgFormControl.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "validator", {
      get: function() {
        return shared_1.composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "asyncValidator", {
      get: function() {
        return shared_1.composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    NgFormControl.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    };
    NgFormControl.prototype._isControlChanged = function(changes) {
      return collection_1.StringMapWrapper.contains(changes, 'form');
    };
    NgFormControl.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngFormControl]',
        providers: [exports.formControlBinding],
        inputs: ['form: ngFormControl', 'model: ngModel'],
        outputs: ['update: ngModelChange'],
        exportAs: 'ngForm'
      }]
    }];
    NgFormControl.ctorParameters = [{
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [control_value_accessor_1.NG_VALUE_ACCESSOR]
      }]
    }];
    return NgFormControl;
  }(ng_control_1.NgControl));
  exports.NgFormControl = NgFormControl;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/control_container.js", ["./abstract_control_directive"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var abstract_control_directive_1 = $__require('./abstract_control_directive');
  var ControlContainer = (function(_super) {
    __extends(ControlContainer, _super);
    function ControlContainer() {
      _super.apply(this, arguments);
    }
    Object.defineProperty(ControlContainer.prototype, "formDirective", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ControlContainer.prototype, "path", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return ControlContainer;
  }(abstract_control_directive_1.AbstractControlDirective));
  exports.ControlContainer = ControlContainer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_form_model.js", ["@angular/core", "../../facade/async", "../../facade/collection", "../../facade/exceptions", "../../facade/lang", "../validators", "./control_container", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var validators_1 = $__require('../validators');
  var control_container_1 = $__require('./control_container');
  var shared_1 = $__require('./shared');
  exports.formDirectiveProvider = {
    provide: control_container_1.ControlContainer,
    useExisting: core_1.forwardRef(function() {
      return NgFormModel;
    })
  };
  var _formModelWarningDisplayed = false;
  var NgFormModel = (function(_super) {
    __extends(NgFormModel, _super);
    function NgFormModel(_validators, _asyncValidators) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this._submitted = false;
      this.form = null;
      this.directives = [];
      this.ngSubmit = new async_1.EventEmitter();
      this._displayWarning();
    }
    NgFormModel.prototype._displayWarning = function() {
      if (!_formModelWarningDisplayed) {
        _formModelWarningDisplayed = true;
        console.warn("\n      *It looks like you're using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/preview\n    ");
      }
    };
    NgFormModel.prototype.ngOnChanges = function(changes) {
      this._checkFormPresent();
      if (collection_1.StringMapWrapper.contains(changes, 'form')) {
        var sync = shared_1.composeValidators(this._validators);
        this.form.validator = validators_1.Validators.compose([this.form.validator, sync]);
        var async = shared_1.composeAsyncValidators(this._asyncValidators);
        this.form.asyncValidator = validators_1.Validators.composeAsync([this.form.asyncValidator, async]);
        this.form.updateValueAndValidity({
          onlySelf: true,
          emitEvent: false
        });
      }
      this._updateDomValue();
    };
    Object.defineProperty(NgFormModel.prototype, "submitted", {
      get: function() {
        return this._submitted;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "formDirective", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "control", {
      get: function() {
        return this.form;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    NgFormModel.prototype.addControl = function(dir) {
      var ctrl = this.form.find(dir.path);
      shared_1.setUpControl(ctrl, dir);
      ctrl.updateValueAndValidity({emitEvent: false});
      this.directives.push(dir);
    };
    NgFormModel.prototype.getControl = function(dir) {
      return this.form.find(dir.path);
    };
    NgFormModel.prototype.removeControl = function(dir) {
      collection_1.ListWrapper.remove(this.directives, dir);
    };
    NgFormModel.prototype.addControlGroup = function(dir) {
      var ctrl = this.form.find(dir.path);
      shared_1.setUpControlGroup(ctrl, dir);
      ctrl.updateValueAndValidity({emitEvent: false});
    };
    NgFormModel.prototype.removeControlGroup = function(dir) {};
    NgFormModel.prototype.getControlGroup = function(dir) {
      return this.form.find(dir.path);
    };
    NgFormModel.prototype.updateModel = function(dir, value) {
      var ctrl = this.form.find(dir.path);
      ctrl.updateValue(value);
    };
    NgFormModel.prototype.onSubmit = function() {
      this._submitted = true;
      this.ngSubmit.emit(null);
      return false;
    };
    NgFormModel.prototype._updateDomValue = function() {
      var _this = this;
      this.directives.forEach(function(dir) {
        var ctrl = _this.form.find(dir.path);
        dir.valueAccessor.writeValue(ctrl.value);
      });
    };
    NgFormModel.prototype._checkFormPresent = function() {
      if (lang_1.isBlank(this.form)) {
        throw new exceptions_1.BaseException("ngFormModel expects a form. Please pass one in. Example: <form [ngFormModel]=\"myCoolForm\">");
      }
    };
    NgFormModel.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngFormModel]',
        providers: [exports.formDirectiveProvider],
        inputs: ['form: ngFormModel'],
        host: {'(submit)': 'onSubmit()'},
        outputs: ['ngSubmit'],
        exportAs: 'ngForm'
      }]
    }];
    NgFormModel.ctorParameters = [{
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }];
    return NgFormModel;
  }(control_container_1.ControlContainer));
  exports.NgFormModel = NgFormModel;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/checkbox_value_accessor.js", ["@angular/core", "./control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  exports.CHECKBOX_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return CheckboxControlValueAccessor;
    }),
    multi: true
  };
  var CheckboxControlValueAccessor = (function() {
    function CheckboxControlValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    CheckboxControlValueAccessor.prototype.writeValue = function(value) {
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
    };
    CheckboxControlValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = fn;
    };
    CheckboxControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    CheckboxControlValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',
        host: {
          '(change)': 'onChange($event.target.checked)',
          '(blur)': 'onTouched()'
        },
        providers: [exports.CHECKBOX_VALUE_ACCESSOR]
      }]
    }];
    CheckboxControlValueAccessor.ctorParameters = [{type: core_1.Renderer}, {type: core_1.ElementRef}];
    return CheckboxControlValueAccessor;
  }());
  exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/default_value_accessor.js", ["@angular/core", "../../facade/lang", "./control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../../facade/lang');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  exports.DEFAULT_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return DefaultValueAccessor;
    }),
    multi: true
  };
  var DefaultValueAccessor = (function() {
    function DefaultValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    DefaultValueAccessor.prototype.writeValue = function(value) {
      var normalizedValue = lang_1.isBlank(value) ? '' : value;
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DefaultValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = fn;
    };
    DefaultValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    DefaultValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
        host: {
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()'
        },
        providers: [exports.DEFAULT_VALUE_ACCESSOR]
      }]
    }];
    DefaultValueAccessor.ctorParameters = [{type: core_1.Renderer}, {type: core_1.ElementRef}];
    return DefaultValueAccessor;
  }());
  exports.DefaultValueAccessor = DefaultValueAccessor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/normalize_validator.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function normalizeValidator(validator) {
    if (validator.validate !== undefined) {
      return function(c) {
        return validator.validate(c);
      };
    } else {
      return validator;
    }
  }
  exports.normalizeValidator = normalizeValidator;
  function normalizeAsyncValidator(validator) {
    if (validator.validate !== undefined) {
      return function(c) {
        return validator.validate(c);
      };
    } else {
      return validator;
    }
  }
  exports.normalizeAsyncValidator = normalizeAsyncValidator;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/number_value_accessor.js", ["@angular/core", "../../facade/lang", "./control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../../facade/lang');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  exports.NUMBER_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return NumberValueAccessor;
    }),
    multi: true
  };
  var NumberValueAccessor = (function() {
    function NumberValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    NumberValueAccessor.prototype.writeValue = function(value) {
      var normalizedValue = lang_1.isBlank(value) ? '' : value;
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    NumberValueAccessor.prototype.registerOnChange = function(fn) {
      this.onChange = function(value) {
        fn(value == '' ? null : lang_1.NumberWrapper.parseFloat(value));
      };
    };
    NumberValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    NumberValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()'
        },
        providers: [exports.NUMBER_VALUE_ACCESSOR]
      }]
    }];
    NumberValueAccessor.ctorParameters = [{type: core_1.Renderer}, {type: core_1.ElementRef}];
    return NumberValueAccessor;
  }());
  exports.NumberValueAccessor = NumberValueAccessor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/abstract_control_directive.js", ["../../facade/exceptions", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var AbstractControlDirective = (function() {
    function AbstractControlDirective() {}
    Object.defineProperty(AbstractControlDirective.prototype, "control", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "value", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.value : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.valid : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.errors : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.pristine : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.dirty : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.touched : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
      get: function() {
        return lang_1.isPresent(this.control) ? this.control.untouched : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "path", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return AbstractControlDirective;
  }());
  exports.AbstractControlDirective = AbstractControlDirective;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_control.js", ["../../facade/exceptions", "./abstract_control_directive"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../../facade/exceptions');
  var abstract_control_directive_1 = $__require('./abstract_control_directive');
  var NgControl = (function(_super) {
    __extends(NgControl, _super);
    function NgControl() {
      _super.apply(this, arguments);
      this.name = null;
      this.valueAccessor = null;
    }
    Object.defineProperty(NgControl.prototype, "validator", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgControl.prototype, "asyncValidator", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return NgControl;
  }(abstract_control_directive_1.AbstractControlDirective));
  exports.NgControl = NgControl;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/radio_control_value_accessor.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "./control_value_accessor", "./ng_control"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  var ng_control_1 = $__require('./ng_control');
  exports.RADIO_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return RadioControlValueAccessor;
    }),
    multi: true
  };
  var RadioControlRegistry = (function() {
    function RadioControlRegistry() {
      this._accessors = [];
    }
    RadioControlRegistry.prototype.add = function(control, accessor) {
      this._accessors.push([control, accessor]);
    };
    RadioControlRegistry.prototype.remove = function(accessor) {
      var indexToRemove = -1;
      for (var i = 0; i < this._accessors.length; ++i) {
        if (this._accessors[i][1] === accessor) {
          indexToRemove = i;
        }
      }
      collection_1.ListWrapper.removeAt(this._accessors, indexToRemove);
    };
    RadioControlRegistry.prototype.select = function(accessor) {
      var _this = this;
      this._accessors.forEach(function(c) {
        if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
          c[1].fireUncheck();
        }
      });
    };
    RadioControlRegistry.prototype._isSameGroup = function(controlPair, accessor) {
      return controlPair[0].control.root === accessor._control.control.root && controlPair[1].name === accessor.name;
    };
    RadioControlRegistry.decorators = [{type: core_1.Injectable}];
    return RadioControlRegistry;
  }());
  exports.RadioControlRegistry = RadioControlRegistry;
  var RadioButtonState = (function() {
    function RadioButtonState(checked, value) {
      this.checked = checked;
      this.value = value;
    }
    return RadioButtonState;
  }());
  exports.RadioButtonState = RadioButtonState;
  var RadioControlValueAccessor = (function() {
    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this._registry = _registry;
      this._injector = _injector;
      this.onChange = function() {};
      this.onTouched = function() {};
    }
    RadioControlValueAccessor.prototype.ngOnInit = function() {
      this._control = this._injector.get(ng_control_1.NgControl);
      this._registry.add(this._control, this);
    };
    RadioControlValueAccessor.prototype.ngOnDestroy = function() {
      this._registry.remove(this);
    };
    RadioControlValueAccessor.prototype.writeValue = function(value) {
      this._state = value;
      if (lang_1.isPresent(value) && value.checked) {
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', true);
      }
    };
    RadioControlValueAccessor.prototype.registerOnChange = function(fn) {
      var _this = this;
      this._fn = fn;
      this.onChange = function() {
        fn(new RadioButtonState(true, _this._state.value));
        _this._registry.select(_this);
      };
    };
    RadioControlValueAccessor.prototype.fireUncheck = function() {
      this._fn(new RadioButtonState(false, this._state.value));
    };
    RadioControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    RadioControlValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'input[type=radio][ngControl],input[type=radio][ngFormControl],input[type=radio][ngModel]',
        host: {
          '(change)': 'onChange()',
          '(blur)': 'onTouched()'
        },
        providers: [exports.RADIO_VALUE_ACCESSOR]
      }]
    }];
    RadioControlValueAccessor.ctorParameters = [{type: core_1.Renderer}, {type: core_1.ElementRef}, {type: RadioControlRegistry}, {type: core_1.Injector}];
    RadioControlValueAccessor.propDecorators = {'name': [{type: core_1.Input}]};
    return RadioControlValueAccessor;
  }());
  exports.RadioControlValueAccessor = RadioControlValueAccessor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/select_multiple_control_value_accessor.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "./control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  exports.SELECT_MULTIPLE_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return SelectMultipleControlValueAccessor;
    }),
    multi: true
  };
  function _buildValueString(id, value) {
    if (lang_1.isBlank(id))
      return "" + value;
    if (lang_1.isString(value))
      value = "'" + value + "'";
    if (!lang_1.isPrimitive(value))
      value = 'Object';
    return lang_1.StringWrapper.slice(id + ": " + value, 0, 50);
  }
  function _extractId(valueString) {
    return valueString.split(':')[0];
  }
  var HTMLCollection = (function() {
    function HTMLCollection() {}
    return HTMLCollection;
  }());
  var SelectMultipleControlValueAccessor = (function() {
    function SelectMultipleControlValueAccessor() {
      this._optionMap = new Map();
      this._idCounter = 0;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    SelectMultipleControlValueAccessor.prototype.writeValue = function(value) {
      var _this = this;
      this.value = value;
      if (value == null)
        return;
      var values = value;
      var ids = values.map(function(v) {
        return _this._getOptionId(v);
      });
      this._optionMap.forEach(function(opt, o) {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      });
    };
    SelectMultipleControlValueAccessor.prototype.registerOnChange = function(fn) {
      var _this = this;
      this.onChange = function(_) {
        var selected = [];
        if (_.hasOwnProperty('selectedOptions')) {
          var options = _.selectedOptions;
          for (var i = 0; i < options.length; i++) {
            var opt = options.item(i);
            var val = _this._getOptionValue(opt.value);
            selected.push(val);
          }
        } else {
          var options = _.options;
          for (var i = 0; i < options.length; i++) {
            var opt = options.item(i);
            if (opt.selected) {
              var val = _this._getOptionValue(opt.value);
              selected.push(val);
            }
          }
        }
        fn(selected);
      };
    };
    SelectMultipleControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    SelectMultipleControlValueAccessor.prototype._registerOption = function(value) {
      var id = (this._idCounter++).toString();
      this._optionMap.set(id, value);
      return id;
    };
    SelectMultipleControlValueAccessor.prototype._getOptionId = function(value) {
      for (var _i = 0,
          _a = collection_1.MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
        var id = _a[_i];
        if (lang_1.looseIdentical(this._optionMap.get(id)._value, value))
          return id;
      }
      return null;
    };
    SelectMultipleControlValueAccessor.prototype._getOptionValue = function(valueString) {
      var opt = this._optionMap.get(_extractId(valueString));
      return lang_1.isPresent(opt) ? opt._value : valueString;
    };
    SelectMultipleControlValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'select[multiple][ngControl],select[multiple][ngFormControl],select[multiple][ngModel]',
        host: {
          '(change)': 'onChange($event.target)',
          '(blur)': 'onTouched()'
        },
        providers: [exports.SELECT_MULTIPLE_VALUE_ACCESSOR]
      }]
    }];
    SelectMultipleControlValueAccessor.ctorParameters = [];
    return SelectMultipleControlValueAccessor;
  }());
  exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
  var NgSelectMultipleOption = (function() {
    function NgSelectMultipleOption(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (lang_1.isPresent(this._select)) {
        this.id = this._select._registerOption(this);
      }
    }
    Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
      set: function(value) {
        if (this._select == null)
          return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
      set: function(value) {
        if (lang_1.isPresent(this._select)) {
          this._value = value;
          this._setElementValue(_buildValueString(this.id, value));
          this._select.writeValue(this._select.value);
        } else {
          this._setElementValue(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    NgSelectMultipleOption.prototype._setElementValue = function(value) {
      this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
    };
    NgSelectMultipleOption.prototype._setSelected = function(selected) {
      this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
    };
    NgSelectMultipleOption.prototype.ngOnDestroy = function() {
      if (lang_1.isPresent(this._select)) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    };
    NgSelectMultipleOption.decorators = [{
      type: core_1.Directive,
      args: [{selector: 'option'}]
    }];
    NgSelectMultipleOption.ctorParameters = [{type: core_1.ElementRef}, {type: core_1.Renderer}, {
      type: SelectMultipleControlValueAccessor,
      decorators: [{type: core_1.Optional}, {type: core_1.Host}]
    }];
    NgSelectMultipleOption.propDecorators = {
      'ngValue': [{
        type: core_1.Input,
        args: ['ngValue']
      }],
      'value': [{
        type: core_1.Input,
        args: ['value']
      }]
    };
    return NgSelectMultipleOption;
  }());
  exports.NgSelectMultipleOption = NgSelectMultipleOption;
  exports.SELECT_DIRECTIVES = [SelectMultipleControlValueAccessor, NgSelectMultipleOption];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/shared.js", ["../../facade/collection", "../../facade/exceptions", "../../facade/lang", "../validators", "./checkbox_value_accessor", "./default_value_accessor", "./normalize_validator", "./number_value_accessor", "./radio_control_value_accessor", "./select_control_value_accessor", "./select_multiple_control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var validators_1 = $__require('../validators');
  var checkbox_value_accessor_1 = $__require('./checkbox_value_accessor');
  var default_value_accessor_1 = $__require('./default_value_accessor');
  var normalize_validator_1 = $__require('./normalize_validator');
  var number_value_accessor_1 = $__require('./number_value_accessor');
  var radio_control_value_accessor_1 = $__require('./radio_control_value_accessor');
  var select_control_value_accessor_1 = $__require('./select_control_value_accessor');
  var select_multiple_control_value_accessor_1 = $__require('./select_multiple_control_value_accessor');
  function controlPath(name, parent) {
    var p = collection_1.ListWrapper.clone(parent.path);
    p.push(name);
    return p;
  }
  exports.controlPath = controlPath;
  function setUpControl(control, dir) {
    if (lang_1.isBlank(control))
      _throwError(dir, 'Cannot find control with');
    if (lang_1.isBlank(dir.valueAccessor))
      _throwError(dir, 'No value accessor for form control with');
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
    dir.valueAccessor.writeValue(control.value);
    dir.valueAccessor.registerOnChange(function(newValue) {
      dir.viewToModelUpdate(newValue);
      control.updateValue(newValue, {emitModelToViewChange: false});
      control.markAsDirty();
    });
    control.registerOnChange(function(newValue) {
      return dir.valueAccessor.writeValue(newValue);
    });
    dir.valueAccessor.registerOnTouched(function() {
      return control.markAsTouched();
    });
  }
  exports.setUpControl = setUpControl;
  function setUpControlGroup(control, dir) {
    if (lang_1.isBlank(control))
      _throwError(dir, 'Cannot find control with');
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
  }
  exports.setUpControlGroup = setUpControlGroup;
  function _throwError(dir, message) {
    var messageEnd;
    if (dir.path.length > 1) {
      messageEnd = "path: '" + dir.path.join(' -> ') + "'";
    } else if (dir.path[0]) {
      messageEnd = "name: '" + dir.path + "'";
    } else {
      messageEnd = 'unspecified name';
    }
    throw new exceptions_1.BaseException(message + " " + messageEnd);
  }
  function composeValidators(validators) {
    return lang_1.isPresent(validators) ? validators_1.Validators.compose(validators.map(normalize_validator_1.normalizeValidator)) : null;
  }
  exports.composeValidators = composeValidators;
  function composeAsyncValidators(validators) {
    return lang_1.isPresent(validators) ? validators_1.Validators.composeAsync(validators.map(normalize_validator_1.normalizeAsyncValidator)) : null;
  }
  exports.composeAsyncValidators = composeAsyncValidators;
  function isPropertyUpdated(changes, viewModel) {
    if (!collection_1.StringMapWrapper.contains(changes, 'model'))
      return false;
    var change = changes['model'];
    if (change.isFirstChange())
      return true;
    return !lang_1.looseIdentical(viewModel, change.currentValue);
  }
  exports.isPropertyUpdated = isPropertyUpdated;
  function selectValueAccessor(dir, valueAccessors) {
    if (lang_1.isBlank(valueAccessors))
      return null;
    var defaultAccessor;
    var builtinAccessor;
    var customAccessor;
    valueAccessors.forEach(function(v) {
      if (lang_1.hasConstructor(v, default_value_accessor_1.DefaultValueAccessor)) {
        defaultAccessor = v;
      } else if (lang_1.hasConstructor(v, checkbox_value_accessor_1.CheckboxControlValueAccessor) || lang_1.hasConstructor(v, number_value_accessor_1.NumberValueAccessor) || lang_1.hasConstructor(v, select_control_value_accessor_1.SelectControlValueAccessor) || lang_1.hasConstructor(v, select_multiple_control_value_accessor_1.SelectMultipleControlValueAccessor) || lang_1.hasConstructor(v, radio_control_value_accessor_1.RadioControlValueAccessor)) {
        if (lang_1.isPresent(builtinAccessor))
          _throwError(dir, 'More than one built-in value accessor matches form control with');
        builtinAccessor = v;
      } else {
        if (lang_1.isPresent(customAccessor))
          _throwError(dir, 'More than one custom value accessor matches form control with');
        customAccessor = v;
      }
    });
    if (lang_1.isPresent(customAccessor))
      return customAccessor;
    if (lang_1.isPresent(builtinAccessor))
      return builtinAccessor;
    if (lang_1.isPresent(defaultAccessor))
      return defaultAccessor;
    _throwError(dir, 'No valid value accessor for form control with');
    return null;
  }
  exports.selectValueAccessor = selectValueAccessor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/ng_model.js", ["@angular/core", "../../facade/async", "../model", "../validators", "./control_value_accessor", "./ng_control", "./shared"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var async_1 = $__require('../../facade/async');
  var model_1 = $__require('../model');
  var validators_1 = $__require('../validators');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  var ng_control_1 = $__require('./ng_control');
  var shared_1 = $__require('./shared');
  exports.formControlBinding = {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function() {
      return NgModel;
    })
  };
  var NgModel = (function(_super) {
    __extends(NgModel, _super);
    function NgModel(_validators, _asyncValidators, valueAccessors) {
      _super.call(this);
      this._validators = _validators;
      this._asyncValidators = _asyncValidators;
      this._control = new model_1.Control();
      this._added = false;
      this.update = new async_1.EventEmitter();
      this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgModel.prototype.ngOnChanges = function(changes) {
      if (!this._added) {
        shared_1.setUpControl(this._control, this);
        this._control.updateValueAndValidity({emitEvent: false});
        this._added = true;
      }
      if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
        this._control.updateValue(this.model);
        this.viewModel = this.model;
      }
    };
    Object.defineProperty(NgModel.prototype, "control", {
      get: function() {
        return this._control;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
      get: function() {
        return shared_1.composeValidators(this._validators);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModel.prototype, "asyncValidator", {
      get: function() {
        return shared_1.composeAsyncValidators(this._asyncValidators);
      },
      enumerable: true,
      configurable: true
    });
    NgModel.prototype.viewToModelUpdate = function(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    };
    NgModel.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[ngModel]:not([ngControl]):not([ngFormControl])',
        providers: [exports.formControlBinding],
        inputs: ['model: ngModel'],
        outputs: ['update: ngModelChange'],
        exportAs: 'ngForm'
      }]
    }];
    NgModel.ctorParameters = [{
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [validators_1.NG_ASYNC_VALIDATORS]
      }]
    }, {
      type: Array,
      decorators: [{type: core_1.Optional}, {type: core_1.Self}, {
        type: core_1.Inject,
        args: [control_value_accessor_1.NG_VALUE_ACCESSOR]
      }]
    }];
    return NgModel;
  }(ng_control_1.NgControl));
  exports.NgModel = NgModel;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/control_value_accessor.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.NG_VALUE_ACCESSOR = new core_1.OpaqueToken('NgValueAccessor');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/select_control_value_accessor.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "./control_value_accessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var control_value_accessor_1 = $__require('./control_value_accessor');
  exports.SELECT_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function() {
      return SelectControlValueAccessor;
    }),
    multi: true
  };
  function _buildValueString(id, value) {
    if (lang_1.isBlank(id))
      return "" + value;
    if (!lang_1.isPrimitive(value))
      value = 'Object';
    return lang_1.StringWrapper.slice(id + ": " + value, 0, 50);
  }
  function _extractId(valueString) {
    return valueString.split(':')[0];
  }
  var SelectControlValueAccessor = (function() {
    function SelectControlValueAccessor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      this._optionMap = new Map();
      this._idCounter = 0;
      this.onChange = function(_) {};
      this.onTouched = function() {};
    }
    SelectControlValueAccessor.prototype.writeValue = function(value) {
      this.value = value;
      var valueString = _buildValueString(this._getOptionId(value), value);
      this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
    };
    SelectControlValueAccessor.prototype.registerOnChange = function(fn) {
      var _this = this;
      this.onChange = function(valueString) {
        _this.value = valueString;
        fn(_this._getOptionValue(valueString));
      };
    };
    SelectControlValueAccessor.prototype.registerOnTouched = function(fn) {
      this.onTouched = fn;
    };
    SelectControlValueAccessor.prototype._registerOption = function() {
      return (this._idCounter++).toString();
    };
    SelectControlValueAccessor.prototype._getOptionId = function(value) {
      for (var _i = 0,
          _a = collection_1.MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
        var id = _a[_i];
        if (lang_1.looseIdentical(this._optionMap.get(id), value))
          return id;
      }
      return null;
    };
    SelectControlValueAccessor.prototype._getOptionValue = function(valueString) {
      var value = this._optionMap.get(_extractId(valueString));
      return lang_1.isPresent(value) ? value : valueString;
    };
    SelectControlValueAccessor.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: 'select:not([multiple])[ngControl],select:not([multiple])[ngFormControl],select:not([multiple])[ngModel]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()'
        },
        providers: [exports.SELECT_VALUE_ACCESSOR]
      }]
    }];
    SelectControlValueAccessor.ctorParameters = [{type: core_1.Renderer}, {type: core_1.ElementRef}];
    return SelectControlValueAccessor;
  }());
  exports.SelectControlValueAccessor = SelectControlValueAccessor;
  var NgSelectOption = (function() {
    function NgSelectOption(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (lang_1.isPresent(this._select))
        this.id = this._select._registerOption();
    }
    Object.defineProperty(NgSelectOption.prototype, "ngValue", {
      set: function(value) {
        if (this._select == null)
          return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgSelectOption.prototype, "value", {
      set: function(value) {
        this._setElementValue(value);
        if (lang_1.isPresent(this._select))
          this._select.writeValue(this._select.value);
      },
      enumerable: true,
      configurable: true
    });
    NgSelectOption.prototype._setElementValue = function(value) {
      this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
    };
    NgSelectOption.prototype.ngOnDestroy = function() {
      if (lang_1.isPresent(this._select)) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    };
    NgSelectOption.decorators = [{
      type: core_1.Directive,
      args: [{selector: 'option'}]
    }];
    NgSelectOption.ctorParameters = [{type: core_1.ElementRef}, {type: core_1.Renderer}, {
      type: SelectControlValueAccessor,
      decorators: [{type: core_1.Optional}, {type: core_1.Host}]
    }];
    NgSelectOption.propDecorators = {
      'ngValue': [{
        type: core_1.Input,
        args: ['ngValue']
      }],
      'value': [{
        type: core_1.Input,
        args: ['value']
      }]
    };
    return NgSelectOption;
  }());
  exports.NgSelectOption = NgSelectOption;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/directives/validators.js", ["@angular/core", "../../facade/lang", "../validators"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../../facade/lang');
  var validators_1 = $__require('../validators');
  exports.REQUIRED = validators_1.Validators.required;
  exports.REQUIRED_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useValue: exports.REQUIRED,
    multi: true
  };
  var RequiredValidator = (function() {
    function RequiredValidator() {}
    RequiredValidator.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',
        providers: [exports.REQUIRED_VALIDATOR]
      }]
    }];
    return RequiredValidator;
  }());
  exports.RequiredValidator = RequiredValidator;
  exports.MIN_LENGTH_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function() {
      return MinLengthValidator;
    }),
    multi: true
  };
  var MinLengthValidator = (function() {
    function MinLengthValidator(minLength) {
      this._validator = validators_1.Validators.minLength(lang_1.NumberWrapper.parseInt(minLength, 10));
    }
    MinLengthValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    MinLengthValidator.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',
        providers: [exports.MIN_LENGTH_VALIDATOR]
      }]
    }];
    MinLengthValidator.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Attribute,
        args: ['minlength']
      }]
    }];
    return MinLengthValidator;
  }());
  exports.MinLengthValidator = MinLengthValidator;
  exports.MAX_LENGTH_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function() {
      return MaxLengthValidator;
    }),
    multi: true
  };
  var MaxLengthValidator = (function() {
    function MaxLengthValidator(maxLength) {
      this._validator = validators_1.Validators.maxLength(lang_1.NumberWrapper.parseInt(maxLength, 10));
    }
    MaxLengthValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    MaxLengthValidator.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',
        providers: [exports.MAX_LENGTH_VALIDATOR]
      }]
    }];
    MaxLengthValidator.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Attribute,
        args: ['maxlength']
      }]
    }];
    return MaxLengthValidator;
  }());
  exports.MaxLengthValidator = MaxLengthValidator;
  exports.PATTERN_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function() {
      return PatternValidator;
    }),
    multi: true
  };
  var PatternValidator = (function() {
    function PatternValidator(pattern) {
      this._validator = validators_1.Validators.pattern(pattern);
    }
    PatternValidator.prototype.validate = function(c) {
      return this._validator(c);
    };
    PatternValidator.decorators = [{
      type: core_1.Directive,
      args: [{
        selector: '[pattern][ngControl],[pattern][ngFormControl],[pattern][ngModel]',
        providers: [exports.PATTERN_VALIDATOR]
      }]
    }];
    PatternValidator.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Attribute,
        args: ['pattern']
      }]
    }];
    return PatternValidator;
  }());
  exports.PatternValidator = PatternValidator;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/observable/PromiseObservable.js", ["../util/root", "../Observable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var root_1 = $__require('../util/root');
  var Observable_1 = $__require('../Observable');
  var PromiseObservable = (function(_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
      if (scheduler === void 0) {
        scheduler = null;
      }
      _super.call(this);
      this.promise = promise;
      this.scheduler = scheduler;
    }
    PromiseObservable.create = function(promise, scheduler) {
      if (scheduler === void 0) {
        scheduler = null;
      }
      return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function(subscriber) {
      var _this = this;
      var promise = this.promise;
      var scheduler = this.scheduler;
      if (scheduler == null) {
        if (this._isScalar) {
          if (!subscriber.isUnsubscribed) {
            subscriber.next(this.value);
            subscriber.complete();
          }
        } else {
          promise.then(function(value) {
            _this.value = value;
            _this._isScalar = true;
            if (!subscriber.isUnsubscribed) {
              subscriber.next(value);
              subscriber.complete();
            }
          }, function(err) {
            if (!subscriber.isUnsubscribed) {
              subscriber.error(err);
            }
          }).then(null, function(err) {
            root_1.root.setTimeout(function() {
              throw err;
            });
          });
        }
      } else {
        if (this._isScalar) {
          if (!subscriber.isUnsubscribed) {
            return scheduler.schedule(dispatchNext, 0, {
              value: this.value,
              subscriber: subscriber
            });
          }
        } else {
          promise.then(function(value) {
            _this.value = value;
            _this._isScalar = true;
            if (!subscriber.isUnsubscribed) {
              subscriber.add(scheduler.schedule(dispatchNext, 0, {
                value: value,
                subscriber: subscriber
              }));
            }
          }, function(err) {
            if (!subscriber.isUnsubscribed) {
              subscriber.add(scheduler.schedule(dispatchError, 0, {
                err: err,
                subscriber: subscriber
              }));
            }
          }).then(null, function(err) {
            root_1.root.setTimeout(function() {
              throw err;
            });
          });
        }
      }
    };
    return PromiseObservable;
  }(Observable_1.Observable));
  exports.PromiseObservable = PromiseObservable;
  function dispatchNext(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
      subscriber.next(value);
      subscriber.complete();
    }
  }
  function dispatchError(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
      subscriber.error(err);
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/async.js", ["rxjs/Subject", "rxjs/Observable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subject_1 = $__require('rxjs/Subject');
  var Observable_1 = $__require('rxjs/Observable');
  exports.Observable = Observable_1.Observable;
  var Subject_2 = $__require('rxjs/Subject');
  exports.Subject = Subject_2.Subject;
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = false;
      }
      _super.call(this);
      this.__isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.next = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(Subject_1.Subject));
  exports.EventEmitter = EventEmitter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/model.js", ["rxjs/observable/PromiseObservable", "../facade/async", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var PromiseObservable_1 = $__require('rxjs/observable/PromiseObservable');
  var async_1 = $__require('../facade/async');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  exports.VALID = 'VALID';
  exports.INVALID = 'INVALID';
  exports.PENDING = 'PENDING';
  function isControl(control) {
    return control instanceof AbstractControl;
  }
  exports.isControl = isControl;
  function _find(control, path) {
    if (lang_1.isBlank(path))
      return null;
    if (!(path instanceof Array)) {
      path = path.split('/');
    }
    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
      return null;
    return path.reduce(function(v, name) {
      if (v instanceof ControlGroup) {
        return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
      } else if (v instanceof ControlArray) {
        var index = name;
        return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
      } else {
        return null;
      }
    }, control);
  }
  function toObservable(r) {
    return lang_1.isPromise(r) ? PromiseObservable_1.PromiseObservable.create(r) : r;
  }
  var AbstractControl = (function() {
    function AbstractControl(validator, asyncValidator) {
      this.validator = validator;
      this.asyncValidator = asyncValidator;
      this._pristine = true;
      this._touched = false;
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
      get: function() {
        return this._value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
      get: function() {
        return this._status;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
      get: function() {
        return this._status === exports.VALID;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
      get: function() {
        return this._errors;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
      get: function() {
        return this._pristine;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
      get: function() {
        return !this.pristine;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
      get: function() {
        return this._touched;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
      get: function() {
        return !this._touched;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
      get: function() {
        return this._valueChanges;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "statusChanges", {
      get: function() {
        return this._statusChanges;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pending", {
      get: function() {
        return this._status == exports.PENDING;
      },
      enumerable: true,
      configurable: true
    });
    AbstractControl.prototype.markAsTouched = function() {
      this._touched = true;
    };
    AbstractControl.prototype.markAsDirty = function(_a) {
      var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
      onlySelf = lang_1.normalizeBool(onlySelf);
      this._pristine = false;
      if (lang_1.isPresent(this._parent) && !onlySelf) {
        this._parent.markAsDirty({onlySelf: onlySelf});
      }
    };
    AbstractControl.prototype.markAsPending = function(_a) {
      var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
      onlySelf = lang_1.normalizeBool(onlySelf);
      this._status = exports.PENDING;
      if (lang_1.isPresent(this._parent) && !onlySelf) {
        this._parent.markAsPending({onlySelf: onlySelf});
      }
    };
    AbstractControl.prototype.setParent = function(parent) {
      this._parent = parent;
    };
    AbstractControl.prototype.updateValueAndValidity = function(_a) {
      var _b = _a === void 0 ? {} : _a,
          onlySelf = _b.onlySelf,
          emitEvent = _b.emitEvent;
      onlySelf = lang_1.normalizeBool(onlySelf);
      emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
      this._updateValue();
      this._errors = this._runValidator();
      this._status = this._calculateStatus();
      if (this._status == exports.VALID || this._status == exports.PENDING) {
        this._runAsyncValidator(emitEvent);
      }
      if (emitEvent) {
        this._valueChanges.emit(this._value);
        this._statusChanges.emit(this._status);
      }
      if (lang_1.isPresent(this._parent) && !onlySelf) {
        this._parent.updateValueAndValidity({
          onlySelf: onlySelf,
          emitEvent: emitEvent
        });
      }
    };
    AbstractControl.prototype._runValidator = function() {
      return lang_1.isPresent(this.validator) ? this.validator(this) : null;
    };
    AbstractControl.prototype._runAsyncValidator = function(emitEvent) {
      var _this = this;
      if (lang_1.isPresent(this.asyncValidator)) {
        this._status = exports.PENDING;
        this._cancelExistingSubscription();
        var obs = toObservable(this.asyncValidator(this));
        this._asyncValidationSubscription = obs.subscribe({next: function(res) {
            return _this.setErrors(res, {emitEvent: emitEvent});
          }});
      }
    };
    AbstractControl.prototype._cancelExistingSubscription = function() {
      if (lang_1.isPresent(this._asyncValidationSubscription)) {
        this._asyncValidationSubscription.unsubscribe();
      }
    };
    AbstractControl.prototype.setErrors = function(errors, _a) {
      var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
      emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
      this._errors = errors;
      this._status = this._calculateStatus();
      if (emitEvent) {
        this._statusChanges.emit(this._status);
      }
      if (lang_1.isPresent(this._parent)) {
        this._parent._updateControlsErrors();
      }
    };
    AbstractControl.prototype.find = function(path) {
      return _find(this, path);
    };
    AbstractControl.prototype.getError = function(errorCode, path) {
      if (path === void 0) {
        path = null;
      }
      var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
      if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
        return collection_1.StringMapWrapper.get(control._errors, errorCode);
      } else {
        return null;
      }
    };
    AbstractControl.prototype.hasError = function(errorCode, path) {
      if (path === void 0) {
        path = null;
      }
      return lang_1.isPresent(this.getError(errorCode, path));
    };
    Object.defineProperty(AbstractControl.prototype, "root", {
      get: function() {
        var x = this;
        while (lang_1.isPresent(x._parent)) {
          x = x._parent;
        }
        return x;
      },
      enumerable: true,
      configurable: true
    });
    AbstractControl.prototype._updateControlsErrors = function() {
      this._status = this._calculateStatus();
      if (lang_1.isPresent(this._parent)) {
        this._parent._updateControlsErrors();
      }
    };
    AbstractControl.prototype._initObservables = function() {
      this._valueChanges = new async_1.EventEmitter();
      this._statusChanges = new async_1.EventEmitter();
    };
    AbstractControl.prototype._calculateStatus = function() {
      if (lang_1.isPresent(this._errors))
        return exports.INVALID;
      if (this._anyControlsHaveStatus(exports.PENDING))
        return exports.PENDING;
      if (this._anyControlsHaveStatus(exports.INVALID))
        return exports.INVALID;
      return exports.VALID;
    };
    return AbstractControl;
  }());
  exports.AbstractControl = AbstractControl;
  var Control = (function(_super) {
    __extends(Control, _super);
    function Control(value, validator, asyncValidator) {
      if (value === void 0) {
        value = null;
      }
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this._value = value;
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
      this._initObservables();
    }
    Control.prototype.updateValue = function(value, _a) {
      var _b = _a === void 0 ? {} : _a,
          onlySelf = _b.onlySelf,
          emitEvent = _b.emitEvent,
          emitModelToViewChange = _b.emitModelToViewChange;
      emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
      this._value = value;
      if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
        this._onChange(this._value);
      this.updateValueAndValidity({
        onlySelf: onlySelf,
        emitEvent: emitEvent
      });
    };
    Control.prototype._updateValue = function() {};
    Control.prototype._anyControlsHaveStatus = function(status) {
      return false;
    };
    Control.prototype.registerOnChange = function(fn) {
      this._onChange = fn;
    };
    return Control;
  }(AbstractControl));
  exports.Control = Control;
  var ControlGroup = (function(_super) {
    __extends(ControlGroup, _super);
    function ControlGroup(controls, optionals, validator, asyncValidator) {
      if (optionals === void 0) {
        optionals = null;
      }
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this.controls = controls;
      this._optionals = lang_1.isPresent(optionals) ? optionals : {};
      this._initObservables();
      this._setParentForControls();
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
    }
    ControlGroup.prototype.registerControl = function(name, control) {
      this.controls[name] = control;
      control.setParent(this);
    };
    ControlGroup.prototype.addControl = function(name, control) {
      this.registerControl(name, control);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.removeControl = function(name) {
      collection_1.StringMapWrapper.delete(this.controls, name);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.include = function(controlName) {
      collection_1.StringMapWrapper.set(this._optionals, controlName, true);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.exclude = function(controlName) {
      collection_1.StringMapWrapper.set(this._optionals, controlName, false);
      this.updateValueAndValidity();
    };
    ControlGroup.prototype.contains = function(controlName) {
      var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
      return c && this._included(controlName);
    };
    ControlGroup.prototype._setParentForControls = function() {
      var _this = this;
      collection_1.StringMapWrapper.forEach(this.controls, function(control, name) {
        control.setParent(_this);
      });
    };
    ControlGroup.prototype._updateValue = function() {
      this._value = this._reduceValue();
    };
    ControlGroup.prototype._anyControlsHaveStatus = function(status) {
      var _this = this;
      var res = false;
      collection_1.StringMapWrapper.forEach(this.controls, function(control, name) {
        res = res || (_this.contains(name) && control.status == status);
      });
      return res;
    };
    ControlGroup.prototype._reduceValue = function() {
      return this._reduceChildren({}, function(acc, control, name) {
        acc[name] = control.value;
        return acc;
      });
    };
    ControlGroup.prototype._reduceChildren = function(initValue, fn) {
      var _this = this;
      var res = initValue;
      collection_1.StringMapWrapper.forEach(this.controls, function(control, name) {
        if (_this._included(name)) {
          res = fn(res, control, name);
        }
      });
      return res;
    };
    ControlGroup.prototype._included = function(controlName) {
      var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
      return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
    };
    return ControlGroup;
  }(AbstractControl));
  exports.ControlGroup = ControlGroup;
  var ControlArray = (function(_super) {
    __extends(ControlArray, _super);
    function ControlArray(controls, validator, asyncValidator) {
      if (validator === void 0) {
        validator = null;
      }
      if (asyncValidator === void 0) {
        asyncValidator = null;
      }
      _super.call(this, validator, asyncValidator);
      this.controls = controls;
      this._initObservables();
      this._setParentForControls();
      this.updateValueAndValidity({
        onlySelf: true,
        emitEvent: false
      });
    }
    ControlArray.prototype.at = function(index) {
      return this.controls[index];
    };
    ControlArray.prototype.push = function(control) {
      this.controls.push(control);
      control.setParent(this);
      this.updateValueAndValidity();
    };
    ControlArray.prototype.insert = function(index, control) {
      collection_1.ListWrapper.insert(this.controls, index, control);
      control.setParent(this);
      this.updateValueAndValidity();
    };
    ControlArray.prototype.removeAt = function(index) {
      collection_1.ListWrapper.removeAt(this.controls, index);
      this.updateValueAndValidity();
    };
    Object.defineProperty(ControlArray.prototype, "length", {
      get: function() {
        return this.controls.length;
      },
      enumerable: true,
      configurable: true
    });
    ControlArray.prototype._updateValue = function() {
      this._value = this.controls.map(function(control) {
        return control.value;
      });
    };
    ControlArray.prototype._anyControlsHaveStatus = function(status) {
      return this.controls.some(function(c) {
        return c.status == status;
      });
    };
    ControlArray.prototype._setParentForControls = function() {
      var _this = this;
      this.controls.forEach(function(control) {
        control.setParent(_this);
      });
    };
    return ControlArray;
  }(AbstractControl));
  exports.ControlArray = ControlArray;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/operator/toPromise.js", ["../util/root"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var root_1 = $__require('../util/root');
  function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
      if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
        PromiseCtor = root_1.root.Rx.config.Promise;
      } else if (root_1.root.Promise) {
        PromiseCtor = root_1.root.Promise;
      }
    }
    if (!PromiseCtor) {
      throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  }
  exports.toPromise = toPromise;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated/validators.js", ["@angular/core", "rxjs/operator/toPromise", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var toPromise_1 = $__require('rxjs/operator/toPromise');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  exports.NG_VALIDATORS = new core_1.OpaqueToken('NgValidators');
  exports.NG_ASYNC_VALIDATORS = new core_1.OpaqueToken('NgAsyncValidators');
  var Validators = (function() {
    function Validators() {}
    Validators.required = function(control) {
      return lang_1.isBlank(control.value) || (lang_1.isString(control.value) && control.value == '') ? {'required': true} : null;
    };
    Validators.minLength = function(minLength) {
      return function(control) {
        if (lang_1.isPresent(Validators.required(control)))
          return null;
        var v = control.value;
        return v.length < minLength ? {'minlength': {
            'requiredLength': minLength,
            'actualLength': v.length
          }} : null;
      };
    };
    Validators.maxLength = function(maxLength) {
      return function(control) {
        if (lang_1.isPresent(Validators.required(control)))
          return null;
        var v = control.value;
        return v.length > maxLength ? {'maxlength': {
            'requiredLength': maxLength,
            'actualLength': v.length
          }} : null;
      };
    };
    Validators.pattern = function(pattern) {
      return function(control) {
        if (lang_1.isPresent(Validators.required(control)))
          return null;
        var regex = new RegExp("^" + pattern + "$");
        var v = control.value;
        return regex.test(v) ? null : {'pattern': {
            'requiredPattern': "^" + pattern + "$",
            'actualValue': v
          }};
      };
    };
    Validators.nullValidator = function(c) {
      return null;
    };
    Validators.compose = function(validators) {
      if (lang_1.isBlank(validators))
        return null;
      var presentValidators = validators.filter(lang_1.isPresent);
      if (presentValidators.length == 0)
        return null;
      return function(control) {
        return _mergeErrors(_executeValidators(control, presentValidators));
      };
    };
    Validators.composeAsync = function(validators) {
      if (lang_1.isBlank(validators))
        return null;
      var presentValidators = validators.filter(lang_1.isPresent);
      if (presentValidators.length == 0)
        return null;
      return function(control) {
        var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
        return Promise.all(promises).then(_mergeErrors);
      };
    };
    return Validators;
  }());
  exports.Validators = Validators;
  function _convertToPromise(obj) {
    return lang_1.isPromise(obj) ? obj : toPromise_1.toPromise.call(obj);
  }
  function _executeValidators(control, validators) {
    return validators.map(function(v) {
      return v(control);
    });
  }
  function _executeAsyncValidators(control, validators) {
    return validators.map(function(v) {
      return v(control);
    });
  }
  function _mergeErrors(arrayOfErrors) {
    var res = arrayOfErrors.reduce(function(res, errors) {
      return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
    }, {});
    return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/forms-deprecated.js", ["@angular/core", "./forms-deprecated/directives", "./forms-deprecated/directives/radio_control_value_accessor", "./forms-deprecated/form_builder", "./forms-deprecated/directives/abstract_control_directive", "./forms-deprecated/directives/checkbox_value_accessor", "./forms-deprecated/directives/control_container", "./forms-deprecated/directives/control_value_accessor", "./forms-deprecated/directives/default_value_accessor", "./forms-deprecated/directives/ng_control", "./forms-deprecated/directives/ng_control_group", "./forms-deprecated/directives/ng_control_name", "./forms-deprecated/directives/ng_control_status", "./forms-deprecated/directives/ng_form", "./forms-deprecated/directives/ng_form_control", "./forms-deprecated/directives/ng_form_model", "./forms-deprecated/directives/ng_model", "./forms-deprecated/directives/select_control_value_accessor", "./forms-deprecated/directives/validators", "./forms-deprecated/model", "./forms-deprecated/validators"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var directives_1 = $__require('./forms-deprecated/directives');
  var radio_control_value_accessor_1 = $__require('./forms-deprecated/directives/radio_control_value_accessor');
  var form_builder_1 = $__require('./forms-deprecated/form_builder');
  var directives_2 = $__require('./forms-deprecated/directives');
  exports.FORM_DIRECTIVES = directives_2.FORM_DIRECTIVES;
  exports.RadioButtonState = directives_2.RadioButtonState;
  var abstract_control_directive_1 = $__require('./forms-deprecated/directives/abstract_control_directive');
  exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
  var checkbox_value_accessor_1 = $__require('./forms-deprecated/directives/checkbox_value_accessor');
  exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
  var control_container_1 = $__require('./forms-deprecated/directives/control_container');
  exports.ControlContainer = control_container_1.ControlContainer;
  var control_value_accessor_1 = $__require('./forms-deprecated/directives/control_value_accessor');
  exports.NG_VALUE_ACCESSOR = control_value_accessor_1.NG_VALUE_ACCESSOR;
  var default_value_accessor_1 = $__require('./forms-deprecated/directives/default_value_accessor');
  exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
  var ng_control_1 = $__require('./forms-deprecated/directives/ng_control');
  exports.NgControl = ng_control_1.NgControl;
  var ng_control_group_1 = $__require('./forms-deprecated/directives/ng_control_group');
  exports.NgControlGroup = ng_control_group_1.NgControlGroup;
  var ng_control_name_1 = $__require('./forms-deprecated/directives/ng_control_name');
  exports.NgControlName = ng_control_name_1.NgControlName;
  var ng_control_status_1 = $__require('./forms-deprecated/directives/ng_control_status');
  exports.NgControlStatus = ng_control_status_1.NgControlStatus;
  var ng_form_1 = $__require('./forms-deprecated/directives/ng_form');
  exports.NgForm = ng_form_1.NgForm;
  var ng_form_control_1 = $__require('./forms-deprecated/directives/ng_form_control');
  exports.NgFormControl = ng_form_control_1.NgFormControl;
  var ng_form_model_1 = $__require('./forms-deprecated/directives/ng_form_model');
  exports.NgFormModel = ng_form_model_1.NgFormModel;
  var ng_model_1 = $__require('./forms-deprecated/directives/ng_model');
  exports.NgModel = ng_model_1.NgModel;
  var select_control_value_accessor_1 = $__require('./forms-deprecated/directives/select_control_value_accessor');
  exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
  exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
  var validators_1 = $__require('./forms-deprecated/directives/validators');
  exports.MaxLengthValidator = validators_1.MaxLengthValidator;
  exports.MinLengthValidator = validators_1.MinLengthValidator;
  exports.PatternValidator = validators_1.PatternValidator;
  exports.RequiredValidator = validators_1.RequiredValidator;
  var form_builder_2 = $__require('./forms-deprecated/form_builder');
  exports.FormBuilder = form_builder_2.FormBuilder;
  var model_1 = $__require('./forms-deprecated/model');
  exports.AbstractControl = model_1.AbstractControl;
  exports.Control = model_1.Control;
  exports.ControlArray = model_1.ControlArray;
  exports.ControlGroup = model_1.ControlGroup;
  var validators_2 = $__require('./forms-deprecated/validators');
  exports.NG_ASYNC_VALIDATORS = validators_2.NG_ASYNC_VALIDATORS;
  exports.NG_VALIDATORS = validators_2.NG_VALIDATORS;
  exports.Validators = validators_2.Validators;
  exports.FORM_PROVIDERS = [form_builder_1.FormBuilder, radio_control_value_accessor_1.RadioControlRegistry];
  var DeprecatedFormsModule = (function() {
    function DeprecatedFormsModule() {}
    DeprecatedFormsModule.decorators = [{
      type: core_1.NgModule,
      args: [{
        providers: [exports.FORM_PROVIDERS],
        declarations: directives_1.FORM_DIRECTIVES,
        exports: directives_1.FORM_DIRECTIVES
      }]
    }];
    return DeprecatedFormsModule;
  }());
  exports.DeprecatedFormsModule = DeprecatedFormsModule;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location/hash_location_strategy.js", ["@angular/core", "../facade/lang", "./location", "./location_strategy", "./platform_location"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var location_1 = $__require('./location');
  var location_strategy_1 = $__require('./location_strategy');
  var platform_location_1 = $__require('./platform_location');
  var HashLocationStrategy = (function(_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy(_platformLocation, _baseHref) {
      _super.call(this);
      this._platformLocation = _platformLocation;
      this._baseHref = '';
      if (lang_1.isPresent(_baseHref)) {
        this._baseHref = _baseHref;
      }
    }
    HashLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    HashLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    HashLocationStrategy.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      var path = this._platformLocation.hash;
      if (!lang_1.isPresent(path))
        path = '#';
      return path.length > 0 ? path.substring(1) : path;
    };
    HashLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      var url = location_1.Location.joinWithSlash(this._baseHref, internal);
      return url.length > 0 ? ('#' + url) : url;
    };
    HashLocationStrategy.prototype.pushState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.replaceState = function(state, title, path, queryParams) {
      var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.replaceState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    HashLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    HashLocationStrategy.decorators = [{type: core_1.Injectable}];
    HashLocationStrategy.ctorParameters = [{type: platform_location_1.PlatformLocation}, {
      type: undefined,
      decorators: [{type: core_1.Optional}, {
        type: core_1.Inject,
        args: [location_strategy_1.APP_BASE_HREF]
      }]
    }];
    return HashLocationStrategy;
  }(location_strategy_1.LocationStrategy));
  exports.HashLocationStrategy = HashLocationStrategy;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/base_wrapped_exception.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  exports.BaseWrappedException = BaseWrappedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/collection.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Map = lang_1.global.Map;
  exports.Set = lang_1.global.Set;
  var createMapFromPairs = (function() {
    try {
      if (new exports.Map([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new exports.Map(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new exports.Map();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new exports.Map(new exports.Map())) {
        return function createMapFromMap(m) {
          return new exports.Map(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new exports.Map();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new exports.Map()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new exports.Map()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new exports.Map();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  exports.MapWrapper = MapWrapper;
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).map(function(k) {
        return map[k];
      });
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var _i = 0,
          _a = Object.keys(map); _i < _a.length; _i++) {
        var k = _a[_i];
        callback(map[k], k);
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var _i = 0,
          _a = Object.keys(m1); _i < _a.length; _i++) {
        var k = _a[_i];
        m[k] = m1[k];
      }
      for (var _b = 0,
          _c = Object.keys(m2); _b < _c.length; _b++) {
        var k = _c[_b];
        m[k] = m2[k];
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  exports.StringMapWrapper = StringMapWrapper;
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (lang_1.isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (lang_1.isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  exports.ListWrapper = ListWrapper;
  function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (lang_1.isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
      return false;
    return lang_1.isArray(obj) || (!(obj instanceof exports.Map) && lang_1.getSymbolIterator() in obj);
  }
  exports.isListLikeIterable = isListLikeIterable;
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  exports.areIterablesEqual = areIterablesEqual;
  function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[lang_1.getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  exports.iterateListLike = iterateListLike;
  var createSetFromList = (function() {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new exports.Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new exports.Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  exports.SetWrapper = SetWrapper;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/exception_handler.js", ["./base_wrapped_exception", "./collection", "./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var collection_1 = $__require('./collection');
  var lang_1 = $__require('./lang');
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join('\n');
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
        this._logger.logError('STACKTRACE:');
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (lang_1.isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (lang_1.isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (lang_1.isPresent(originalStack)) {
        this._logger.logError('ORIGINAL STACKTRACE:');
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (lang_1.isPresent(context)) {
        this._logger.logError('ERROR CONTEXT:');
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
          return null;
        return lang_1.isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  exports.ExceptionHandler = ExceptionHandler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/exceptions.js", ["./base_wrapped_exception", "./exception_handler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var exception_handler_1 = $__require('./exception_handler');
  var exception_handler_2 = $__require('./exception_handler');
  exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = '--';
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  exports.BaseException = BaseException;
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return exception_handler_1.ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(base_wrapped_exception_1.BaseWrappedException));
  exports.WrappedException = WrappedException;
  function makeTypeError(message) {
    return new TypeError(message);
  }
  exports.makeTypeError = makeTypeError;
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  exports.unimplemented = unimplemented;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/facade/lang.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  exports.scheduleMicroTask = scheduleMicroTask;
  var _global = globalScope;
  exports.global = _global;
  exports.Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  exports.getTypeNameForDebugging = getTypeNameForDebugging;
  exports.Math = _global.Math;
  exports.Date = _global.Date;
  _global.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  exports.isPresent = isPresent;
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  exports.isBlank = isBlank;
  function isBoolean(obj) {
    return typeof obj === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  exports.isNumber = isNumber;
  function isString(obj) {
    return typeof obj === 'string';
  }
  exports.isString = isString;
  function isFunction(obj) {
    return typeof obj === 'function';
  }
  exports.isFunction = isFunction;
  function isType(obj) {
    return isFunction(obj);
  }
  exports.isType = isType;
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  exports.isStringMap = isStringMap;
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  exports.isStrictStringMap = isStrictStringMap;
  function isPromise(obj) {
    return isPresent(obj) && isFunction(obj.then);
  }
  exports.isPromise = isPromise;
  function isArray(obj) {
    return Array.isArray(obj);
  }
  exports.isArray = isArray;
  function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
  }
  exports.isDate = isDate;
  function noop() {}
  exports.noop = noop;
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf('\n');
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  exports.stringify = stringify;
  function serializeEnum(val) {
    return val;
  }
  exports.serializeEnum = serializeEnum;
  function deserializeEnum(val, values) {
    return val;
  }
  exports.deserializeEnum = deserializeEnum;
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  exports.resolveEnumToken = resolveEnumToken;
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  exports.StringWrapper = StringWrapper;
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join('');
    };
    return StringJoiner;
  }());
  exports.StringJoiner = StringJoiner;
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  exports.NumberParseError = NumberParseError;
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError('Invalid integer literal when parsing ' + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNumeric = function(value) {
      return !isNaN(value - parseFloat(value));
    };
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  exports.NumberWrapper = NumberWrapper;
  exports.RegExp = _global.RegExp;
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    FunctionWrapper.bind = function(fn, scope) {
      return fn.bind(scope);
    };
    return FunctionWrapper;
  }());
  exports.FunctionWrapper = FunctionWrapper;
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  exports.looseIdentical = looseIdentical;
  function getMapKey(value) {
    return value;
  }
  exports.getMapKey = getMapKey;
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  exports.normalizeBlank = normalizeBlank;
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  exports.normalizeBool = normalizeBool;
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  exports.isJsObject = isJsObject;
  function print(obj) {
    console.log(obj);
  }
  exports.print = print;
  function warn(obj) {
    console.warn(obj);
  }
  exports.warn = warn;
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return _global.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return _global.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  exports.Json = Json;
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new exports.Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new exports.Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new exports.Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  exports.DateWrapper = DateWrapper;
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  exports.setValueOnPath = setValueOnPath;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  exports.evalExpression = evalExpression;
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  exports.isPrimitive = isPrimitive;
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  exports.hasConstructor = hasConstructor;
  function escape(s) {
    return _global.encodeURI(s);
  }
  exports.escape = escape;
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  exports.escapeRegExp = escapeRegExp;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location/platform_location.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var PlatformLocation = (function() {
    function PlatformLocation() {}
    Object.defineProperty(PlatformLocation.prototype, "pathname", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "search", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "hash", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return PlatformLocation;
  }());
  exports.PlatformLocation = PlatformLocation;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location/path_location_strategy.js", ["@angular/core", "../facade/exceptions", "../facade/lang", "./location", "./location_strategy", "./platform_location"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var location_1 = $__require('./location');
  var location_strategy_1 = $__require('./location_strategy');
  var platform_location_1 = $__require('./platform_location');
  var PathLocationStrategy = (function(_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy(_platformLocation, href) {
      _super.call(this);
      this._platformLocation = _platformLocation;
      if (lang_1.isBlank(href)) {
        href = this._platformLocation.getBaseHrefFromDOM();
      }
      if (lang_1.isBlank(href)) {
        throw new exceptions_1.BaseException("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
      }
      this._baseHref = href;
    }
    PathLocationStrategy.prototype.onPopState = function(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    };
    PathLocationStrategy.prototype.getBaseHref = function() {
      return this._baseHref;
    };
    PathLocationStrategy.prototype.prepareExternalUrl = function(internal) {
      return location_1.Location.joinWithSlash(this._baseHref, internal);
    };
    PathLocationStrategy.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      var pathname = this._platformLocation.pathname + location_1.Location.normalizeQueryParams(this._platformLocation.search);
      var hash = this._platformLocation.hash;
      return hash && includeHash ? "" + pathname + hash : pathname;
    };
    PathLocationStrategy.prototype.pushState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
      this._platformLocation.pushState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.replaceState = function(state, title, url, queryParams) {
      var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
      this._platformLocation.replaceState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.forward = function() {
      this._platformLocation.forward();
    };
    PathLocationStrategy.prototype.back = function() {
      this._platformLocation.back();
    };
    PathLocationStrategy.decorators = [{type: core_1.Injectable}];
    PathLocationStrategy.ctorParameters = [{type: platform_location_1.PlatformLocation}, {
      type: undefined,
      decorators: [{type: core_1.Optional}, {
        type: core_1.Inject,
        args: [location_strategy_1.APP_BASE_HREF]
      }]
    }];
    return PathLocationStrategy;
  }(location_strategy_1.LocationStrategy));
  exports.PathLocationStrategy = PathLocationStrategy;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location/location_strategy.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var LocationStrategy = (function() {
    function LocationStrategy() {}
    return LocationStrategy;
  }());
  exports.LocationStrategy = LocationStrategy;
  exports.APP_BASE_HREF = new core_1.OpaqueToken('appBaseHref');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location/location.js", ["@angular/core", "./location_strategy"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var location_strategy_1 = $__require('./location_strategy');
  var Location = (function() {
    function Location(platformStrategy) {
      var _this = this;
      this._subject = new core_1.EventEmitter();
      this._platformStrategy = platformStrategy;
      var browserBaseHref = this._platformStrategy.getBaseHref();
      this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
      this._platformStrategy.onPopState(function(ev) {
        _this._subject.emit({
          'url': _this.path(true),
          'pop': true,
          'type': ev.type
        });
      });
    }
    Location.prototype.path = function(includeHash) {
      if (includeHash === void 0) {
        includeHash = false;
      }
      return this.normalize(this._platformStrategy.path(includeHash));
    };
    Location.prototype.isCurrentPathEqualTo = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
    };
    Location.prototype.normalize = function(url) {
      return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    };
    Location.prototype.prepareExternalUrl = function(url) {
      if (url.length > 0 && !url.startsWith('/')) {
        url = '/' + url;
      }
      return this._platformStrategy.prepareExternalUrl(url);
    };
    Location.prototype.go = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this._platformStrategy.pushState(null, '', path, query);
    };
    Location.prototype.replaceState = function(path, query) {
      if (query === void 0) {
        query = '';
      }
      this._platformStrategy.replaceState(null, '', path, query);
    };
    Location.prototype.forward = function() {
      this._platformStrategy.forward();
    };
    Location.prototype.back = function() {
      this._platformStrategy.back();
    };
    Location.prototype.subscribe = function(onNext, onThrow, onReturn) {
      if (onThrow === void 0) {
        onThrow = null;
      }
      if (onReturn === void 0) {
        onReturn = null;
      }
      return this._subject.subscribe({
        next: onNext,
        error: onThrow,
        complete: onReturn
      });
    };
    Location.normalizeQueryParams = function(params) {
      return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
    };
    Location.joinWithSlash = function(start, end) {
      if (start.length == 0) {
        return end;
      }
      if (end.length == 0) {
        return start;
      }
      var slashes = 0;
      if (start.endsWith('/')) {
        slashes++;
      }
      if (end.startsWith('/')) {
        slashes++;
      }
      if (slashes == 2) {
        return start + end.substring(1);
      }
      if (slashes == 1) {
        return start + end;
      }
      return start + '/' + end;
    };
    Location.stripTrailingSlash = function(url) {
      if (/\/$/g.test(url)) {
        url = url.substring(0, url.length - 1);
      }
      return url;
    };
    Location.decorators = [{type: core_1.Injectable}];
    Location.ctorParameters = [{type: location_strategy_1.LocationStrategy}];
    return Location;
  }());
  exports.Location = Location;
  function _stripBaseHref(baseHref, url) {
    if (baseHref.length > 0 && url.startsWith(baseHref)) {
      return url.substring(baseHref.length);
    }
    return url;
  }
  function _stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
      return url.substring(0, url.length - 11);
    }
    return url;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/location.js", ["./location/platform_location", "./location/location_strategy", "./location/hash_location_strategy", "./location/path_location_strategy", "./location/location"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  __export($__require('./location/platform_location'));
  __export($__require('./location/location_strategy'));
  __export($__require('./location/hash_location_strategy'));
  __export($__require('./location/path_location_strategy'));
  __export($__require('./location/location'));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/src/localization.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var NgLocalization = (function() {
    function NgLocalization() {}
    return NgLocalization;
  }());
  exports.NgLocalization = NgLocalization;
  function getPluralCategory(value, cases, ngLocalization) {
    var nbCase = "=" + value;
    return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
  }
  exports.getPluralCategory = getPluralCategory;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/common/index.js", ["@angular/core", "./src/common_directives", "./src/pipes", "./src/directives", "./src/forms-deprecated", "./src/location", "./src/localization"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  var core_1 = $__require('@angular/core');
  var common_directives_1 = $__require('./src/common_directives');
  var pipes_1 = $__require('./src/pipes');
  __export($__require('./src/pipes'));
  __export($__require('./src/directives'));
  __export($__require('./src/forms-deprecated'));
  __export($__require('./src/common_directives'));
  __export($__require('./src/location'));
  var localization_1 = $__require('./src/localization');
  exports.NgLocalization = localization_1.NgLocalization;
  var CommonModule = (function() {
    function CommonModule() {}
    CommonModule.decorators = [{
      type: core_1.NgModule,
      args: [{
        declarations: [common_directives_1.COMMON_DIRECTIVES, pipes_1.COMMON_PIPES],
        exports: [common_directives_1.COMMON_DIRECTIVES, pipes_1.COMMON_PIPES]
      }]
    }];
    return CommonModule;
  }());
  exports.CommonModule = CommonModule;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/location/history.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function supportsState() {
    return !!window.history.pushState;
  }
  exports.supportsState = supportsState;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/location/browser_platform_location.js", ["@angular/common", "@angular/core", "../../dom/dom_adapter", "./history"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var common_1 = $__require('@angular/common');
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../../dom/dom_adapter');
  var history_1 = $__require('./history');
  var BrowserPlatformLocation = (function(_super) {
    __extends(BrowserPlatformLocation, _super);
    function BrowserPlatformLocation() {
      _super.call(this);
      this._init();
    }
    BrowserPlatformLocation.prototype._init = function() {
      this._location = dom_adapter_1.getDOM().getLocation();
      this._history = dom_adapter_1.getDOM().getHistory();
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
      get: function() {
        return this._location;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function() {
      return dom_adapter_1.getDOM().getBaseHref();
    };
    BrowserPlatformLocation.prototype.onPopState = function(fn) {
      dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    BrowserPlatformLocation.prototype.onHashChange = function(fn) {
      dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
      get: function() {
        return this._location.pathname;
      },
      set: function(newPath) {
        this._location.pathname = newPath;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
      get: function() {
        return this._location.search;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
      get: function() {
        return this._location.hash;
      },
      enumerable: true,
      configurable: true
    });
    BrowserPlatformLocation.prototype.pushState = function(state, title, url) {
      if (history_1.supportsState()) {
        this._history.pushState(state, title, url);
      } else {
        this._location.hash = url;
      }
    };
    BrowserPlatformLocation.prototype.replaceState = function(state, title, url) {
      if (history_1.supportsState()) {
        this._history.replaceState(state, title, url);
      } else {
        this._location.hash = url;
      }
    };
    BrowserPlatformLocation.prototype.forward = function() {
      this._history.forward();
    };
    BrowserPlatformLocation.prototype.back = function() {
      this._history.back();
    };
    BrowserPlatformLocation.decorators = [{type: core_1.Injectable}];
    BrowserPlatformLocation.ctorParameters = [];
    return BrowserPlatformLocation;
  }(common_1.PlatformLocation));
  exports.BrowserPlatformLocation = BrowserPlatformLocation;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser/testability.js", ["@angular/core", "../dom/dom_adapter", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var PublicTestability = (function() {
    function PublicTestability(testability) {
      this._testability = testability;
    }
    PublicTestability.prototype.isStable = function() {
      return this._testability.isStable();
    };
    PublicTestability.prototype.whenStable = function(callback) {
      this._testability.whenStable(callback);
    };
    PublicTestability.prototype.findBindings = function(using, provider, exactMatch) {
      return this.findProviders(using, provider, exactMatch);
    };
    PublicTestability.prototype.findProviders = function(using, provider, exactMatch) {
      return this._testability.findBindings(using, provider, exactMatch);
    };
    return PublicTestability;
  }());
  var BrowserGetTestability = (function() {
    function BrowserGetTestability() {}
    BrowserGetTestability.init = function() {
      core_1.setTestabilityGetter(new BrowserGetTestability());
    };
    BrowserGetTestability.prototype.addToWindow = function(registry) {
      lang_1.global.getAngularTestability = function(elem, findInAncestors) {
        if (findInAncestors === void 0) {
          findInAncestors = true;
        }
        var testability = registry.findTestabilityInTree(elem, findInAncestors);
        if (testability == null) {
          throw new Error('Could not find testability for element.');
        }
        return new PublicTestability(testability);
      };
      lang_1.global.getAllAngularTestabilities = function() {
        var testabilities = registry.getAllTestabilities();
        return testabilities.map(function(testability) {
          return new PublicTestability(testability);
        });
      };
      lang_1.global.getAllAngularRootElements = function() {
        return registry.getAllRootElements();
      };
      var whenAllStable = function(callback) {
        var testabilities = lang_1.global.getAllAngularTestabilities();
        var count = testabilities.length;
        var didWork = false;
        var decrement = function(didWork_) {
          didWork = didWork || didWork_;
          count--;
          if (count == 0) {
            callback(didWork);
          }
        };
        testabilities.forEach(function(testability) {
          testability.whenStable(decrement);
        });
      };
      if (!lang_1.global.frameworkStabilizers) {
        lang_1.global.frameworkStabilizers = collection_1.ListWrapper.createGrowableSize(0);
      }
      lang_1.global.frameworkStabilizers.push(whenAllStable);
    };
    BrowserGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      if (elem == null) {
        return null;
      }
      var t = registry.getTestability(elem);
      if (lang_1.isPresent(t)) {
        return t;
      } else if (!findInAncestors) {
        return null;
      }
      if (dom_adapter_1.getDOM().isShadowRoot(elem)) {
        return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().getHost(elem), true);
      }
      return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().parentElement(elem), true);
    };
    return BrowserGetTestability;
  }());
  exports.BrowserGetTestability = BrowserGetTestability;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/events/hammer_common.js", ["../../facade/collection", "./event_manager"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../../facade/collection');
  var event_manager_1 = $__require('./event_manager');
  var _eventNames = {
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    'press': true,
    'pressup': true,
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    'tap': true
  };
  var HammerGesturesPluginCommon = (function(_super) {
    __extends(HammerGesturesPluginCommon, _super);
    function HammerGesturesPluginCommon() {
      _super.call(this);
    }
    HammerGesturesPluginCommon.prototype.supports = function(eventName) {
      eventName = eventName.toLowerCase();
      return collection_1.StringMapWrapper.contains(_eventNames, eventName);
    };
    return HammerGesturesPluginCommon;
  }(event_manager_1.EventManagerPlugin));
  exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/events/hammer_gestures.js", ["@angular/core", "../../facade/exceptions", "../../facade/lang", "./hammer_common"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var hammer_common_1 = $__require('./hammer_common');
  exports.HAMMER_GESTURE_CONFIG = new core_1.OpaqueToken('HammerGestureConfig');
  var HammerGestureConfig = (function() {
    function HammerGestureConfig() {
      this.events = [];
      this.overrides = {};
    }
    HammerGestureConfig.prototype.buildHammer = function(element) {
      var mc = new Hammer(element);
      mc.get('pinch').set({enable: true});
      mc.get('rotate').set({enable: true});
      for (var eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    };
    HammerGestureConfig.decorators = [{type: core_1.Injectable}];
    return HammerGestureConfig;
  }());
  exports.HammerGestureConfig = HammerGestureConfig;
  var HammerGesturesPlugin = (function(_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin(_config) {
      _super.call(this);
      this._config = _config;
    }
    HammerGesturesPlugin.prototype.supports = function(eventName) {
      if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
        return false;
      if (!lang_1.isPresent(window['Hammer'])) {
        throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
      }
      return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var _this = this;
      var zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      return zone.runOutsideAngular(function() {
        var mc = _this._config.buildHammer(element);
        var callback = function(eventObj) {
          zone.runGuarded(function() {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return function() {
          mc.off(eventName, callback);
        };
      });
    };
    HammerGesturesPlugin.prototype.isCustomEvent = function(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    };
    HammerGesturesPlugin.decorators = [{type: core_1.Injectable}];
    HammerGesturesPlugin.ctorParameters = [{
      type: HammerGestureConfig,
      decorators: [{
        type: core_1.Inject,
        args: [exports.HAMMER_GESTURE_CONFIG]
      }]
    }];
    return HammerGesturesPlugin;
  }(hammer_common_1.HammerGesturesPluginCommon));
  exports.HammerGesturesPlugin = HammerGesturesPlugin;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/events/key_events.js", ["@angular/core", "../../facade/collection", "../../facade/lang", "../dom_adapter", "./event_manager"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var lang_1 = $__require('../../facade/lang');
  var dom_adapter_1 = $__require('../dom_adapter');
  var event_manager_1 = $__require('./event_manager');
  var modifierKeys = ['alt', 'control', 'meta', 'shift'];
  var modifierKeyGetters = {
    'alt': function(event) {
      return event.altKey;
    },
    'control': function(event) {
      return event.ctrlKey;
    },
    'meta': function(event) {
      return event.metaKey;
    },
    'shift': function(event) {
      return event.shiftKey;
    }
  };
  var KeyEventsPlugin = (function(_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin() {
      _super.call(this);
    }
    KeyEventsPlugin.prototype.supports = function(eventName) {
      return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
    };
    KeyEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(function() {
        return dom_adapter_1.getDOM().onAndCancel(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
      });
    };
    KeyEventsPlugin.parseEventName = function(eventName) {
      var parts = eventName.toLowerCase().split('.');
      var domEventName = parts.shift();
      if ((parts.length === 0) || !(lang_1.StringWrapper.equals(domEventName, 'keydown') || lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
        return null;
      }
      var key = KeyEventsPlugin._normalizeKey(parts.pop());
      var fullKey = '';
      modifierKeys.forEach(function(modifierName) {
        if (collection_1.ListWrapper.contains(parts, modifierName)) {
          collection_1.ListWrapper.remove(parts, modifierName);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        return null;
      }
      var result = collection_1.StringMapWrapper.create();
      collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
      collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
      return result;
    };
    KeyEventsPlugin.getEventFullKey = function(event) {
      var fullKey = '';
      var key = dom_adapter_1.getDOM().getEventKey(event);
      key = key.toLowerCase();
      if (lang_1.StringWrapper.equals(key, ' ')) {
        key = 'space';
      } else if (lang_1.StringWrapper.equals(key, '.')) {
        key = 'dot';
      }
      modifierKeys.forEach(function(modifierName) {
        if (modifierName != key) {
          var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    };
    KeyEventsPlugin.eventCallback = function(element, fullKey, handler, zone) {
      return function(event) {
        if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
          zone.runGuarded(function() {
            return handler(event);
          });
        }
      };
    };
    KeyEventsPlugin._normalizeKey = function(keyName) {
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    };
    KeyEventsPlugin.decorators = [{type: core_1.Injectable}];
    KeyEventsPlugin.ctorParameters = [];
    return KeyEventsPlugin;
  }(event_manager_1.EventManagerPlugin));
  exports.KeyEventsPlugin = KeyEventsPlugin;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/security/html_sanitizer.js", ["@angular/core", "../dom/dom_adapter", "./url_sanitizer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var url_sanitizer_1 = $__require('./url_sanitizer');
  var inertElement = null;
  var DOM = null;
  function getInertElement() {
    if (inertElement)
      return inertElement;
    DOM = dom_adapter_1.getDOM();
    var templateEl = DOM.createElement('template');
    if ('content' in templateEl)
      return templateEl;
    var doc = DOM.createHtmlDocument();
    inertElement = DOM.querySelector(doc, 'body');
    if (inertElement == null) {
      var html = DOM.createElement('html', doc);
      inertElement = DOM.createElement('body', doc);
      DOM.appendChild(html, inertElement);
      DOM.appendChild(doc, html);
    }
    return inertElement;
  }
  function tagSet(tags) {
    var res = {};
    for (var _i = 0,
        _a = tags.split(','); _i < _a.length; _i++) {
      var t = _a[_i];
      res[t] = true;
    }
    return res;
  }
  function merge() {
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sets[_i - 0] = arguments[_i];
    }
    var res = {};
    for (var _a = 0,
        sets_1 = sets; _a < sets_1.length; _a++) {
      var s = sets_1[_a];
      for (var v in s) {
        if (s.hasOwnProperty(v))
          res[v] = true;
      }
    }
    return res;
  }
  var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
  var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
  var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
  var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
  var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
  var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
  var SRCSET_ATTRS = tagSet('srcset');
  var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');
  var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
  var SanitizingHtmlSerializer = (function() {
    function SanitizingHtmlSerializer() {
      this.sanitizedSomething = false;
      this.buf = [];
    }
    SanitizingHtmlSerializer.prototype.sanitizeChildren = function(el) {
      var current = el.firstChild;
      while (current) {
        if (DOM.isElementNode(current)) {
          this.startElement(current);
        } else if (DOM.isTextNode(current)) {
          this.chars(DOM.nodeValue(current));
        } else {
          this.sanitizedSomething = true;
        }
        if (DOM.firstChild(current)) {
          current = DOM.firstChild(current);
          continue;
        }
        while (current) {
          if (DOM.isElementNode(current)) {
            this.endElement(current);
          }
          if (DOM.nextSibling(current)) {
            current = DOM.nextSibling(current);
            break;
          }
          current = DOM.parentElement(current);
        }
      }
      return this.buf.join('');
    };
    SanitizingHtmlSerializer.prototype.startElement = function(element) {
      var _this = this;
      var tagName = DOM.nodeName(element).toLowerCase();
      if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
        this.sanitizedSomething = true;
        return;
      }
      this.buf.push('<');
      this.buf.push(tagName);
      DOM.attributeMap(element).forEach(function(value, attrName) {
        var lower = attrName.toLowerCase();
        if (!VALID_ATTRS.hasOwnProperty(lower)) {
          _this.sanitizedSomething = true;
          return;
        }
        if (URI_ATTRS[lower])
          value = url_sanitizer_1.sanitizeUrl(value);
        if (SRCSET_ATTRS[lower])
          value = url_sanitizer_1.sanitizeSrcset(value);
        _this.buf.push(' ');
        _this.buf.push(attrName);
        _this.buf.push('="');
        _this.buf.push(encodeEntities(value));
        _this.buf.push('"');
      });
      this.buf.push('>');
    };
    SanitizingHtmlSerializer.prototype.endElement = function(current) {
      var tagName = DOM.nodeName(current).toLowerCase();
      if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
        this.buf.push('</');
        this.buf.push(tagName);
        this.buf.push('>');
      }
    };
    SanitizingHtmlSerializer.prototype.chars = function(chars) {
      this.buf.push(encodeEntities(chars));
    };
    return SanitizingHtmlSerializer;
  }());
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  function encodeEntities(value) {
    return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(match) {
      var hi = match.charCodeAt(0);
      var low = match.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
      return '&#' + match.charCodeAt(0) + ';';
    }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  function stripCustomNsAttrs(el) {
    DOM.attributeMap(el).forEach(function(_, attrName) {
      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
        DOM.removeAttribute(el, attrName);
      }
    });
    for (var _i = 0,
        _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
      var n = _a[_i];
      if (DOM.isElementNode(n))
        stripCustomNsAttrs(n);
    }
  }
  function sanitizeHtml(unsafeHtmlInput) {
    try {
      var containerEl = getInertElement();
      var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
      var mXSSAttempts = 5;
      var parsedHtml = unsafeHtml;
      do {
        if (mXSSAttempts === 0) {
          throw new Error('Failed to sanitize html because the input is unstable');
        }
        mXSSAttempts--;
        unsafeHtml = parsedHtml;
        DOM.setInnerHTML(containerEl, unsafeHtml);
        if (DOM.defaultDoc().documentMode) {
          stripCustomNsAttrs(containerEl);
        }
        parsedHtml = DOM.getInnerHTML(containerEl);
      } while (unsafeHtml !== parsedHtml);
      var sanitizer = new SanitizingHtmlSerializer();
      var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
      var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
      for (var _i = 0,
          _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
        var child = _a[_i];
        DOM.removeChild(parent_1, child);
      }
      if (core_1.isDevMode() && sanitizer.sanitizedSomething) {
        DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
      }
      return safeHtml;
    } catch (e) {
      inertElement = null;
      throw e;
    }
  }
  exports.sanitizeHtml = sanitizeHtml;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/security/style_sanitizer.js", ["@angular/core", "../dom/dom_adapter", "./url_sanitizer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var url_sanitizer_1 = $__require('./url_sanitizer');
  var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
  var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
  var COLOR_FNS = '(?:rgb|hsl)a?';
  var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
  var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + ")" + FN_ARGS + ")$", 'g');
  var URL_RE = /^url\(([^)]+)\)$/;
  function hasBalancedQuotes(value) {
    var outsideSingle = true;
    var outsideDouble = true;
    for (var i = 0; i < value.length; i++) {
      var c = value.charAt(i);
      if (c === '\'' && outsideDouble) {
        outsideSingle = !outsideSingle;
      } else if (c === '"' && outsideSingle) {
        outsideDouble = !outsideDouble;
      }
    }
    return outsideSingle && outsideDouble;
  }
  function sanitizeStyle(value) {
    value = String(value).trim();
    if (!value)
      return '';
    var urlMatch = value.match(URL_RE);
    if ((urlMatch && url_sanitizer_1.sanitizeUrl(urlMatch[1]) === urlMatch[1]) || value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
      return value;
    }
    if (core_1.isDevMode()) {
      dom_adapter_1.getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
    }
    return 'unsafe';
  }
  exports.sanitizeStyle = sanitizeStyle;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/security/url_sanitizer.js", ["@angular/core", "../dom/dom_adapter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../dom/dom_adapter');
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  var SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  function sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
      return url;
    if (core_1.isDevMode()) {
      dom_adapter_1.getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
    }
    return 'unsafe:' + url;
  }
  exports.sanitizeUrl = sanitizeUrl;
  function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(',').map(function(srcset) {
      return sanitizeUrl(srcset.trim());
    }).join(', ');
  }
  exports.sanitizeSrcset = sanitizeSrcset;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/security/dom_sanitization_service.js", ["@angular/core", "./html_sanitizer", "./style_sanitizer", "./url_sanitizer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  exports.SecurityContext = core_1.SecurityContext;
  var html_sanitizer_1 = $__require('./html_sanitizer');
  var style_sanitizer_1 = $__require('./style_sanitizer');
  var url_sanitizer_1 = $__require('./url_sanitizer');
  var DomSanitizationService = (function() {
    function DomSanitizationService() {}
    return DomSanitizationService;
  }());
  exports.DomSanitizationService = DomSanitizationService;
  var DomSanitizationServiceImpl = (function(_super) {
    __extends(DomSanitizationServiceImpl, _super);
    function DomSanitizationServiceImpl() {
      _super.apply(this, arguments);
    }
    DomSanitizationServiceImpl.prototype.sanitize = function(ctx, value) {
      if (value == null)
        return null;
      switch (ctx) {
        case core_1.SecurityContext.NONE:
          return value;
        case core_1.SecurityContext.HTML:
          if (value instanceof SafeHtmlImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'HTML');
          return html_sanitizer_1.sanitizeHtml(String(value));
        case core_1.SecurityContext.STYLE:
          if (value instanceof SafeStyleImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Style');
          return style_sanitizer_1.sanitizeStyle(value);
        case core_1.SecurityContext.SCRIPT:
          if (value instanceof SafeScriptImpl)
            return value.changingThisBreaksApplicationSecurity;
          this.checkNotSafeValue(value, 'Script');
          throw new Error('unsafe value used in a script context');
        case core_1.SecurityContext.URL:
          if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
            return value.changingThisBreaksApplicationSecurity;
          }
          this.checkNotSafeValue(value, 'URL');
          return url_sanitizer_1.sanitizeUrl(String(value));
        case core_1.SecurityContext.RESOURCE_URL:
          if (value instanceof SafeResourceUrlImpl) {
            return value.changingThisBreaksApplicationSecurity;
          }
          this.checkNotSafeValue(value, 'ResourceURL');
          throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
        default:
          throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
      }
    };
    DomSanitizationServiceImpl.prototype.checkNotSafeValue = function(value, expectedType) {
      if (value instanceof SafeValueImpl) {
        throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") + "(see http://g.co/ng/security#xss)");
      }
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustHtml = function(value) {
      return new SafeHtmlImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustStyle = function(value) {
      return new SafeStyleImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustScript = function(value) {
      return new SafeScriptImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustUrl = function(value) {
      return new SafeUrlImpl(value);
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustResourceUrl = function(value) {
      return new SafeResourceUrlImpl(value);
    };
    DomSanitizationServiceImpl.decorators = [{type: core_1.Injectable}];
    return DomSanitizationServiceImpl;
  }(DomSanitizationService));
  exports.DomSanitizationServiceImpl = DomSanitizationServiceImpl;
  var SafeValueImpl = (function() {
    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    SafeValueImpl.prototype.toString = function() {
      return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) + " (see http://g.co/ng/security#xss)";
    };
    return SafeValueImpl;
  }());
  var SafeHtmlImpl = (function(_super) {
    __extends(SafeHtmlImpl, _super);
    function SafeHtmlImpl() {
      _super.apply(this, arguments);
    }
    SafeHtmlImpl.prototype.getTypeName = function() {
      return 'HTML';
    };
    return SafeHtmlImpl;
  }(SafeValueImpl));
  var SafeStyleImpl = (function(_super) {
    __extends(SafeStyleImpl, _super);
    function SafeStyleImpl() {
      _super.apply(this, arguments);
    }
    SafeStyleImpl.prototype.getTypeName = function() {
      return 'Style';
    };
    return SafeStyleImpl;
  }(SafeValueImpl));
  var SafeScriptImpl = (function(_super) {
    __extends(SafeScriptImpl, _super);
    function SafeScriptImpl() {
      _super.apply(this, arguments);
    }
    SafeScriptImpl.prototype.getTypeName = function() {
      return 'Script';
    };
    return SafeScriptImpl;
  }(SafeValueImpl));
  var SafeUrlImpl = (function(_super) {
    __extends(SafeUrlImpl, _super);
    function SafeUrlImpl() {
      _super.apply(this, arguments);
    }
    SafeUrlImpl.prototype.getTypeName = function() {
      return 'URL';
    };
    return SafeUrlImpl;
  }(SafeValueImpl));
  var SafeResourceUrlImpl = (function(_super) {
    __extends(SafeResourceUrlImpl, _super);
    function SafeResourceUrlImpl() {
      _super.apply(this, arguments);
    }
    SafeResourceUrlImpl.prototype.getTypeName = function() {
      return 'ResourceURL';
    };
    return SafeResourceUrlImpl;
  }(SafeValueImpl));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/browser.js", ["@angular/common", "@angular/core", "../core_private", "../src/dom/animation_driver", "../src/dom/web_animations_driver", "./browser/browser_adapter", "./browser/location/browser_platform_location", "./browser/testability", "./dom/debug/ng_probe", "./dom/dom_adapter", "./dom/dom_renderer", "./dom/dom_tokens", "./dom/events/dom_events", "./dom/events/event_manager", "./dom/events/hammer_gestures", "./dom/events/key_events", "./dom/shared_styles_host", "./security/dom_sanitization_service"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var common_1 = $__require('@angular/common');
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var animation_driver_1 = $__require('../src/dom/animation_driver');
  var web_animations_driver_1 = $__require('../src/dom/web_animations_driver');
  var browser_adapter_1 = $__require('./browser/browser_adapter');
  var browser_platform_location_1 = $__require('./browser/location/browser_platform_location');
  var testability_1 = $__require('./browser/testability');
  var ng_probe_1 = $__require('./dom/debug/ng_probe');
  var dom_adapter_1 = $__require('./dom/dom_adapter');
  var dom_renderer_1 = $__require('./dom/dom_renderer');
  var dom_tokens_1 = $__require('./dom/dom_tokens');
  var dom_events_1 = $__require('./dom/events/dom_events');
  var event_manager_1 = $__require('./dom/events/event_manager');
  var hammer_gestures_1 = $__require('./dom/events/hammer_gestures');
  var key_events_1 = $__require('./dom/events/key_events');
  var shared_styles_host_1 = $__require('./dom/shared_styles_host');
  var dom_sanitization_service_1 = $__require('./security/dom_sanitization_service');
  exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
    provide: core_1.PLATFORM_INITIALIZER,
    useValue: initDomAdapter,
    multi: true
  }, {
    provide: common_1.PlatformLocation,
    useClass: browser_platform_location_1.BrowserPlatformLocation
  }];
  exports.BROWSER_PLATFORM_PROVIDERS = [core_1.PLATFORM_COMMON_PROVIDERS, exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS];
  exports.BROWSER_SANITIZATION_PROVIDERS = [{
    provide: core_1.SanitizationService,
    useExisting: dom_sanitization_service_1.DomSanitizationService
  }, {
    provide: dom_sanitization_service_1.DomSanitizationService,
    useClass: dom_sanitization_service_1.DomSanitizationServiceImpl
  }];
  exports.BROWSER_APP_PROVIDERS = [];
  exports.platformBrowser = core_1.createPlatformFactory(core_1.platformCore, 'browser', exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS);
  exports.browserPlatform = exports.platformBrowser;
  function initDomAdapter() {
    browser_adapter_1.BrowserDomAdapter.makeCurrent();
    core_private_1.wtfInit();
    testability_1.BrowserGetTestability.init();
  }
  exports.initDomAdapter = initDomAdapter;
  function _exceptionHandler() {
    return new core_1.ExceptionHandler(dom_adapter_1.getDOM());
  }
  exports._exceptionHandler = _exceptionHandler;
  function _document() {
    return dom_adapter_1.getDOM().defaultDoc();
  }
  exports._document = _document;
  function _resolveDefaultAnimationDriver() {
    if (dom_adapter_1.getDOM().supportsWebAnimation()) {
      return new web_animations_driver_1.WebAnimationsDriver();
    }
    return animation_driver_1.AnimationDriver.NOOP;
  }
  exports._resolveDefaultAnimationDriver = _resolveDefaultAnimationDriver;
  var BrowserModule = (function() {
    function BrowserModule() {}
    BrowserModule.decorators = [{
      type: core_1.NgModule,
      args: [{
        providers: [exports.BROWSER_SANITIZATION_PROVIDERS, {
          provide: core_1.ExceptionHandler,
          useFactory: _exceptionHandler,
          deps: []
        }, {
          provide: dom_tokens_1.DOCUMENT,
          useFactory: _document,
          deps: []
        }, {
          provide: event_manager_1.EVENT_MANAGER_PLUGINS,
          useClass: dom_events_1.DomEventsPlugin,
          multi: true
        }, {
          provide: event_manager_1.EVENT_MANAGER_PLUGINS,
          useClass: key_events_1.KeyEventsPlugin,
          multi: true
        }, {
          provide: event_manager_1.EVENT_MANAGER_PLUGINS,
          useClass: hammer_gestures_1.HammerGesturesPlugin,
          multi: true
        }, {
          provide: hammer_gestures_1.HAMMER_GESTURE_CONFIG,
          useClass: hammer_gestures_1.HammerGestureConfig
        }, {
          provide: dom_renderer_1.DomRootRenderer,
          useClass: dom_renderer_1.DomRootRenderer_
        }, {
          provide: core_1.RootRenderer,
          useExisting: dom_renderer_1.DomRootRenderer
        }, {
          provide: shared_styles_host_1.SharedStylesHost,
          useExisting: shared_styles_host_1.DomSharedStylesHost
        }, {
          provide: animation_driver_1.AnimationDriver,
          useFactory: _resolveDefaultAnimationDriver
        }, shared_styles_host_1.DomSharedStylesHost, core_1.Testability, event_manager_1.EventManager, ng_probe_1.ELEMENT_PROBE_PROVIDERS],
        exports: [common_1.CommonModule, core_1.ApplicationModule]
      }]
    }];
    return BrowserModule;
  }());
  exports.BrowserModule = BrowserModule;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/debug/ng_probe.js", ["@angular/core", "../../../core_private", "../dom_adapter", "../dom_renderer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../../core_private');
  var dom_adapter_1 = $__require('../dom_adapter');
  var dom_renderer_1 = $__require('../dom_renderer');
  var CORE_TOKENS = {
    'ApplicationRef': core_1.ApplicationRef,
    'NgZone': core_1.NgZone
  };
  var INSPECT_GLOBAL_NAME = 'ng.probe';
  var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
  function inspectNativeElement(element) {
    return core_1.getDebugNode(element);
  }
  exports.inspectNativeElement = inspectNativeElement;
  function _createConditionalRootRenderer(rootRenderer) {
    if (core_1.isDevMode()) {
      return _createRootRenderer(rootRenderer);
    }
    return rootRenderer;
  }
  exports._createConditionalRootRenderer = _createConditionalRootRenderer;
  function _createRootRenderer(rootRenderer) {
    dom_adapter_1.getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    dom_adapter_1.getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, CORE_TOKENS);
    return new core_private_1.DebugDomRootRenderer(rootRenderer);
  }
  exports.ELEMENT_PROBE_PROVIDERS = [{
    provide: core_1.RootRenderer,
    useFactory: _createConditionalRootRenderer,
    deps: [dom_renderer_1.DomRootRenderer]
  }];
  exports.ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{
    provide: core_1.RootRenderer,
    useFactory: _createRootRenderer,
    deps: [dom_renderer_1.DomRootRenderer]
  }];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/core_private.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.RenderDebugInfo = core_1.__core_private__.RenderDebugInfo;
  exports.wtfInit = core_1.__core_private__.wtfInit;
  exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;
  exports.VIEW_ENCAPSULATION_VALUES = core_1.__core_private__.VIEW_ENCAPSULATION_VALUES;
  exports.DebugDomRootRenderer = core_1.__core_private__.DebugDomRootRenderer;
  exports.reflector = core_1.__core_private__.reflector;
  exports.NoOpAnimationPlayer = core_1.__core_private__.NoOpAnimationPlayer;
  exports.AnimationPlayer = core_1.__core_private__.AnimationPlayer;
  exports.AnimationSequencePlayer = core_1.__core_private__.AnimationSequencePlayer;
  exports.AnimationGroupPlayer = core_1.__core_private__.AnimationGroupPlayer;
  exports.AnimationKeyframe = core_1.__core_private__.AnimationKeyframe;
  exports.AnimationStyles = core_1.__core_private__.AnimationStyles;
  exports.prepareFinalAnimationStyles = core_1.__core_private__.prepareFinalAnimationStyles;
  exports.balanceAnimationKeyframes = core_1.__core_private__.balanceAnimationKeyframes;
  exports.flattenStyles = core_1.__core_private__.flattenStyles;
  exports.clearStyles = core_1.__core_private__.clearStyles;
  exports.collectAndResolveStyles = core_1.__core_private__.collectAndResolveStyles;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/animation_driver.js", ["../../core_private"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_private_1 = $__require('../../core_private');
  var _NoOpAnimationDriver = (function() {
    function _NoOpAnimationDriver() {}
    _NoOpAnimationDriver.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing) {
      return new core_private_1.NoOpAnimationPlayer();
    };
    return _NoOpAnimationDriver;
  }());
  var AnimationDriver = (function() {
    function AnimationDriver() {}
    AnimationDriver.NOOP = new _NoOpAnimationDriver();
    return AnimationDriver;
  }());
  exports.AnimationDriver = AnimationDriver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/util.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  var DASH_CASE_REGEXP = /-([a-z])/g;
  function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function(m) {
      return '-' + m[1].toLowerCase();
    });
  }
  exports.camelCaseToDashCase = camelCaseToDashCase;
  function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function(m) {
      return m[1].toUpperCase();
    });
  }
  exports.dashCaseToCamelCase = dashCaseToCamelCase;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/dom_renderer.js", ["@angular/core", "../facade/exceptions", "../facade/lang", "./animation_driver", "./dom_adapter", "./dom_tokens", "./events/event_manager", "./shared_styles_host", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var animation_driver_1 = $__require('./animation_driver');
  var dom_adapter_1 = $__require('./dom_adapter');
  var dom_tokens_1 = $__require('./dom_tokens');
  var event_manager_1 = $__require('./events/event_manager');
  var shared_styles_host_1 = $__require('./shared_styles_host');
  var util_1 = $__require('./util');
  var NAMESPACE_URIS = {
    'xlink': 'http://www.w3.org/1999/xlink',
    'svg': 'http://www.w3.org/2000/svg',
    'xhtml': 'http://www.w3.org/1999/xhtml'
  };
  var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
  var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
  var DomRootRenderer = (function() {
    function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
      this.document = document;
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.animationDriver = animationDriver;
      this.registeredComponents = new Map();
    }
    DomRootRenderer.prototype.renderComponent = function(componentProto) {
      var renderer = this.registeredComponents.get(componentProto.id);
      if (lang_1.isBlank(renderer)) {
        renderer = new DomRenderer(this, componentProto, this.animationDriver);
        this.registeredComponents.set(componentProto.id, renderer);
      }
      return renderer;
    };
    return DomRootRenderer;
  }());
  exports.DomRootRenderer = DomRootRenderer;
  var DomRootRenderer_ = (function(_super) {
    __extends(DomRootRenderer_, _super);
    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
      _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);
    }
    DomRootRenderer_.decorators = [{type: core_1.Injectable}];
    DomRootRenderer_.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Inject,
        args: [dom_tokens_1.DOCUMENT]
      }]
    }, {type: event_manager_1.EventManager}, {type: shared_styles_host_1.DomSharedStylesHost}, {type: animation_driver_1.AnimationDriver}];
    return DomRootRenderer_;
  }(DomRootRenderer));
  exports.DomRootRenderer_ = DomRootRenderer_;
  var DomRenderer = (function() {
    function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
      this._rootRenderer = _rootRenderer;
      this.componentProto = componentProto;
      this._animationDriver = _animationDriver;
      this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
      if (componentProto.encapsulation !== core_1.ViewEncapsulation.Native) {
        this._rootRenderer.sharedStylesHost.addStyles(this._styles);
      }
      if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Emulated) {
        this._contentAttr = _shimContentAttribute(componentProto.id);
        this._hostAttr = _shimHostAttribute(componentProto.id);
      } else {
        this._contentAttr = null;
        this._hostAttr = null;
      }
    }
    DomRenderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {
      var el;
      if (lang_1.isString(selectorOrNode)) {
        el = dom_adapter_1.getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
        if (lang_1.isBlank(el)) {
          throw new exceptions_1.BaseException("The selector \"" + selectorOrNode + "\" did not match any elements");
        }
      } else {
        el = selectorOrNode;
      }
      dom_adapter_1.getDOM().clearNodes(el);
      return el;
    };
    DomRenderer.prototype.createElement = function(parent, name, debugInfo) {
      var nsAndName = splitNamespace(name);
      var el = lang_1.isPresent(nsAndName[0]) ? dom_adapter_1.getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) : dom_adapter_1.getDOM().createElement(nsAndName[1]);
      if (lang_1.isPresent(this._contentAttr)) {
        dom_adapter_1.getDOM().setAttribute(el, this._contentAttr, '');
      }
      if (lang_1.isPresent(parent)) {
        dom_adapter_1.getDOM().appendChild(parent, el);
      }
      return el;
    };
    DomRenderer.prototype.createViewRoot = function(hostElement) {
      var nodesParent;
      if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native) {
        nodesParent = dom_adapter_1.getDOM().createShadowRoot(hostElement);
        this._rootRenderer.sharedStylesHost.addHost(nodesParent);
        for (var i = 0; i < this._styles.length; i++) {
          dom_adapter_1.getDOM().appendChild(nodesParent, dom_adapter_1.getDOM().createStyleElement(this._styles[i]));
        }
      } else {
        if (lang_1.isPresent(this._hostAttr)) {
          dom_adapter_1.getDOM().setAttribute(hostElement, this._hostAttr, '');
        }
        nodesParent = hostElement;
      }
      return nodesParent;
    };
    DomRenderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {
      var comment = dom_adapter_1.getDOM().createComment(TEMPLATE_COMMENT_TEXT);
      if (lang_1.isPresent(parentElement)) {
        dom_adapter_1.getDOM().appendChild(parentElement, comment);
      }
      return comment;
    };
    DomRenderer.prototype.createText = function(parentElement, value, debugInfo) {
      var node = dom_adapter_1.getDOM().createTextNode(value);
      if (lang_1.isPresent(parentElement)) {
        dom_adapter_1.getDOM().appendChild(parentElement, node);
      }
      return node;
    };
    DomRenderer.prototype.projectNodes = function(parentElement, nodes) {
      if (lang_1.isBlank(parentElement))
        return;
      appendNodes(parentElement, nodes);
    };
    DomRenderer.prototype.attachViewAfter = function(node, viewRootNodes) {
      moveNodesAfterSibling(node, viewRootNodes);
    };
    DomRenderer.prototype.detachView = function(viewRootNodes) {
      for (var i = 0; i < viewRootNodes.length; i++) {
        dom_adapter_1.getDOM().remove(viewRootNodes[i]);
      }
    };
    DomRenderer.prototype.destroyView = function(hostElement, viewAllNodes) {
      if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native && lang_1.isPresent(hostElement)) {
        this._rootRenderer.sharedStylesHost.removeHost(dom_adapter_1.getDOM().getShadowRoot(hostElement));
      }
    };
    DomRenderer.prototype.listen = function(renderElement, name, callback) {
      return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.listenGlobal = function(target, name, callback) {
      return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      dom_adapter_1.getDOM().setProperty(renderElement, propertyName, propertyValue);
    };
    DomRenderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {
      var attrNs;
      var nsAndName = splitNamespace(attributeName);
      if (lang_1.isPresent(nsAndName[0])) {
        attributeName = nsAndName[0] + ':' + nsAndName[1];
        attrNs = NAMESPACE_URIS[nsAndName[0]];
      }
      if (lang_1.isPresent(attributeValue)) {
        if (lang_1.isPresent(attrNs)) {
          dom_adapter_1.getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
        } else {
          dom_adapter_1.getDOM().setAttribute(renderElement, attributeName, attributeValue);
        }
      } else {
        if (lang_1.isPresent(attrNs)) {
          dom_adapter_1.getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
        } else {
          dom_adapter_1.getDOM().removeAttribute(renderElement, attributeName);
        }
      }
    };
    DomRenderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {
      var dashCasedPropertyName = util_1.camelCaseToDashCase(propertyName);
      if (dom_adapter_1.getDOM().isCommentNode(renderElement)) {
        var existingBindings = lang_1.StringWrapper.replaceAll(dom_adapter_1.getDOM().getText(renderElement), /\n/g, '').match(TEMPLATE_BINDINGS_EXP);
        var parsedBindings = lang_1.Json.parse(existingBindings[1]);
        parsedBindings[dashCasedPropertyName] = propertyValue;
        dom_adapter_1.getDOM().setText(renderElement, lang_1.StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', lang_1.Json.stringify(parsedBindings)));
      } else {
        this.setElementAttribute(renderElement, propertyName, propertyValue);
      }
    };
    DomRenderer.prototype.setElementClass = function(renderElement, className, isAdd) {
      if (isAdd) {
        dom_adapter_1.getDOM().addClass(renderElement, className);
      } else {
        dom_adapter_1.getDOM().removeClass(renderElement, className);
      }
    };
    DomRenderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      if (lang_1.isPresent(styleValue)) {
        dom_adapter_1.getDOM().setStyle(renderElement, styleName, lang_1.stringify(styleValue));
      } else {
        dom_adapter_1.getDOM().removeStyle(renderElement, styleName);
      }
    };
    DomRenderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      dom_adapter_1.getDOM().invoke(renderElement, methodName, args);
    };
    DomRenderer.prototype.setText = function(renderNode, text) {
      dom_adapter_1.getDOM().setText(renderNode, text);
    };
    DomRenderer.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing) {
      return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
    };
    return DomRenderer;
  }());
  exports.DomRenderer = DomRenderer;
  function moveNodesAfterSibling(sibling, nodes) {
    var parent = dom_adapter_1.getDOM().parentElement(sibling);
    if (nodes.length > 0 && lang_1.isPresent(parent)) {
      var nextSibling = dom_adapter_1.getDOM().nextSibling(sibling);
      if (lang_1.isPresent(nextSibling)) {
        for (var i = 0; i < nodes.length; i++) {
          dom_adapter_1.getDOM().insertBefore(nextSibling, nodes[i]);
        }
      } else {
        for (var i = 0; i < nodes.length; i++) {
          dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
        }
      }
    }
  }
  function appendNodes(parent, nodes) {
    for (var i = 0; i < nodes.length; i++) {
      dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
    }
  }
  function decoratePreventDefault(eventHandler) {
    return function(event) {
      var allowDefaultBehavior = eventHandler(event);
      if (allowDefaultBehavior === false) {
        dom_adapter_1.getDOM().preventDefault(event);
      }
    };
  }
  var COMPONENT_REGEX = /%COMP%/g;
  exports.COMPONENT_VARIABLE = '%COMP%';
  exports.HOST_ATTR = "_nghost-" + exports.COMPONENT_VARIABLE;
  exports.CONTENT_ATTR = "_ngcontent-" + exports.COMPONENT_VARIABLE;
  function _shimContentAttribute(componentShortId) {
    return lang_1.StringWrapper.replaceAll(exports.CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
  }
  function _shimHostAttribute(componentShortId) {
    return lang_1.StringWrapper.replaceAll(exports.HOST_ATTR, COMPONENT_REGEX, componentShortId);
  }
  function _flattenStyles(compId, styles, target) {
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      if (lang_1.isArray(style)) {
        _flattenStyles(compId, style, target);
      } else {
        style = lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
        target.push(style);
      }
    }
    return target;
  }
  var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
  function splitNamespace(name) {
    if (name[0] != ':') {
      return [null, name];
    }
    var match = name.match(NS_PREFIX_RE);
    return [match[1], match[2]];
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/base_wrapped_exception.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  exports.BaseWrappedException = BaseWrappedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/exception_handler.js", ["./base_wrapped_exception", "./collection", "./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var collection_1 = $__require('./collection');
  var lang_1 = $__require('./lang');
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join('\n');
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
        this._logger.logError('STACKTRACE:');
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (lang_1.isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (lang_1.isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (lang_1.isPresent(originalStack)) {
        this._logger.logError('ORIGINAL STACKTRACE:');
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (lang_1.isPresent(context)) {
        this._logger.logError('ERROR CONTEXT:');
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
          return null;
        return lang_1.isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  exports.ExceptionHandler = ExceptionHandler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/exceptions.js", ["./base_wrapped_exception", "./exception_handler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var exception_handler_1 = $__require('./exception_handler');
  var exception_handler_2 = $__require('./exception_handler');
  exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = '--';
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  exports.BaseException = BaseException;
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return exception_handler_1.ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(base_wrapped_exception_1.BaseWrappedException));
  exports.WrappedException = WrappedException;
  function makeTypeError(message) {
    return new TypeError(message);
  }
  exports.makeTypeError = makeTypeError;
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  exports.unimplemented = unimplemented;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/events/event_manager.js", ["@angular/core", "../../facade/collection", "../../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  exports.EVENT_MANAGER_PLUGINS = new core_1.OpaqueToken('EventManagerPlugins');
  var EventManager = (function() {
    function EventManager(plugins, _zone) {
      var _this = this;
      this._zone = _zone;
      plugins.forEach(function(p) {
        return p.manager = _this;
      });
      this._plugins = collection_1.ListWrapper.reversed(plugins);
    }
    EventManager.prototype.addEventListener = function(element, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function(target, eventName, handler) {
      var plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function() {
      return this._zone;
    };
    EventManager.prototype._findPluginFor = function(eventName) {
      var plugins = this._plugins;
      for (var i = 0; i < plugins.length; i++) {
        var plugin = plugins[i];
        if (plugin.supports(eventName)) {
          return plugin;
        }
      }
      throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
    };
    EventManager.decorators = [{type: core_1.Injectable}];
    EventManager.ctorParameters = [{
      type: Array,
      decorators: [{
        type: core_1.Inject,
        args: [exports.EVENT_MANAGER_PLUGINS]
      }]
    }, {type: core_1.NgZone}];
    return EventManager;
  }());
  exports.EventManager = EventManager;
  var EventManagerPlugin = (function() {
    function EventManagerPlugin() {}
    EventManagerPlugin.prototype.supports = function(eventName) {
      return false;
    };
    EventManagerPlugin.prototype.addEventListener = function(element, eventName, handler) {
      throw 'not implemented';
    };
    EventManagerPlugin.prototype.addGlobalEventListener = function(element, eventName, handler) {
      throw 'not implemented';
    };
    return EventManagerPlugin;
  }());
  exports.EventManagerPlugin = EventManagerPlugin;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/events/dom_events.js", ["@angular/core", "../dom_adapter", "./event_manager"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var dom_adapter_1 = $__require('../dom_adapter');
  var event_manager_1 = $__require('./event_manager');
  var DomEventsPlugin = (function(_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin() {
      _super.apply(this, arguments);
    }
    DomEventsPlugin.prototype.supports = function(eventName) {
      return true;
    };
    DomEventsPlugin.prototype.addEventListener = function(element, eventName, handler) {
      var zone = this.manager.getZone();
      var outsideHandler = function(event) {
        return zone.runGuarded(function() {
          return handler(event);
        });
      };
      return this.manager.getZone().runOutsideAngular(function() {
        return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler);
      });
    };
    DomEventsPlugin.prototype.addGlobalEventListener = function(target, eventName, handler) {
      var element = dom_adapter_1.getDOM().getGlobalEventTarget(target);
      var zone = this.manager.getZone();
      var outsideHandler = function(event) {
        return zone.runGuarded(function() {
          return handler(event);
        });
      };
      return this.manager.getZone().runOutsideAngular(function() {
        return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler);
      });
    };
    DomEventsPlugin.decorators = [{type: core_1.Injectable}];
    return DomEventsPlugin;
  }(event_manager_1.EventManagerPlugin));
  exports.DomEventsPlugin = DomEventsPlugin;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/collection.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Map = lang_1.global.Map;
  exports.Set = lang_1.global.Set;
  var createMapFromPairs = (function() {
    try {
      if (new exports.Map([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new exports.Map(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new exports.Map();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new exports.Map(new exports.Map())) {
        return function createMapFromMap(m) {
          return new exports.Map(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new exports.Map();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new exports.Map()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new exports.Map()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new exports.Map();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  exports.MapWrapper = MapWrapper;
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).map(function(k) {
        return map[k];
      });
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var _i = 0,
          _a = Object.keys(map); _i < _a.length; _i++) {
        var k = _a[_i];
        callback(map[k], k);
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var _i = 0,
          _a = Object.keys(m1); _i < _a.length; _i++) {
        var k = _a[_i];
        m[k] = m1[k];
      }
      for (var _b = 0,
          _c = Object.keys(m2); _b < _c.length; _b++) {
        var k = _c[_b];
        m[k] = m2[k];
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  exports.StringMapWrapper = StringMapWrapper;
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (lang_1.isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (lang_1.isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  exports.ListWrapper = ListWrapper;
  function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (lang_1.isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
      return false;
    return lang_1.isArray(obj) || (!(obj instanceof exports.Map) && lang_1.getSymbolIterator() in obj);
  }
  exports.isListLikeIterable = isListLikeIterable;
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  exports.areIterablesEqual = areIterablesEqual;
  function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[lang_1.getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  exports.iterateListLike = iterateListLike;
  var createSetFromList = (function() {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new exports.Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new exports.Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  exports.SetWrapper = SetWrapper;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/facade/lang.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  exports.scheduleMicroTask = scheduleMicroTask;
  var _global = globalScope;
  exports.global = _global;
  exports.Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  exports.getTypeNameForDebugging = getTypeNameForDebugging;
  exports.Math = _global.Math;
  exports.Date = _global.Date;
  _global.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  exports.isPresent = isPresent;
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  exports.isBlank = isBlank;
  function isBoolean(obj) {
    return typeof obj === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  exports.isNumber = isNumber;
  function isString(obj) {
    return typeof obj === 'string';
  }
  exports.isString = isString;
  function isFunction(obj) {
    return typeof obj === 'function';
  }
  exports.isFunction = isFunction;
  function isType(obj) {
    return isFunction(obj);
  }
  exports.isType = isType;
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  exports.isStringMap = isStringMap;
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  exports.isStrictStringMap = isStrictStringMap;
  function isPromise(obj) {
    return isPresent(obj) && isFunction(obj.then);
  }
  exports.isPromise = isPromise;
  function isArray(obj) {
    return Array.isArray(obj);
  }
  exports.isArray = isArray;
  function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
  }
  exports.isDate = isDate;
  function noop() {}
  exports.noop = noop;
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf('\n');
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  exports.stringify = stringify;
  function serializeEnum(val) {
    return val;
  }
  exports.serializeEnum = serializeEnum;
  function deserializeEnum(val, values) {
    return val;
  }
  exports.deserializeEnum = deserializeEnum;
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  exports.resolveEnumToken = resolveEnumToken;
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  exports.StringWrapper = StringWrapper;
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join('');
    };
    return StringJoiner;
  }());
  exports.StringJoiner = StringJoiner;
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  exports.NumberParseError = NumberParseError;
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError('Invalid integer literal when parsing ' + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNumeric = function(value) {
      return !isNaN(value - parseFloat(value));
    };
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  exports.NumberWrapper = NumberWrapper;
  exports.RegExp = _global.RegExp;
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    FunctionWrapper.bind = function(fn, scope) {
      return fn.bind(scope);
    };
    return FunctionWrapper;
  }());
  exports.FunctionWrapper = FunctionWrapper;
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  exports.looseIdentical = looseIdentical;
  function getMapKey(value) {
    return value;
  }
  exports.getMapKey = getMapKey;
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  exports.normalizeBlank = normalizeBlank;
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  exports.normalizeBool = normalizeBool;
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  exports.isJsObject = isJsObject;
  function print(obj) {
    console.log(obj);
  }
  exports.print = print;
  function warn(obj) {
    console.warn(obj);
  }
  exports.warn = warn;
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return _global.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return _global.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  exports.Json = Json;
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new exports.Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new exports.Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new exports.Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  exports.DateWrapper = DateWrapper;
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  exports.setValueOnPath = setValueOnPath;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  exports.evalExpression = evalExpression;
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  exports.isPrimitive = isPrimitive;
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  exports.hasConstructor = hasConstructor;
  function escape(s) {
    return _global.encodeURI(s);
  }
  exports.escape = escape;
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  exports.escapeRegExp = escapeRegExp;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/dom_adapter.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var _DOM = null;
  function getDOM() {
    return _DOM;
  }
  exports.getDOM = getDOM;
  function setDOM(adapter) {
    _DOM = adapter;
  }
  exports.setDOM = setDOM;
  function setRootDomAdapter(adapter) {
    if (lang_1.isBlank(_DOM)) {
      _DOM = adapter;
    }
  }
  exports.setRootDomAdapter = setRootDomAdapter;
  var DomAdapter = (function() {
    function DomAdapter() {
      this.xhrType = null;
    }
    DomAdapter.prototype.getXHR = function() {
      return this.xhrType;
    };
    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
      get: function() {
        return this._attrToPropMap;
      },
      set: function(value) {
        this._attrToPropMap = value;
      },
      enumerable: true,
      configurable: true
    });
    ;
    ;
    return DomAdapter;
  }());
  exports.DomAdapter = DomAdapter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/dom_tokens.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.DOCUMENT = new core_1.OpaqueToken('DocumentToken');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/src/dom/shared_styles_host.js", ["@angular/core", "../facade/collection", "./dom_adapter", "./dom_tokens"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var dom_adapter_1 = $__require('./dom_adapter');
  var dom_tokens_1 = $__require('./dom_tokens');
  var SharedStylesHost = (function() {
    function SharedStylesHost() {
      this._styles = [];
      this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function(styles) {
      var _this = this;
      var additions = [];
      styles.forEach(function(style) {
        if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
          _this._stylesSet.add(style);
          _this._styles.push(style);
          additions.push(style);
        }
      });
      this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function(additions) {};
    SharedStylesHost.prototype.getAllStyles = function() {
      return this._styles;
    };
    SharedStylesHost.decorators = [{type: core_1.Injectable}];
    SharedStylesHost.ctorParameters = [];
    return SharedStylesHost;
  }());
  exports.SharedStylesHost = SharedStylesHost;
  var DomSharedStylesHost = (function(_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(doc) {
      _super.call(this);
      this._hostNodes = new Set();
      this._hostNodes.add(doc.head);
    }
    DomSharedStylesHost.prototype._addStylesToHost = function(styles, host) {
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        dom_adapter_1.getDOM().appendChild(host, dom_adapter_1.getDOM().createStyleElement(style));
      }
    };
    DomSharedStylesHost.prototype.addHost = function(hostNode) {
      this._addStylesToHost(this._styles, hostNode);
      this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function(hostNode) {
      collection_1.SetWrapper.delete(this._hostNodes, hostNode);
    };
    DomSharedStylesHost.prototype.onStylesAdded = function(additions) {
      var _this = this;
      this._hostNodes.forEach(function(hostNode) {
        _this._addStylesToHost(additions, hostNode);
      });
    };
    DomSharedStylesHost.decorators = [{type: core_1.Injectable}];
    DomSharedStylesHost.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Inject,
        args: [dom_tokens_1.DOCUMENT]
      }]
    }];
    return DomSharedStylesHost;
  }(SharedStylesHost));
  exports.DomSharedStylesHost = DomSharedStylesHost;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/private_export.js", ["./src/browser", "./src/dom/debug/ng_probe", "./src/dom/dom_adapter", "./src/dom/dom_renderer", "./src/dom/events/dom_events", "./src/dom/shared_styles_host"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var browser = $__require('./src/browser');
  var ng_proble = $__require('./src/dom/debug/ng_probe');
  var dom_adapter = $__require('./src/dom/dom_adapter');
  var dom_renderer = $__require('./src/dom/dom_renderer');
  var dom_events = $__require('./src/dom/events/dom_events');
  var shared_styles_host = $__require('./src/dom/shared_styles_host');
  exports.__platform_browser_private__ = {
    DomAdapter: dom_adapter.DomAdapter,
    getDOM: dom_adapter.getDOM,
    setRootDomAdapter: dom_adapter.setRootDomAdapter,
    DomRootRenderer: dom_renderer.DomRootRenderer,
    DomRootRenderer_: dom_renderer.DomRootRenderer_,
    DomSharedStylesHost: shared_styles_host.DomSharedStylesHost,
    SharedStylesHost: shared_styles_host.SharedStylesHost,
    ELEMENT_PROBE_PROVIDERS: ng_proble.ELEMENT_PROBE_PROVIDERS,
    DomEventsPlugin: dom_events.DomEventsPlugin,
    initDomAdapter: browser.initDomAdapter,
    INTERNAL_BROWSER_PLATFORM_PROVIDERS: browser.INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser/index.js", ["./src/browser", "./src/browser/location/browser_platform_location", "./src/browser/title", "./src/browser/tools/tools", "./src/dom/animation_driver", "./src/dom/debug/by", "./src/dom/dom_tokens", "./src/dom/events/event_manager", "./src/dom/events/hammer_gestures", "./src/security/dom_sanitization_service", "./src/web_workers/shared/client_message_broker", "./src/web_workers/shared/serializer", "./src/web_workers/shared/service_message_broker", "./src/web_workers/shared/message_bus", "./src/web_workers/worker/location_providers", "./src/web_workers/ui/location_providers", "./src/worker_render", "./src/worker_app", "./private_export"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  var browser_1 = $__require('./src/browser');
  exports.BROWSER_APP_PROVIDERS = browser_1.BROWSER_APP_PROVIDERS;
  exports.BROWSER_PLATFORM_PROVIDERS = browser_1.BROWSER_PLATFORM_PROVIDERS;
  exports.BROWSER_SANITIZATION_PROVIDERS = browser_1.BROWSER_SANITIZATION_PROVIDERS;
  exports.BrowserModule = browser_1.BrowserModule;
  exports.browserPlatform = browser_1.browserPlatform;
  exports.platformBrowser = browser_1.platformBrowser;
  var browser_platform_location_1 = $__require('./src/browser/location/browser_platform_location');
  exports.BrowserPlatformLocation = browser_platform_location_1.BrowserPlatformLocation;
  var title_1 = $__require('./src/browser/title');
  exports.Title = title_1.Title;
  var tools_1 = $__require('./src/browser/tools/tools');
  exports.disableDebugTools = tools_1.disableDebugTools;
  exports.enableDebugTools = tools_1.enableDebugTools;
  var animation_driver_1 = $__require('./src/dom/animation_driver');
  exports.AnimationDriver = animation_driver_1.AnimationDriver;
  var by_1 = $__require('./src/dom/debug/by');
  exports.By = by_1.By;
  var dom_tokens_1 = $__require('./src/dom/dom_tokens');
  exports.DOCUMENT = dom_tokens_1.DOCUMENT;
  var event_manager_1 = $__require('./src/dom/events/event_manager');
  exports.EVENT_MANAGER_PLUGINS = event_manager_1.EVENT_MANAGER_PLUGINS;
  exports.EventManager = event_manager_1.EventManager;
  var hammer_gestures_1 = $__require('./src/dom/events/hammer_gestures');
  exports.HAMMER_GESTURE_CONFIG = hammer_gestures_1.HAMMER_GESTURE_CONFIG;
  exports.HammerGestureConfig = hammer_gestures_1.HammerGestureConfig;
  var dom_sanitization_service_1 = $__require('./src/security/dom_sanitization_service');
  exports.DomSanitizationService = dom_sanitization_service_1.DomSanitizationService;
  var client_message_broker_1 = $__require('./src/web_workers/shared/client_message_broker');
  exports.ClientMessageBroker = client_message_broker_1.ClientMessageBroker;
  exports.ClientMessageBrokerFactory = client_message_broker_1.ClientMessageBrokerFactory;
  exports.FnArg = client_message_broker_1.FnArg;
  exports.UiArguments = client_message_broker_1.UiArguments;
  var serializer_1 = $__require('./src/web_workers/shared/serializer');
  exports.PRIMITIVE = serializer_1.PRIMITIVE;
  var service_message_broker_1 = $__require('./src/web_workers/shared/service_message_broker');
  exports.ReceivedMessage = service_message_broker_1.ReceivedMessage;
  exports.ServiceMessageBroker = service_message_broker_1.ServiceMessageBroker;
  exports.ServiceMessageBrokerFactory = service_message_broker_1.ServiceMessageBrokerFactory;
  __export($__require('./src/web_workers/shared/message_bus'));
  var location_providers_1 = $__require('./src/web_workers/worker/location_providers');
  exports.WORKER_APP_LOCATION_PROVIDERS = location_providers_1.WORKER_APP_LOCATION_PROVIDERS;
  var location_providers_2 = $__require('./src/web_workers/ui/location_providers');
  exports.WORKER_UI_LOCATION_PROVIDERS = location_providers_2.WORKER_UI_LOCATION_PROVIDERS;
  __export($__require('./src/worker_render'));
  __export($__require('./src/worker_app'));
  __export($__require('./private_export'));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/platform_browser_private.js", ["@angular/platform-browser"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var platform_browser_1 = $__require('@angular/platform-browser');
  exports.INTERNAL_BROWSER_PLATFORM_PROVIDERS = platform_browser_1.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;
  exports.getDOM = platform_browser_1.__platform_browser_private__.getDOM;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/platform_providers.js", ["@angular/compiler", "@angular/core", "../platform_browser_private", "./xhr/xhr_impl"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var compiler_1 = $__require('@angular/compiler');
  var core_1 = $__require('@angular/core');
  var platform_browser_private_1 = $__require('../platform_browser_private');
  var xhr_impl_1 = $__require('./xhr/xhr_impl');
  exports.INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [platform_browser_private_1.INTERNAL_BROWSER_PLATFORM_PROVIDERS, {
    provide: core_1.COMPILER_OPTIONS,
    useValue: {providers: [{
        provide: compiler_1.XHR,
        useClass: xhr_impl_1.XHRImpl
      }]},
    multi: true
  }];
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/facade/base_wrapped_exception.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  exports.BaseWrappedException = BaseWrappedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/facade/collection.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Map = lang_1.global.Map;
  exports.Set = lang_1.global.Set;
  var createMapFromPairs = (function() {
    try {
      if (new exports.Map([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new exports.Map(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new exports.Map();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new exports.Map(new exports.Map())) {
        return function createMapFromMap(m) {
          return new exports.Map(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new exports.Map();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new exports.Map()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new exports.Map()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new exports.Map();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  exports.MapWrapper = MapWrapper;
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).map(function(k) {
        return map[k];
      });
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var _i = 0,
          _a = Object.keys(map); _i < _a.length; _i++) {
        var k = _a[_i];
        callback(map[k], k);
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var _i = 0,
          _a = Object.keys(m1); _i < _a.length; _i++) {
        var k = _a[_i];
        m[k] = m1[k];
      }
      for (var _b = 0,
          _c = Object.keys(m2); _b < _c.length; _b++) {
        var k = _c[_b];
        m[k] = m2[k];
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  exports.StringMapWrapper = StringMapWrapper;
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (lang_1.isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (lang_1.isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  exports.ListWrapper = ListWrapper;
  function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (lang_1.isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
      return false;
    return lang_1.isArray(obj) || (!(obj instanceof exports.Map) && lang_1.getSymbolIterator() in obj);
  }
  exports.isListLikeIterable = isListLikeIterable;
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  exports.areIterablesEqual = areIterablesEqual;
  function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[lang_1.getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  exports.iterateListLike = iterateListLike;
  var createSetFromList = (function() {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new exports.Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new exports.Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  exports.SetWrapper = SetWrapper;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/facade/exception_handler.js", ["./base_wrapped_exception", "./collection", "./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var collection_1 = $__require('./collection');
  var lang_1 = $__require('./lang');
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join('\n');
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
        this._logger.logError('STACKTRACE:');
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (lang_1.isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (lang_1.isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (lang_1.isPresent(originalStack)) {
        this._logger.logError('ORIGINAL STACKTRACE:');
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (lang_1.isPresent(context)) {
        this._logger.logError('ERROR CONTEXT:');
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
          return null;
        return lang_1.isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  exports.ExceptionHandler = ExceptionHandler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/facade/exceptions.js", ["./base_wrapped_exception", "./exception_handler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var exception_handler_1 = $__require('./exception_handler');
  var exception_handler_2 = $__require('./exception_handler');
  exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = '--';
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  exports.BaseException = BaseException;
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return exception_handler_1.ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(base_wrapped_exception_1.BaseWrappedException));
  exports.WrappedException = WrappedException;
  function makeTypeError(message) {
    return new TypeError(message);
  }
  exports.makeTypeError = makeTypeError;
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  exports.unimplemented = unimplemented;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/xhr/xhr_cache.js", ["@angular/compiler", "../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var compiler_1 = $__require('@angular/compiler');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var CachedXHR = (function(_super) {
    __extends(CachedXHR, _super);
    function CachedXHR() {
      _super.call(this);
      this._cache = lang_1.global.$templateCache;
      if (this._cache == null) {
        throw new exceptions_1.BaseException('CachedXHR: Template cache was not found in $templateCache.');
      }
    }
    CachedXHR.prototype.get = function(url) {
      if (this._cache.hasOwnProperty(url)) {
        return Promise.resolve(this._cache[url]);
      } else {
        return Promise.reject('CachedXHR: Did not find cached template for ' + url);
      }
    };
    return CachedXHR;
  }(compiler_1.XHR));
  exports.CachedXHR = CachedXHR;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/digest.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function digestMessage(message) {
    return strHash(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
  }
  exports.digestMessage = digestMessage;
  function strHash(str) {
    var result = 0;
    for (var i = 0; i < str.length; ++i) {
      result = (31 * result + str.charCodeAt(i)) >>> 0;
    }
    return result.toString(16);
  }
  exports.strHash = strHash;
  var _SerializerVisitor = (function() {
    function _SerializerVisitor() {}
    _SerializerVisitor.prototype.visitText = function(text, context) {
      return text.value;
    };
    _SerializerVisitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      return "[" + container.children.map(function(child) {
        return child.visit(_this);
      }).join(', ') + "]";
    };
    _SerializerVisitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var strCases = Object.keys(icu.cases).map(function(k) {
        return (k + " {" + icu.cases[k].visit(_this) + "}");
      });
      return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
    };
    _SerializerVisitor.prototype.visitTagPlaceholder = function(ph, context) {
      var _this = this;
      return ph.isVoid ? "<ph tag name=\"" + ph.startName + "\"/>" : "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function(child) {
        return child.visit(_this);
      }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
    };
    _SerializerVisitor.prototype.visitPlaceholder = function(ph, context) {
      return "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>";
    };
    _SerializerVisitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
    };
    return _SerializerVisitor;
  }());
  var serializerVisitor = new _SerializerVisitor();
  function serializeNodes(nodes) {
    return nodes.map(function(a) {
      return a.visit(serializerVisitor, null);
    });
  }
  exports.serializeNodes = serializeNodes;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/i18n_ast.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Message = (function() {
    function Message(nodes, placeholders, meaning, description) {
      this.nodes = nodes;
      this.placeholders = placeholders;
      this.meaning = meaning;
      this.description = description;
    }
    return Message;
  }());
  exports.Message = Message;
  var Text = (function() {
    function Text(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Text.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return Text;
  }());
  exports.Text = Text;
  var Container = (function() {
    function Container(children, sourceSpan) {
      this.children = children;
      this.sourceSpan = sourceSpan;
    }
    Container.prototype.visit = function(visitor, context) {
      return visitor.visitContainer(this, context);
    };
    return Container;
  }());
  exports.Container = Container;
  var Icu = (function() {
    function Icu(expression, type, cases, sourceSpan) {
      this.expression = expression;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
    }
    Icu.prototype.visit = function(visitor, context) {
      return visitor.visitIcu(this, context);
    };
    return Icu;
  }());
  exports.Icu = Icu;
  var TagPlaceholder = (function() {
    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
      this.tag = tag;
      this.attrs = attrs;
      this.startName = startName;
      this.closeName = closeName;
      this.children = children;
      this.isVoid = isVoid;
      this.sourceSpan = sourceSpan;
    }
    TagPlaceholder.prototype.visit = function(visitor, context) {
      return visitor.visitTagPlaceholder(this, context);
    };
    return TagPlaceholder;
  }());
  exports.TagPlaceholder = TagPlaceholder;
  var Placeholder = (function() {
    function Placeholder(value, name, sourceSpan) {
      if (name === void 0) {
        name = '';
      }
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    Placeholder.prototype.visit = function(visitor, context) {
      return visitor.visitPlaceholder(this, context);
    };
    return Placeholder;
  }());
  exports.Placeholder = Placeholder;
  var IcuPlaceholder = (function() {
    function IcuPlaceholder(value, name, sourceSpan) {
      if (name === void 0) {
        name = '';
      }
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    IcuPlaceholder.prototype.visit = function(visitor, context) {
      return visitor.visitIcuPlaceholder(this, context);
    };
    return IcuPlaceholder;
  }());
  exports.IcuPlaceholder = IcuPlaceholder;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/serializers/placeholder.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var TAG_TO_PLACEHOLDER_NAMES = {
    'A': 'LINK',
    'B': 'BOLD_TEXT',
    'BR': 'LINE_BREAK',
    'EM': 'EMPHASISED_TEXT',
    'H1': 'HEADING_LEVEL1',
    'H2': 'HEADING_LEVEL2',
    'H3': 'HEADING_LEVEL3',
    'H4': 'HEADING_LEVEL4',
    'H5': 'HEADING_LEVEL5',
    'H6': 'HEADING_LEVEL6',
    'HR': 'HORIZONTAL_RULE',
    'I': 'ITALIC_TEXT',
    'LI': 'LIST_ITEM',
    'LINK': 'MEDIA_LINK',
    'OL': 'ORDERED_LIST',
    'P': 'PARAGRAPH',
    'Q': 'QUOTATION',
    'S': 'STRIKETHROUGH_TEXT',
    'SMALL': 'SMALL_TEXT',
    'SUB': 'SUBSTRIPT',
    'SUP': 'SUPERSCRIPT',
    'TBODY': 'TABLE_BODY',
    'TD': 'TABLE_CELL',
    'TFOOT': 'TABLE_FOOTER',
    'TH': 'TABLE_HEADER_CELL',
    'THEAD': 'TABLE_HEADER',
    'TR': 'TABLE_ROW',
    'TT': 'MONOSPACED_TEXT',
    'U': 'UNDERLINED_TEXT',
    'UL': 'UNORDERED_LIST'
  };
  var PlaceholderRegistry = (function() {
    function PlaceholderRegistry() {
      this._placeHolderNameCounts = {};
      this._signatureToName = {};
    }
    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function(tag, attrs, isVoid) {
      var signature = this._hashTag(tag, attrs, isVoid);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
      var name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
      this._signatureToName[signature] = name;
      return name;
    };
    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function(tag) {
      var signature = this._hashClosingTag(tag);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
      var name = this._generateUniqueName("CLOSE_" + baseName);
      this._signatureToName[signature] = name;
      return name;
    };
    PlaceholderRegistry.prototype.getPlaceholderName = function(name, content) {
      var upperName = name.toUpperCase();
      var signature = "PH: " + upperName + "=" + content;
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      var uniqueName = this._generateUniqueName(upperName);
      this._signatureToName[signature] = uniqueName;
      return uniqueName;
    };
    PlaceholderRegistry.prototype._hashTag = function(tag, attrs, isVoid) {
      var start = "<" + tag;
      var strAttrs = Object.keys(attrs).sort().map(function(name) {
        return (" " + name + "=" + attrs[name]);
      }).join('');
      var end = isVoid ? '/>' : "></" + tag + ">";
      return start + strAttrs + end;
    };
    PlaceholderRegistry.prototype._hashClosingTag = function(tag) {
      return this._hashTag("/" + tag, {}, false);
    };
    PlaceholderRegistry.prototype._generateUniqueName = function(base) {
      var name = base;
      var next = this._placeHolderNameCounts[name];
      if (!next) {
        next = 1;
      } else {
        name += "_" + next;
        next++;
      }
      this._placeHolderNameCounts[base] = next;
      return name;
    };
    return PlaceholderRegistry;
  }());
  exports.PlaceholderRegistry = PlaceholderRegistry;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/i18n_parser.js", ["../expression_parser/lexer", "../expression_parser/parser", "../ml_parser/ast", "../ml_parser/html_tags", "./i18n_ast", "./serializers/placeholder"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lexer_1 = $__require('../expression_parser/lexer');
  var parser_1 = $__require('../expression_parser/parser');
  var html = $__require('../ml_parser/ast');
  var html_tags_1 = $__require('../ml_parser/html_tags');
  var i18n = $__require('./i18n_ast');
  var placeholder_1 = $__require('./serializers/placeholder');
  var _expParser = new parser_1.Parser(new lexer_1.Lexer());
  function createI18nMessageFactory(interpolationConfig) {
    var visitor = new _I18nVisitor(_expParser, interpolationConfig);
    return function(nodes, meaning, description) {
      return visitor.toI18nMessage(nodes, meaning, description);
    };
  }
  exports.createI18nMessageFactory = createI18nMessageFactory;
  var _I18nVisitor = (function() {
    function _I18nVisitor(_expressionParser, _interpolationConfig) {
      this._expressionParser = _expressionParser;
      this._interpolationConfig = _interpolationConfig;
    }
    _I18nVisitor.prototype.toI18nMessage = function(nodes, meaning, description) {
      this._isIcu = nodes.length == 1 && nodes[0] instanceof html.Expansion;
      this._icuDepth = 0;
      this._placeholderRegistry = new placeholder_1.PlaceholderRegistry();
      this._placeholderToContent = {};
      var i18nodes = html.visitAll(this, nodes, {});
      return new i18n.Message(i18nodes, this._placeholderToContent, meaning, description);
    };
    _I18nVisitor.prototype.visitElement = function(el, context) {
      var children = html.visitAll(this, el.children);
      var attrs = {};
      el.attrs.forEach(function(attr) {
        attrs[attr.name] = attr.value;
      });
      var isVoid = html_tags_1.getHtmlTagDefinition(el.name).isVoid;
      var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
      this._placeholderToContent[startPhName] = el.sourceSpan.toString();
      var closePhName = '';
      if (!isVoid) {
        closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
        this._placeholderToContent[closePhName] = "</" + el.name + ">";
      }
      return new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
    };
    _I18nVisitor.prototype.visitAttribute = function(attribute, context) {
      return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
    };
    _I18nVisitor.prototype.visitText = function(text, context) {
      return this._visitTextWithInterpolation(text.value, text.sourceSpan);
    };
    _I18nVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    _I18nVisitor.prototype.visitExpansion = function(icu, context) {
      var _this = this;
      this._icuDepth++;
      var i18nIcuCases = {};
      var i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
      icu.cases.forEach(function(caze) {
        i18nIcuCases[caze.value] = new i18n.Container(caze.expression.map(function(node) {
          return node.visit(_this, {});
        }), caze.expSourceSpan);
      });
      this._icuDepth--;
      if (this._isIcu || this._icuDepth > 0) {
        return i18nIcu;
      }
      var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
      this._placeholderToContent[phName] = icu.sourceSpan.toString();
      return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
    };
    _I18nVisitor.prototype.visitExpansionCase = function(icuCase, context) {
      throw new Error('Unreachable code');
    };
    _I18nVisitor.prototype._visitTextWithInterpolation = function(text, sourceSpan) {
      var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
      if (!splitInterpolation) {
        return new i18n.Text(text, sourceSpan);
      }
      var nodes = [];
      var container = new i18n.Container(nodes, sourceSpan);
      var _a = this._interpolationConfig,
          sDelimiter = _a.start,
          eDelimiter = _a.end;
      for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
        var expression = splitInterpolation.expressions[i];
        var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
        var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
        if (splitInterpolation.strings[i].length) {
          nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));
        }
        nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));
        this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
      }
      var lastStringIdx = splitInterpolation.strings.length - 1;
      if (splitInterpolation.strings[lastStringIdx].length) {
        nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));
      }
      return container;
    };
    return _I18nVisitor;
  }());
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
  function _extractPlaceholderName(input) {
    return input.split(_CUSTOM_PH_EXP)[1];
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/extractor_merger.js", ["../ml_parser/ast", "./digest", "./i18n_ast", "./i18n_parser", "./parse_util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var html = $__require('../ml_parser/ast');
  var digest_1 = $__require('./digest');
  var i18n = $__require('./i18n_ast');
  var i18n_parser_1 = $__require('./i18n_parser');
  var parse_util_1 = $__require('./parse_util');
  var _I18N_ATTR = 'i18n';
  var _I18N_ATTR_PREFIX = 'i18n-';
  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
    var visitor = new _Visitor(implicitTags, implicitAttrs);
    return visitor.extract(nodes, interpolationConfig);
  }
  exports.extractMessages = extractMessages;
  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
    var visitor = new _Visitor(implicitTags, implicitAttrs);
    return visitor.merge(nodes, translations, interpolationConfig);
  }
  exports.mergeTranslations = mergeTranslations;
  var ExtractionResult = (function() {
    function ExtractionResult(messages, errors) {
      this.messages = messages;
      this.errors = errors;
    }
    return ExtractionResult;
  }());
  exports.ExtractionResult = ExtractionResult;
  var _VisitorMode;
  (function(_VisitorMode) {
    _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
    _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  var _Visitor = (function() {
    function _Visitor(_implicitTags, _implicitAttrs) {
      this._implicitTags = _implicitTags;
      this._implicitAttrs = _implicitAttrs;
      this._inI18nNode = false;
      this._depth = 0;
      this._inIcu = false;
    }
    _Visitor.prototype.extract = function(nodes, interpolationConfig) {
      var _this = this;
      this._init(_VisitorMode.Extract, interpolationConfig);
      nodes.forEach(function(node) {
        return node.visit(_this, null);
      });
      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }
      return new ExtractionResult(this._messages, this._errors);
    };
    _Visitor.prototype.merge = function(nodes, translations, interpolationConfig) {
      this._init(_VisitorMode.Merge, interpolationConfig);
      this._translations = translations;
      var wrapper = new html.Element('wrapper', [], nodes, null, null, null);
      var translatedNode = wrapper.visit(this, null);
      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }
      return translatedNode.children;
    };
    _Visitor.prototype.visitExpansionCase = function(icuCase, context) {
      var expression = html.visitAll(this, icuCase.expression, context);
      if (this._mode === _VisitorMode.Merge) {
        return new html.ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
      }
    };
    _Visitor.prototype.visitExpansion = function(icu, context) {
      this._mayBeAddBlockChildren(icu);
      var wasInIcu = this._inIcu;
      if (!this._inIcu) {
        if (this._isInTranslatableSection) {
          this._addMessage([icu]);
        }
        this._inIcu = true;
      }
      var cases = html.visitAll(this, icu.cases, context);
      if (this._mode === _VisitorMode.Merge) {
        icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
      }
      this._inIcu = wasInIcu;
      return icu;
    };
    _Visitor.prototype.visitComment = function(comment, context) {
      var isOpening = _isOpeningComment(comment);
      if (isOpening && this._isInTranslatableSection) {
        this._reportError(comment, 'Could not start a block inside a translatable section');
        return;
      }
      var isClosing = _isClosingComment(comment);
      if (isClosing && !this._inI18nBlock) {
        this._reportError(comment, 'Trying to close an unopened block');
        return;
      }
      if (!this._inI18nNode && !this._inIcu) {
        if (!this._inI18nBlock) {
          if (isOpening) {
            this._inI18nBlock = true;
            this._blockStartDepth = this._depth;
            this._blockChildren = [];
            this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
            this._openTranslatableSection(comment);
          }
        } else {
          if (isClosing) {
            if (this._depth == this._blockStartDepth) {
              this._closeTranslatableSection(comment, this._blockChildren);
              this._inI18nBlock = false;
              var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
              return this._translateMessage(comment, message);
            } else {
              this._reportError(comment, 'I18N blocks should not cross element boundaries');
              return;
            }
          }
        }
      }
    };
    _Visitor.prototype.visitText = function(text, context) {
      if (this._isInTranslatableSection) {
        this._mayBeAddBlockChildren(text);
      }
      return text;
    };
    _Visitor.prototype.visitElement = function(el, context) {
      var _this = this;
      this._mayBeAddBlockChildren(el);
      this._depth++;
      var wasInI18nNode = this._inI18nNode;
      var childNodes;
      var i18nAttr = _getI18nAttr(el);
      var isImplicitI18n = this._implicitTags.some(function(tag) {
        return el.name === tag;
      });
      if (!this._isInTranslatableSection && !this._inIcu) {
        if (i18nAttr) {
          this._inI18nNode = true;
          var message = this._addMessage(el.children, i18nAttr.value);
          childNodes = this._translateMessage(el, message);
        } else if (isImplicitI18n) {
          this._inI18nNode = true;
          var message = this._addMessage(el.children);
          childNodes = this._translateMessage(el, message);
        }
        if (this._mode == _VisitorMode.Extract) {
          var isTranslatable = i18nAttr || isImplicitI18n;
          if (isTranslatable) {
            this._openTranslatableSection(el);
          }
          html.visitAll(this, el.children);
          if (isTranslatable) {
            this._closeTranslatableSection(el, el.children);
          }
        }
        if (this._mode === _VisitorMode.Merge && !i18nAttr && !isImplicitI18n) {
          childNodes = [];
          el.children.forEach(function(child) {
            var visited = child.visit(_this, context);
            if (visited && !_this._isInTranslatableSection) {
              childNodes = childNodes.concat(visited);
            }
          });
        }
      } else {
        if (i18nAttr || isImplicitI18n) {
          this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
        }
        if (this._mode == _VisitorMode.Extract) {
          html.visitAll(this, el.children);
        }
        if (this._mode == _VisitorMode.Merge) {
          childNodes = [];
          el.children.forEach(function(child) {
            var visited = child.visit(_this, context);
            if (visited && !_this._isInTranslatableSection) {
              childNodes = childNodes.concat(visited);
            }
          });
        }
      }
      this._visitAttributesOf(el);
      this._depth--;
      this._inI18nNode = wasInI18nNode;
      if (this._mode === _VisitorMode.Merge) {
        var translatedAttrs = this._translateAttributes(el);
        return new html.Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      }
    };
    _Visitor.prototype.visitAttribute = function(attribute, context) {
      throw new Error('unreachable code');
    };
    _Visitor.prototype._init = function(mode, interpolationConfig) {
      this._mode = mode;
      this._inI18nBlock = false;
      this._inI18nNode = false;
      this._depth = 0;
      this._inIcu = false;
      this._msgCountAtSectionStart = void 0;
      this._errors = [];
      this._messages = [];
      this._createI18nMessage = i18n_parser_1.createI18nMessageFactory(interpolationConfig);
    };
    _Visitor.prototype._visitAttributesOf = function(el) {
      var _this = this;
      var explicitAttrNameToValue = {};
      var implicitAttrNames = this._implicitAttrs[el.name] || [];
      el.attrs.filter(function(attr) {
        return attr.name.startsWith(_I18N_ATTR_PREFIX);
      }).forEach(function(attr) {
        return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;
      });
      el.attrs.forEach(function(attr) {
        if (attr.name in explicitAttrNameToValue) {
          _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
        } else if (implicitAttrNames.some(function(name) {
          return attr.name === name;
        })) {
          _this._addMessage([attr]);
        }
      });
    };
    _Visitor.prototype._addMessage = function(ast, meaningAndDesc) {
      if (ast.length == 0 || ast.length == 1 && ast[0] instanceof html.Attribute && !ast[0].value) {
        return;
      }
      var _a = _splitMeaningAndDesc(meaningAndDesc),
          meaning = _a[0],
          description = _a[1];
      var message = this._createI18nMessage(ast, meaning, description);
      this._messages.push(message);
      return message;
    };
    _Visitor.prototype._translateMessage = function(el, message) {
      if (message && this._mode === _VisitorMode.Merge) {
        var id = digest_1.digestMessage(message);
        var nodes = this._translations.get(id);
        if (nodes) {
          return nodes;
        }
        this._reportError(el, "Translation unavailable for message id=\"" + id + "\"");
      }
      return [];
    };
    _Visitor.prototype._translateAttributes = function(el) {
      var _this = this;
      var attributes = el.attrs;
      var i18nAttributeMeanings = {};
      attributes.forEach(function(attr) {
        if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _splitMeaningAndDesc(attr.value)[0];
        }
      });
      var translatedAttributes = [];
      attributes.forEach(function(attr) {
        if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          return;
        }
        if (i18nAttributeMeanings.hasOwnProperty(attr.name)) {
          var meaning = i18nAttributeMeanings[attr.name];
          var message = _this._createI18nMessage([attr], meaning, '');
          var id = digest_1.digestMessage(message);
          var nodes = _this._translations.get(id);
          if (nodes) {
            if (nodes[0] instanceof html.Text) {
              var value = nodes[0].value;
              translatedAttributes.push(new html.Attribute(attr.name, value, attr.sourceSpan));
            } else {
              _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
            }
          } else {
            _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
          }
        } else {
          translatedAttributes.push(attr);
        }
      });
      return translatedAttributes;
    };
    _Visitor.prototype._mayBeAddBlockChildren = function(node) {
      if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
        this._blockChildren.push(node);
      }
    };
    _Visitor.prototype._openTranslatableSection = function(node) {
      if (this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section start');
      } else {
        this._msgCountAtSectionStart = this._messages.length;
      }
    };
    Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
      get: function() {
        return this._msgCountAtSectionStart !== void 0;
      },
      enumerable: true,
      configurable: true
    });
    _Visitor.prototype._closeTranslatableSection = function(node, directChildren) {
      if (!this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section end');
        return;
      }
      var startIndex = this._msgCountAtSectionStart;
      var significantChildren = directChildren.reduce(function(count, node) {
        return count + (node instanceof html.Comment ? 0 : 1);
      }, 0);
      if (significantChildren == 1) {
        for (var i = this._messages.length - 1; i >= startIndex; i--) {
          var ast = this._messages[i].nodes;
          if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {
            this._messages.splice(i, 1);
            break;
          }
        }
      }
      this._msgCountAtSectionStart = void 0;
    };
    _Visitor.prototype._reportError = function(node, msg) {
      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, msg));
    };
    return _Visitor;
  }());
  function _isOpeningComment(n) {
    return n instanceof html.Comment && n.value && n.value.startsWith('i18n');
  }
  function _isClosingComment(n) {
    return n instanceof html.Comment && n.value && n.value === '/i18n';
  }
  function _getI18nAttr(p) {
    return p.attrs.find(function(attr) {
      return attr.name === _I18N_ATTR;
    }) || null;
  }
  function _splitMeaningAndDesc(i18n) {
    if (!i18n)
      return ['', ''];
    var pipeIndex = i18n.indexOf('|');
    return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/message_bundle.js", ["./digest", "./extractor_merger"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var digest_1 = $__require('./digest');
  var extractor_merger_1 = $__require('./extractor_merger');
  var MessageBundle = (function() {
    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
      this._htmlParser = _htmlParser;
      this._implicitTags = _implicitTags;
      this._implicitAttrs = _implicitAttrs;
      this._messageMap = {};
    }
    MessageBundle.prototype.updateFromTemplate = function(html, url, interpolationConfig) {
      var _this = this;
      var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
      if (htmlParserResult.errors.length) {
        return htmlParserResult.errors;
      }
      var i18nParserResult = extractor_merger_1.extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
      if (i18nParserResult.errors.length) {
        return i18nParserResult.errors;
      }
      i18nParserResult.messages.forEach(function(message) {
        _this._messageMap[digest_1.digestMessage(message)] = message;
      });
    };
    MessageBundle.prototype.write = function(serializer) {
      return serializer.write(this._messageMap);
    };
    return MessageBundle;
  }());
  exports.MessageBundle = MessageBundle;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/serializers/xml_helper.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var _Visitor = (function() {
    function _Visitor() {}
    _Visitor.prototype.visitTag = function(tag) {
      var _this = this;
      var strAttrs = this._serializeAttributes(tag.attrs);
      if (tag.children.length == 0) {
        return "<" + tag.name + strAttrs + "/>";
      }
      var strChildren = tag.children.map(function(node) {
        return node.visit(_this);
      });
      return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
    };
    _Visitor.prototype.visitText = function(text) {
      return text.value;
    };
    _Visitor.prototype.visitDeclaration = function(decl) {
      return "<? xml" + this._serializeAttributes(decl.attrs) + " ?>";
    };
    _Visitor.prototype._serializeAttributes = function(attrs) {
      var strAttrs = Object.keys(attrs).map(function(name) {
        return (name + "=\"" + attrs[name] + "\"");
      }).join(' ');
      return strAttrs.length > 0 ? ' ' + strAttrs : '';
    };
    _Visitor.prototype.visitDoctype = function(doctype) {
      return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
    };
    return _Visitor;
  }());
  var _visitor = new _Visitor();
  function serialize(nodes) {
    return nodes.map(function(node) {
      return node.visit(_visitor);
    }).join('');
  }
  exports.serialize = serialize;
  var Declaration = (function() {
    function Declaration(unescapedAttrs) {
      var _this = this;
      this.attrs = {};
      Object.keys(unescapedAttrs).forEach(function(k) {
        _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
      });
    }
    Declaration.prototype.visit = function(visitor) {
      return visitor.visitDeclaration(this);
    };
    return Declaration;
  }());
  exports.Declaration = Declaration;
  var Doctype = (function() {
    function Doctype(rootTag, dtd) {
      this.rootTag = rootTag;
      this.dtd = dtd;
    }
    ;
    Doctype.prototype.visit = function(visitor) {
      return visitor.visitDoctype(this);
    };
    return Doctype;
  }());
  exports.Doctype = Doctype;
  var Tag = (function() {
    function Tag(name, unescapedAttrs, children) {
      var _this = this;
      if (unescapedAttrs === void 0) {
        unescapedAttrs = {};
      }
      if (children === void 0) {
        children = [];
      }
      this.name = name;
      this.children = children;
      this.attrs = {};
      Object.keys(unescapedAttrs).forEach(function(k) {
        _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
      });
    }
    Tag.prototype.visit = function(visitor) {
      return visitor.visitTag(this);
    };
    return Tag;
  }());
  exports.Tag = Tag;
  var Text = (function() {
    function Text(unescapedValue) {
      this.value = _escapeXml(unescapedValue);
    }
    ;
    Text.prototype.visit = function(visitor) {
      return visitor.visitText(this);
    };
    return Text;
  }());
  exports.Text = Text;
  var _ESCAPED_CHARS = [[/&/g, '&amp;'], [/"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']];
  function _escapeXml(text) {
    return _ESCAPED_CHARS.reduce(function(text, entry) {
      return text.replace(entry[0], entry[1]);
    }, text);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/serializers/xmb.js", ["../../facade/collection", "./xml_helper"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../../facade/collection');
  var xml = $__require('./xml_helper');
  var _MESSAGES_TAG = 'messagebundle';
  var _MESSAGE_TAG = 'msg';
  var _PLACEHOLDER_TAG = 'ph';
  var _EXEMPLE_TAG = 'ex';
  var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
  var Xmb = (function() {
    function Xmb() {}
    Xmb.prototype.write = function(messageMap) {
      var visitor = new _Visitor();
      var rootNode = new xml.Tag(_MESSAGES_TAG);
      rootNode.children.push(new xml.Text('\n'));
      Object.keys(messageMap).forEach(function(id) {
        var message = messageMap[id];
        var attrs = {id: id};
        if (message.description) {
          attrs['desc'] = message.description;
        }
        if (message.meaning) {
          attrs['meaning'] = message.meaning;
        }
        rootNode.children.push(new xml.Text('  '), new xml.Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)), new xml.Text('\n'));
      });
      return xml.serialize([new xml.Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new xml.Text('\n'), new xml.Doctype(_MESSAGES_TAG, _DOCTYPE), new xml.Text('\n'), rootNode]);
    };
    Xmb.prototype.load = function(content, url, placeholders) {
      throw new Error('Unsupported');
    };
    return Xmb;
  }());
  exports.Xmb = Xmb;
  var _Visitor = (function() {
    function _Visitor() {}
    _Visitor.prototype.visitText = function(text, context) {
      return [new xml.Text(text.value)];
    };
    _Visitor.prototype.visitContainer = function(container, context) {
      var _this = this;
      var nodes = [];
      container.children.forEach(function(node) {
        return nodes.push.apply(nodes, node.visit(_this));
      });
      return nodes;
    };
    _Visitor.prototype.visitIcu = function(icu, context) {
      var _this = this;
      var nodes = [new xml.Text("{" + icu.expression + ", " + icu.type + ", ")];
      Object.keys(icu.cases).forEach(function(c) {
        nodes.push.apply(nodes, [new xml.Text(c + " {")].concat(icu.cases[c].visit(_this), [new xml.Text("}")]));
      });
      nodes.push(new xml.Text("}"));
      return nodes;
    };
    _Visitor.prototype.visitTagPlaceholder = function(ph, context) {
      var startEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text("<" + ph.tag + ">")]);
      var startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx]);
      if (ph.isVoid) {
        return [startTagPh];
      }
      var closeEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text("</" + ph.tag + ">")]);
      var closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx]);
      return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
    };
    _Visitor.prototype.visitPlaceholder = function(ph, context) {
      return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name})];
    };
    _Visitor.prototype.visitIcuPlaceholder = function(ph, context) {
      return [new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name})];
    };
    _Visitor.prototype.serialize = function(nodes) {
      var _this = this;
      return collection_1.ListWrapper.flatten(nodes.map(function(node) {
        return node.visit(_this);
      }));
    };
    return _Visitor;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/xml_tags.js", ["./tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var tags_1 = $__require('./tags');
  var XmlTagDefinition = (function() {
    function XmlTagDefinition() {
      this.closedByParent = false;
      this.contentType = tags_1.TagContentType.PARSABLE_DATA;
      this.isVoid = false;
      this.ignoreFirstLf = false;
      this.canSelfClose = true;
    }
    XmlTagDefinition.prototype.requireExtraParent = function(currentParent) {
      return false;
    };
    XmlTagDefinition.prototype.isClosedByChild = function(name) {
      return false;
    };
    return XmlTagDefinition;
  }());
  exports.XmlTagDefinition = XmlTagDefinition;
  var _TAG_DEFINITION = new XmlTagDefinition();
  function getXmlTagDefinition(tagName) {
    return _TAG_DEFINITION;
  }
  exports.getXmlTagDefinition = getXmlTagDefinition;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/xml_parser.js", ["./parser", "./xml_tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var parser_1 = $__require('./parser');
  var xml_tags_1 = $__require('./xml_tags');
  var parser_2 = $__require('./parser');
  exports.ParseTreeResult = parser_2.ParseTreeResult;
  exports.TreeError = parser_2.TreeError;
  var XmlParser = (function(_super) {
    __extends(XmlParser, _super);
    function XmlParser() {
      _super.call(this, xml_tags_1.getXmlTagDefinition);
    }
    XmlParser.prototype.parse = function(source, url, parseExpansionForms) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);
    };
    return XmlParser;
  }(parser_1.Parser));
  exports.XmlParser = XmlParser;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/parse_util.js", ["../parse_util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var parse_util_1 = $__require('../parse_util');
  var I18nError = (function(_super) {
    __extends(I18nError, _super);
    function I18nError(span, msg) {
      _super.call(this, span, msg);
    }
    return I18nError;
  }(parse_util_1.ParseError));
  exports.I18nError = I18nError;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/serializers/xtb.js", ["../../ml_parser/ast", "../../ml_parser/xml_parser", "../parse_util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ml = $__require('../../ml_parser/ast');
  var xml_parser_1 = $__require('../../ml_parser/xml_parser');
  var parse_util_1 = $__require('../parse_util');
  var _TRANSLATIONS_TAG = 'translationbundle';
  var _TRANSLATION_TAG = 'translation';
  var _PLACEHOLDER_TAG = 'ph';
  var Xtb = (function() {
    function Xtb(_htmlParser, _interpolationConfig) {
      this._htmlParser = _htmlParser;
      this._interpolationConfig = _interpolationConfig;
    }
    Xtb.prototype.write = function(messageMap) {
      throw new Error('Unsupported');
    };
    Xtb.prototype.load = function(content, url, placeholders) {
      var _this = this;
      var result = new xml_parser_1.XmlParser().parse(content, url);
      if (result.errors.length) {
        throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
      }
      var _a = new _Serializer().parse(result.rootNodes, placeholders),
          messages = _a.messages,
          errors = _a.errors;
      if (errors.length) {
        throw new Error("xtb parse errors:\n" + errors.join('\n'));
      }
      var messageMap = {};
      var parseErrors = [];
      Object.keys(messages).forEach(function(id) {
        var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
        parseErrors.push.apply(parseErrors, res.errors);
        messageMap[id] = res.rootNodes;
      });
      if (parseErrors.length) {
        throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
      }
      return messageMap;
    };
    return Xtb;
  }());
  exports.Xtb = Xtb;
  var _Serializer = (function() {
    function _Serializer() {}
    _Serializer.prototype.parse = function(nodes, _placeholders) {
      this._messages = {};
      this._bundleDepth = 0;
      this._translationDepth = 0;
      this._errors = [];
      this._placeholders = _placeholders;
      ml.visitAll(this, nodes, null);
      return {
        messages: this._messages,
        errors: this._errors
      };
    };
    _Serializer.prototype.visitElement = function(element, context) {
      switch (element.name) {
        case _TRANSLATIONS_TAG:
          this._bundleDepth++;
          if (this._bundleDepth > 1) {
            this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
          }
          ml.visitAll(this, element.children, null);
          this._bundleDepth--;
          break;
        case _TRANSLATION_TAG:
          this._translationDepth++;
          if (this._translationDepth > 1) {
            this._addError(element, "<" + _TRANSLATION_TAG + "> elements can not be nested");
          }
          var idAttr = element.attrs.find(function(attr) {
            return attr.name === 'id';
          });
          if (!idAttr) {
            this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
          } else {
            this._currentPlaceholders = this._placeholders[idAttr.value] || {};
            this._messages[idAttr.value] = ml.visitAll(this, element.children).join('');
          }
          this._translationDepth--;
          break;
        case _PLACEHOLDER_TAG:
          var nameAttr = element.attrs.find(function(attr) {
            return attr.name === 'name';
          });
          if (!nameAttr) {
            this._addError(element, "<" + _PLACEHOLDER_TAG + "> misses the \"name\" attribute");
          } else {
            if (this._currentPlaceholders.hasOwnProperty(nameAttr.value)) {
              return this._currentPlaceholders[nameAttr.value];
            }
            this._addError(element, "The placeholder \"" + nameAttr.value + "\" does not exists in the source message");
          }
          break;
        default:
          this._addError(element, 'Unexpected tag');
      }
    };
    _Serializer.prototype.visitAttribute = function(attribute, context) {
      throw new Error('unreachable code');
    };
    _Serializer.prototype.visitText = function(text, context) {
      return text.value;
    };
    _Serializer.prototype.visitComment = function(comment, context) {
      return '';
    };
    _Serializer.prototype.visitExpansion = function(expansion, context) {
      var _this = this;
      var strCases = expansion.cases.map(function(c) {
        return c.visit(_this, null);
      });
      return "{" + expansion.switchValue + ", " + expansion.type + ", strCases.join(' ')}";
    };
    _Serializer.prototype.visitExpansionCase = function(expansionCase, context) {
      return expansionCase.value + " {" + ml.visitAll(this, expansionCase.expression, null) + "}";
    };
    _Serializer.prototype._addError = function(node, message) {
      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, message));
    };
    return _Serializer;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/i18n/index.js", ["./message_bundle", "./serializers/xmb", "./serializers/xtb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var message_bundle_1 = $__require('./message_bundle');
  exports.MessageBundle = message_bundle_1.MessageBundle;
  var xmb_1 = $__require('./serializers/xmb');
  exports.Xmb = xmb_1.Xmb;
  var xtb_1 = $__require('./serializers/xtb');
  exports.Xtb = xtb_1.Xtb;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/offline_compiler.js", ["./compile_metadata", "./facade/collection", "./facade/exceptions", "./identifiers", "./output/output_ast", "./view_compiler/view_compiler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var compile_metadata_1 = $__require('./compile_metadata');
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var identifiers_1 = $__require('./identifiers');
  var o = $__require('./output/output_ast');
  var view_compiler_1 = $__require('./view_compiler/view_compiler');
  var SourceModule = (function() {
    function SourceModule(moduleUrl, source) {
      this.moduleUrl = moduleUrl;
      this.source = source;
    }
    return SourceModule;
  }());
  exports.SourceModule = SourceModule;
  var NgModulesSummary = (function() {
    function NgModulesSummary(ngModuleByComponent) {
      this.ngModuleByComponent = ngModuleByComponent;
    }
    return NgModulesSummary;
  }());
  exports.NgModulesSummary = NgModulesSummary;
  var OfflineCompiler = (function() {
    function OfflineCompiler(_metadataResolver, _directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter) {
      this._metadataResolver = _metadataResolver;
      this._directiveNormalizer = _directiveNormalizer;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._ngModuleCompiler = _ngModuleCompiler;
      this._outputEmitter = _outputEmitter;
    }
    OfflineCompiler.prototype.analyzeModules = function(ngModules) {
      var _this = this;
      var ngModuleByComponent = new Map();
      ngModules.forEach(function(ngModule) {
        var ngModuleMeta = _this._metadataResolver.getNgModuleMetadata(ngModule);
        ngModuleMeta.declaredDirectives.forEach(function(dirMeta) {
          if (dirMeta.isComponent) {
            ngModuleByComponent.set(dirMeta.type.runtime, ngModuleMeta);
          }
        });
      });
      return new NgModulesSummary(ngModuleByComponent);
    };
    OfflineCompiler.prototype.clearCache = function() {
      this._directiveNormalizer.clearCache();
      this._metadataResolver.clearCache();
    };
    OfflineCompiler.prototype.compile = function(moduleUrl, ngModulesSummary, components, ngModules) {
      var _this = this;
      var fileSuffix = _splitLastSuffix(moduleUrl)[1];
      var statements = [];
      var exportedVars = [];
      var outputSourceModules = [];
      exportedVars.push.apply(exportedVars, ngModules.map(function(ngModuleType) {
        return _this._compileModule(ngModuleType, statements);
      }));
      return Promise.all(components.map(function(compType) {
        var compMeta = _this._metadataResolver.getDirectiveMetadata(compType);
        var ngModule = ngModulesSummary.ngModuleByComponent.get(compType);
        if (!ngModule) {
          throw new exceptions_1.BaseException("Cannot determine the module for component " + compMeta.type.name + "!");
        }
        return Promise.all([compMeta].concat(ngModule.transitiveModule.directives).map(function(dirMeta) {
          return _this._directiveNormalizer.normalizeDirective(dirMeta).asyncResult;
        })).then(function(normalizedCompWithDirectives) {
          var compMeta = normalizedCompWithDirectives[0];
          var dirMetas = normalizedCompWithDirectives.slice(1);
          _assertComponent(compMeta);
          var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
          stylesCompileResults.externalStylesheets.forEach(function(compiledStyleSheet) {
            outputSourceModules.push(_this._codgenStyles(compiledStyleSheet, fileSuffix));
          });
          exportedVars.push(_this._compileComponentFactory(compMeta, fileSuffix, statements));
          exportedVars.push(_this._compileComponent(compMeta, dirMetas, ngModule.transitiveModule.pipes, ngModule.schemas, stylesCompileResults.componentStylesheet, fileSuffix, statements));
        });
      })).then(function() {
        if (statements.length > 0) {
          outputSourceModules.unshift(_this._codegenSourceModule(_ngfactoryModuleUrl(moduleUrl), statements, exportedVars));
        }
        return outputSourceModules;
      });
    };
    OfflineCompiler.prototype._compileModule = function(ngModuleType, targetStatements) {
      var ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);
      var appCompileResult = this._ngModuleCompiler.compile(ngModule, []);
      appCompileResult.dependencies.forEach(function(dep) {
        dep.placeholder.name = _componentFactoryName(dep.comp);
        dep.placeholder.moduleUrl = _ngfactoryModuleUrl(dep.comp.moduleUrl);
      });
      targetStatements.push.apply(targetStatements, appCompileResult.statements);
      return appCompileResult.ngModuleFactoryVar;
    };
    OfflineCompiler.prototype._compileComponentFactory = function(compMeta, fileSuffix, targetStatements) {
      var hostMeta = compile_metadata_1.createHostComponentMeta(compMeta);
      var hostViewFactoryVar = this._compileComponent(hostMeta, [compMeta], [], [], null, fileSuffix, targetStatements);
      var compFactoryVar = _componentFactoryName(compMeta.type);
      targetStatements.push(o.variable(compFactoryVar).set(o.importExpr(identifiers_1.Identifiers.ComponentFactory, [o.importType(compMeta.type)]).instantiate([o.literal(compMeta.selector), o.variable(hostViewFactoryVar), o.importExpr(compMeta.type)], o.importType(identifiers_1.Identifiers.ComponentFactory, [o.importType(compMeta.type)], [o.TypeModifier.Const]))).toDeclStmt(null, [o.StmtModifier.Final]));
      return compFactoryVar;
    };
    OfflineCompiler.prototype._compileComponent = function(compMeta, directives, pipes, schemas, componentStyles, fileSuffix, targetStatements) {
      var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, schemas, compMeta.type.name);
      var stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);
      var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes);
      if (componentStyles) {
        collection_1.ListWrapper.addAll(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));
      }
      collection_1.ListWrapper.addAll(targetStatements, _resolveViewStatements(viewResult));
      return viewResult.viewFactoryVar;
    };
    OfflineCompiler.prototype._codgenStyles = function(stylesCompileResult, fileSuffix) {
      _resolveStyleStatements(stylesCompileResult, fileSuffix);
      return this._codegenSourceModule(_stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
    };
    OfflineCompiler.prototype._codegenSourceModule = function(moduleUrl, statements, exportedVars) {
      return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
    };
    return OfflineCompiler;
  }());
  exports.OfflineCompiler = OfflineCompiler;
  function _resolveViewStatements(compileResult) {
    compileResult.dependencies.forEach(function(dep) {
      if (dep instanceof view_compiler_1.ViewFactoryDependency) {
        var vfd = dep;
        vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp.moduleUrl);
      } else if (dep instanceof view_compiler_1.ComponentFactoryDependency) {
        var cfd = dep;
        cfd.placeholder.name = _componentFactoryName(cfd.comp);
        cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp.moduleUrl);
      }
    });
    return compileResult.statements;
  }
  function _resolveStyleStatements(compileResult, fileSuffix) {
    compileResult.dependencies.forEach(function(dep) {
      dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);
    });
    return compileResult.statements;
  }
  function _ngfactoryModuleUrl(compUrl) {
    var urlWithSuffix = _splitLastSuffix(compUrl);
    return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
  }
  function _componentFactoryName(comp) {
    return comp.name + "NgFactory";
  }
  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
    return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
  }
  function _assertComponent(meta) {
    if (!meta.isComponent) {
      throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
  }
  function _splitLastSuffix(path) {
    var lastDot = path.lastIndexOf('.');
    if (lastDot !== -1) {
      return [path.substring(0, lastDot), path.substring(lastDot)];
    } else {
      return [path, ''];
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/output_interpreter.js", ["../facade/collection", "../facade/exceptions", "../facade/lang", "./output_ast", "./ts_emitter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var o = $__require('./output_ast');
  var ts_emitter_1 = $__require('./ts_emitter');
  function interpretStatements(statements, resultVar) {
    var stmtsWithReturn = statements.concat([new o.ReturnStatement(o.variable(resultVar))]);
    var ctx = new _ExecutionContext(null, null, null, new Map());
    var visitor = new StatementInterpreter();
    var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
    return lang_1.isPresent(result) ? result.value : null;
  }
  exports.interpretStatements = interpretStatements;
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
    var childCtx = ctx.createChildWihtLocalVars();
    for (var i = 0; i < varNames.length; i++) {
      childCtx.vars.set(varNames[i], varValues[i]);
    }
    var result = visitor.visitAllStatements(statements, childCtx);
    return lang_1.isPresent(result) ? result.value : null;
  }
  var _ExecutionContext = (function() {
    function _ExecutionContext(parent, instance, className, vars) {
      this.parent = parent;
      this.instance = instance;
      this.className = className;
      this.vars = vars;
    }
    _ExecutionContext.prototype.createChildWihtLocalVars = function() {
      return new _ExecutionContext(this, this.instance, this.className, new Map());
    };
    return _ExecutionContext;
  }());
  var ReturnValue = (function() {
    function ReturnValue(value) {
      this.value = value;
    }
    return ReturnValue;
  }());
  function createDynamicClass(_classStmt, _ctx, _visitor) {
    var propertyDescriptors = {};
    _classStmt.getters.forEach(function(getter) {
      propertyDescriptors[getter.name] = {
        configurable: false,
        get: function() {
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
        }
      };
    });
    _classStmt.methods.forEach(function(method) {
      var paramNames = method.params.map(function(param) {
        return param.name;
      });
      propertyDescriptors[method.name] = {
        writable: false,
        configurable: false,
        value: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
          }
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
        }
      };
    });
    var ctorParamNames = _classStmt.constructorMethod.params.map(function(param) {
      return param.name;
    });
    var ctor = function() {
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
      _classStmt.fields.forEach(function(field) {
        _this[field.name] = undefined;
      });
      _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
    };
    var superClass = _classStmt.parent.visitExpression(_visitor, _ctx);
    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
    return ctor;
  }
  var StatementInterpreter = (function() {
    function StatementInterpreter() {}
    StatementInterpreter.prototype.debugAst = function(ast) {
      return ts_emitter_1.debugOutputAstAsTypeScript(ast);
    };
    StatementInterpreter.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
      return null;
    };
    StatementInterpreter.prototype.visitWriteVarExpr = function(expr, ctx) {
      var value = expr.value.visitExpression(this, ctx);
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(expr.name)) {
          currCtx.vars.set(expr.name, value);
          return value;
        }
        currCtx = currCtx.parent;
      }
      throw new exceptions_1.BaseException("Not declared variable " + expr.name);
    };
    StatementInterpreter.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ast.name;
      if (lang_1.isPresent(ast.builtin)) {
        switch (ast.builtin) {
          case o.BuiltinVar.Super:
            return ctx.instance.__proto__;
          case o.BuiltinVar.This:
            return ctx.instance;
          case o.BuiltinVar.CatchError:
            varName = CATCH_ERROR_VAR;
            break;
          case o.BuiltinVar.CatchStack:
            varName = CATCH_STACK_VAR;
            break;
          default:
            throw new exceptions_1.BaseException("Unknown builtin variable " + ast.builtin);
        }
      }
      var currCtx = ctx;
      while (currCtx != null) {
        if (currCtx.vars.has(varName)) {
          return currCtx.vars.get(varName);
        }
        currCtx = currCtx.parent;
      }
      throw new exceptions_1.BaseException("Not declared variable " + varName);
    };
    StatementInterpreter.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var index = expr.index.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      receiver[index] = value;
      return value;
    };
    StatementInterpreter.prototype.visitWritePropExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var value = expr.value.visitExpression(this, ctx);
      receiver[expr.name] = value;
      return value;
    };
    StatementInterpreter.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      var receiver = expr.receiver.visitExpression(this, ctx);
      var args = this.visitAllExpressions(expr.args, ctx);
      var result;
      if (lang_1.isPresent(expr.builtin)) {
        switch (expr.builtin) {
          case o.BuiltinMethod.ConcatArray:
            result = collection_1.ListWrapper.concat(receiver, args[0]);
            break;
          case o.BuiltinMethod.SubscribeObservable:
            result = receiver.subscribe({next: args[0]});
            break;
          case o.BuiltinMethod.bind:
            result = receiver.bind(args[0]);
            break;
          default:
            throw new exceptions_1.BaseException("Unknown builtin method " + expr.builtin);
        }
      } else {
        result = receiver[expr.name].apply(receiver, args);
      }
      return result;
    };
    StatementInterpreter.prototype.visitInvokeFunctionExpr = function(stmt, ctx) {
      var args = this.visitAllExpressions(stmt.args, ctx);
      var fnExpr = stmt.fn;
      if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {
        ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
        return null;
      } else {
        var fn = stmt.fn.visitExpression(this, ctx);
        return fn.apply(null, args);
      }
    };
    StatementInterpreter.prototype.visitReturnStmt = function(stmt, ctx) {
      return new ReturnValue(stmt.value.visitExpression(this, ctx));
    };
    StatementInterpreter.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var clazz = createDynamicClass(stmt, ctx, this);
      ctx.vars.set(stmt.name, clazz);
      return null;
    };
    StatementInterpreter.prototype.visitExpressionStmt = function(stmt, ctx) {
      return stmt.expr.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitIfStmt = function(stmt, ctx) {
      var condition = stmt.condition.visitExpression(this, ctx);
      if (condition) {
        return this.visitAllStatements(stmt.trueCase, ctx);
      } else if (lang_1.isPresent(stmt.falseCase)) {
        return this.visitAllStatements(stmt.falseCase, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitTryCatchStmt = function(stmt, ctx) {
      try {
        return this.visitAllStatements(stmt.bodyStmts, ctx);
      } catch (e) {
        var childCtx = ctx.createChildWihtLocalVars();
        childCtx.vars.set(CATCH_ERROR_VAR, e);
        childCtx.vars.set(CATCH_STACK_VAR, e.stack);
        return this.visitAllStatements(stmt.catchStmts, childCtx);
      }
    };
    StatementInterpreter.prototype.visitThrowStmt = function(stmt, ctx) {
      throw stmt.error.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCommentStmt = function(stmt, context) {
      return null;
    };
    StatementInterpreter.prototype.visitInstantiateExpr = function(ast, ctx) {
      var args = this.visitAllExpressions(ast.args, ctx);
      var clazz = ast.classExpr.visitExpression(this, ctx);
      return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
    };
    StatementInterpreter.prototype.visitLiteralExpr = function(ast, ctx) {
      return ast.value;
    };
    StatementInterpreter.prototype.visitExternalExpr = function(ast, ctx) {
      return ast.value.runtime;
    };
    StatementInterpreter.prototype.visitConditionalExpr = function(ast, ctx) {
      if (ast.condition.visitExpression(this, ctx)) {
        return ast.trueCase.visitExpression(this, ctx);
      } else if (lang_1.isPresent(ast.falseCase)) {
        return ast.falseCase.visitExpression(this, ctx);
      }
      return null;
    };
    StatementInterpreter.prototype.visitNotExpr = function(ast, ctx) {
      return !ast.condition.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCastExpr = function(ast, ctx) {
      return ast.value.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitFunctionExpr = function(ast, ctx) {
      var paramNames = ast.params.map(function(param) {
        return param.name;
      });
      return _declareFn(paramNames, ast.statements, ctx, this);
    };
    StatementInterpreter.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      var paramNames = stmt.params.map(function(param) {
        return param.name;
      });
      ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
      return null;
    };
    StatementInterpreter.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var _this = this;
      var lhs = function() {
        return ast.lhs.visitExpression(_this, ctx);
      };
      var rhs = function() {
        return ast.rhs.visitExpression(_this, ctx);
      };
      switch (ast.operator) {
        case o.BinaryOperator.Equals:
          return lhs() == rhs();
        case o.BinaryOperator.Identical:
          return lhs() === rhs();
        case o.BinaryOperator.NotEquals:
          return lhs() != rhs();
        case o.BinaryOperator.NotIdentical:
          return lhs() !== rhs();
        case o.BinaryOperator.And:
          return lhs() && rhs();
        case o.BinaryOperator.Or:
          return lhs() || rhs();
        case o.BinaryOperator.Plus:
          return lhs() + rhs();
        case o.BinaryOperator.Minus:
          return lhs() - rhs();
        case o.BinaryOperator.Divide:
          return lhs() / rhs();
        case o.BinaryOperator.Multiply:
          return lhs() * rhs();
        case o.BinaryOperator.Modulo:
          return lhs() % rhs();
        case o.BinaryOperator.Lower:
          return lhs() < rhs();
        case o.BinaryOperator.LowerEquals:
          return lhs() <= rhs();
        case o.BinaryOperator.Bigger:
          return lhs() > rhs();
        case o.BinaryOperator.BiggerEquals:
          return lhs() >= rhs();
        default:
          throw new exceptions_1.BaseException("Unknown operator " + ast.operator);
      }
    };
    StatementInterpreter.prototype.visitReadPropExpr = function(ast, ctx) {
      var result;
      var receiver = ast.receiver.visitExpression(this, ctx);
      result = receiver[ast.name];
      return result;
    };
    StatementInterpreter.prototype.visitReadKeyExpr = function(ast, ctx) {
      var receiver = ast.receiver.visitExpression(this, ctx);
      var prop = ast.index.visitExpression(this, ctx);
      return receiver[prop];
    };
    StatementInterpreter.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      return this.visitAllExpressions(ast.entries, ctx);
    };
    StatementInterpreter.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      var result = {};
      ast.entries.forEach(function(entry) {
        return result[entry[0]] = entry[1].visitExpression(_this, ctx);
      });
      return result;
    };
    StatementInterpreter.prototype.visitAllExpressions = function(expressions, ctx) {
      var _this = this;
      return expressions.map(function(expr) {
        return expr.visitExpression(_this, ctx);
      });
    };
    StatementInterpreter.prototype.visitAllStatements = function(statements, ctx) {
      for (var i = 0; i < statements.length; i++) {
        var stmt = statements[i];
        var val = stmt.visitStatement(this, ctx);
        if (val instanceof ReturnValue) {
          return val;
        }
      }
      return null;
    };
    return StatementInterpreter;
  }());
  function _declareFn(varNames, statements, ctx, visitor) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
    };
  }
  var CATCH_ERROR_VAR = 'error';
  var CATCH_STACK_VAR = 'stack';
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/abstract_js_emitter.js", ["../facade/exceptions", "../facade/lang", "./abstract_emitter", "./output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var abstract_emitter_1 = $__require('./abstract_emitter');
  var o = $__require('./output_ast');
  var AbstractJsEmitterVisitor = (function(_super) {
    __extends(AbstractJsEmitterVisitor, _super);
    function AbstractJsEmitterVisitor() {
      _super.call(this, false);
    }
    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      this._visitClassConstructor(stmt, ctx);
      if (lang_1.isPresent(stmt.parent)) {
        ctx.print(stmt.name + ".prototype = Object.create(");
        stmt.parent.visitExpression(this, ctx);
        ctx.println(".prototype);");
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(stmt, getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(stmt, method, ctx);
      });
      ctx.popClass();
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print("function " + stmt.name + "(");
      if (lang_1.isPresent(stmt.constructorMethod)) {
        this._visitParams(stmt.constructorMethod.params, ctx);
      }
      ctx.println(") {");
      ctx.incIndent();
      if (lang_1.isPresent(stmt.constructorMethod)) {
        if (stmt.constructorMethod.body.length > 0) {
          ctx.println("var self = this;");
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
        }
      }
      ctx.decIndent();
      ctx.println("}");
    };
    AbstractJsEmitterVisitor.prototype._visitClassGetter = function(stmt, getter, ctx) {
      ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
      ctx.incIndent();
      if (getter.body.length > 0) {
        ctx.println("var self = this;");
        this.visitAllStatements(getter.body, ctx);
      }
      ctx.decIndent();
      ctx.println("}});");
    };
    AbstractJsEmitterVisitor.prototype._visitClassMethod = function(stmt, method, ctx) {
      ctx.print(stmt.name + ".prototype." + method.name + " = function(");
      this._visitParams(method.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      if (method.body.length > 0) {
        ctx.println("var self = this;");
        this.visitAllStatements(method.body, ctx);
      }
      ctx.decIndent();
      ctx.println("};");
    };
    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      if (ast.builtin === o.BuiltinVar.This) {
        ctx.print('self');
      } else if (ast.builtin === o.BuiltinVar.Super) {
        throw new exceptions_1.BaseException("'super' needs to be handled at a parent ast node, not at the variable level!");
      } else {
        _super.prototype.visitReadVarExpr.call(this, ast, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      ctx.print("var " + stmt.name + " = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ast.value.visitExpression(this, ctx);
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      var fnExpr = expr.fn;
      if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {
        ctx.currentClass.parent.visitExpression(this, ctx);
        ctx.print(".call(this");
        if (expr.args.length > 0) {
          ctx.print(", ");
          this.visitAllExpressions(expr.args, ctx, ',');
        }
        ctx.print(")");
      } else {
        _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
      }
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print("function(");
      this._visitParams(ast.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      ctx.print("function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println("try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println("} catch (" + abstract_emitter_1.CATCH_ERROR_VAR.name + ") {");
      ctx.incIndent();
      var catchStmts = [abstract_emitter_1.CATCH_STACK_VAR.set(abstract_emitter_1.CATCH_ERROR_VAR.prop('stack')).toDeclStmt(null, [o.StmtModifier.Final])].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    AbstractJsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      this.visitAllObjects(function(param) {
        return ctx.print(param.name);
      }, params, ctx, ',');
    };
    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case o.BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case o.BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case o.BuiltinMethod.bind:
          name = 'bind';
          break;
        default:
          throw new exceptions_1.BaseException("Unknown builtin method: " + method);
      }
      return name;
    };
    return AbstractJsEmitterVisitor;
  }(abstract_emitter_1.AbstractEmitterVisitor));
  exports.AbstractJsEmitterVisitor = AbstractJsEmitterVisitor;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/output_jit.js", ["../facade/lang", "../util", "./abstract_emitter", "./abstract_js_emitter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var lang_1 = $__require('../facade/lang');
  var util_1 = $__require('../util');
  var abstract_emitter_1 = $__require('./abstract_emitter');
  var abstract_js_emitter_1 = $__require('./abstract_js_emitter');
  function jitStatements(sourceUrl, statements, resultVar) {
    var converter = new JitEmitterVisitor();
    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot([resultVar]);
    converter.visitAllStatements(statements, ctx);
    return lang_1.evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
  }
  exports.jitStatements = jitStatements;
  var JitEmitterVisitor = (function(_super) {
    __extends(JitEmitterVisitor, _super);
    function JitEmitterVisitor() {
      _super.apply(this, arguments);
      this._evalArgNames = [];
      this._evalArgValues = [];
    }
    JitEmitterVisitor.prototype.getArgs = function() {
      var result = {};
      for (var i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }
      return result;
    };
    JitEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      var value = ast.value.runtime;
      var id = this._evalArgValues.indexOf(value);
      if (id === -1) {
        id = this._evalArgValues.length;
        this._evalArgValues.push(value);
        var name = lang_1.isPresent(ast.value.name) ? util_1.sanitizeIdentifier(ast.value.name) : 'val';
        this._evalArgNames.push(util_1.sanitizeIdentifier("jit_" + name + id));
      }
      ctx.print(this._evalArgNames[id]);
      return null;
    };
    return JitEmitterVisitor;
  }(abstract_js_emitter_1.AbstractJsEmitterVisitor));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/runtime_compiler.js", ["@angular/core", "../core_private", "./compile_metadata", "./config", "./directive_normalizer", "./facade/exceptions", "./facade/lang", "./metadata_resolver", "./ng_module_compiler", "./output/output_ast", "./output/output_interpreter", "./output/output_jit", "./style_compiler", "./template_parser/template_parser", "./util", "./view_compiler/view_compiler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var compile_metadata_1 = $__require('./compile_metadata');
  var config_1 = $__require('./config');
  var directive_normalizer_1 = $__require('./directive_normalizer');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var metadata_resolver_1 = $__require('./metadata_resolver');
  var ng_module_compiler_1 = $__require('./ng_module_compiler');
  var ir = $__require('./output/output_ast');
  var output_interpreter_1 = $__require('./output/output_interpreter');
  var output_jit_1 = $__require('./output/output_jit');
  var style_compiler_1 = $__require('./style_compiler');
  var template_parser_1 = $__require('./template_parser/template_parser');
  var util_1 = $__require('./util');
  var view_compiler_1 = $__require('./view_compiler/view_compiler');
  var RuntimeCompiler = (function() {
    function RuntimeCompiler(_injector, _metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _compilerConfig, _console) {
      this._injector = _injector;
      this._metadataResolver = _metadataResolver;
      this._templateNormalizer = _templateNormalizer;
      this._templateParser = _templateParser;
      this._styleCompiler = _styleCompiler;
      this._viewCompiler = _viewCompiler;
      this._ngModuleCompiler = _ngModuleCompiler;
      this._compilerConfig = _compilerConfig;
      this._console = _console;
      this._compiledTemplateCache = new Map();
      this._compiledHostTemplateCache = new Map();
      this._compiledNgModuleCache = new Map();
    }
    Object.defineProperty(RuntimeCompiler.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    RuntimeCompiler.prototype.compileModuleSync = function(moduleType) {
      return this._compileModuleAndComponents(moduleType, true).syncResult;
    };
    RuntimeCompiler.prototype.compileModuleAsync = function(moduleType) {
      return this._compileModuleAndComponents(moduleType, false).asyncResult;
    };
    RuntimeCompiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      return this._compileModuleAndAllComponents(moduleType, true).syncResult;
    };
    RuntimeCompiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      return this._compileModuleAndAllComponents(moduleType, false).asyncResult;
    };
    RuntimeCompiler.prototype.compileComponentAsync = function(compType, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      if (!ngModule) {
        throw new exceptions_1.BaseException("Calling compileComponentAsync on the root compiler without a module is not allowed! (Compiling component " + lang_1.stringify(compType) + ")");
      }
      return this._compileComponentInModule(compType, false, ngModule).asyncResult;
    };
    RuntimeCompiler.prototype.compileComponentSync = function(compType, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      if (!ngModule) {
        throw new exceptions_1.BaseException("Calling compileComponentSync on the root compiler without a module is not allowed! (Compiling component " + lang_1.stringify(compType) + ")");
      }
      return this._compileComponentInModule(compType, true, ngModule).syncResult;
    };
    RuntimeCompiler.prototype._compileModuleAndComponents = function(moduleType, isSync) {
      var componentPromise = this._compileComponents(moduleType, isSync);
      var ngModuleFactory = this._compileModule(moduleType);
      return new util_1.SyncAsyncResult(ngModuleFactory, componentPromise.then(function() {
        return ngModuleFactory;
      }));
    };
    RuntimeCompiler.prototype._compileModuleAndAllComponents = function(moduleType, isSync) {
      var _this = this;
      var componentPromise = this._compileComponents(moduleType, isSync);
      var ngModuleFactory = this._compileModule(moduleType);
      var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);
      var componentFactories = [];
      var templates = new Set();
      moduleMeta.transitiveModule.modules.forEach(function(moduleMeta) {
        moduleMeta.declaredDirectives.forEach(function(dirMeta) {
          if (dirMeta.isComponent) {
            var template = _this._createCompiledHostTemplate(dirMeta.type.runtime);
            templates.add(template);
            componentFactories.push(template.proxyComponentFactory);
          }
        });
      });
      var syncResult = new core_1.ModuleWithComponentFactories(ngModuleFactory, componentFactories);
      var compile = function() {
        templates.forEach(function(template) {
          _this._compileTemplate(template);
        });
        return syncResult;
      };
      var asyncResult = isSync ? Promise.resolve(compile()) : componentPromise.then(compile);
      return new util_1.SyncAsyncResult(syncResult, asyncResult);
    };
    RuntimeCompiler.prototype._compileModule = function(moduleType) {
      var _this = this;
      var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
      if (!ngModuleFactory) {
        var moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);
        var transitiveModuleMeta = moduleMeta_1.transitiveModule;
        var boundCompilerFactory = function(parentResolver) {
          return new ModuleBoundCompiler(_this, moduleMeta_1.type.runtime, parentResolver, _this._console);
        };
        var extraProviders = [this._metadataResolver.getProviderMetadata(new core_1.Provider(core_1.Compiler, {
          useFactory: boundCompilerFactory,
          deps: [[new core_1.OptionalMetadata(), new core_1.SkipSelfMetadata(), core_1.ComponentResolver]]
        })), this._metadataResolver.getProviderMetadata(new core_1.Provider(core_1.ComponentResolver, {useExisting: core_1.Compiler}))];
        var compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);
        compileResult.dependencies.forEach(function(dep) {
          dep.placeholder.runtime = _this._assertComponentKnown(dep.comp.runtime, true).proxyComponentFactory;
          dep.placeholder.name = "compFactory_" + dep.comp.name;
        });
        if (!this._compilerConfig.useJit) {
          ngModuleFactory = output_interpreter_1.interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);
        } else {
          ngModuleFactory = output_jit_1.jitStatements(moduleMeta_1.type.name + ".ngfactory.js", compileResult.statements, compileResult.ngModuleFactoryVar);
        }
        this._compiledNgModuleCache.set(moduleMeta_1.type.runtime, ngModuleFactory);
      }
      return ngModuleFactory;
    };
    RuntimeCompiler.prototype._compileComponentInModule = function(compType, isSync, moduleType) {
      this._metadataResolver.addComponentToModule(moduleType, compType);
      var componentPromise = this._compileComponents(moduleType, isSync);
      var componentFactory = this._assertComponentKnown(compType, true).proxyComponentFactory;
      return new util_1.SyncAsyncResult(componentFactory, componentPromise.then(function() {
        return componentFactory;
      }));
    };
    RuntimeCompiler.prototype._compileComponents = function(mainModule, isSync) {
      var _this = this;
      var templates = new Set();
      var loadingPromises = [];
      var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
      ngModule.transitiveModule.modules.forEach(function(localModuleMeta) {
        localModuleMeta.declaredDirectives.forEach(function(dirMeta) {
          if (dirMeta.isComponent) {
            templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
            dirMeta.entryComponents.forEach(function(entryComponentType) {
              templates.add(_this._createCompiledHostTemplate(entryComponentType.runtime));
            });
          }
        });
        localModuleMeta.entryComponents.forEach(function(entryComponentType) {
          templates.add(_this._createCompiledHostTemplate(entryComponentType.runtime));
        });
      });
      templates.forEach(function(template) {
        if (template.loading) {
          if (isSync) {
            throw new core_1.ComponentStillLoadingError(template.compType.runtime);
          } else {
            loadingPromises.push(template.loading);
          }
        }
      });
      var compile = function() {
        templates.forEach(function(template) {
          _this._compileTemplate(template);
        });
      };
      if (isSync) {
        compile();
        return Promise.resolve(null);
      } else {
        return Promise.all(loadingPromises).then(compile);
      }
    };
    RuntimeCompiler.prototype.clearCacheFor = function(type) {
      this._compiledNgModuleCache.delete(type);
      this._metadataResolver.clearCacheFor(type);
      this._compiledHostTemplateCache.delete(type);
      var compiledTemplate = this._compiledTemplateCache.get(type);
      if (compiledTemplate) {
        this._templateNormalizer.clearCacheFor(compiledTemplate.normalizedCompMeta);
        this._compiledTemplateCache.delete(type);
      }
    };
    RuntimeCompiler.prototype.clearCache = function() {
      this._metadataResolver.clearCache();
      this._compiledTemplateCache.clear();
      this._compiledHostTemplateCache.clear();
      this._templateNormalizer.clearCache();
      this._compiledNgModuleCache.clear();
    };
    RuntimeCompiler.prototype._createCompiledHostTemplate = function(compType) {
      var compiledTemplate = this._compiledHostTemplateCache.get(compType);
      if (lang_1.isBlank(compiledTemplate)) {
        var compMeta = this._metadataResolver.getDirectiveMetadata(compType);
        assertComponent(compMeta);
        var hostMeta = compile_metadata_1.createHostComponentMeta(compMeta);
        compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, [compMeta], [], [], this._templateNormalizer.normalizeDirective(hostMeta));
        this._compiledHostTemplateCache.set(compType, compiledTemplate);
      }
      return compiledTemplate;
    };
    RuntimeCompiler.prototype._createCompiledTemplate = function(compMeta, ngModule) {
      var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.runtime);
      if (lang_1.isBlank(compiledTemplate)) {
        assertComponent(compMeta);
        compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, ngModule.transitiveModule.directives, ngModule.transitiveModule.pipes, ngModule.schemas, this._templateNormalizer.normalizeDirective(compMeta));
        this._compiledTemplateCache.set(compMeta.type.runtime, compiledTemplate);
      }
      return compiledTemplate;
    };
    RuntimeCompiler.prototype._assertComponentKnown = function(compType, isHost) {
      var compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) : this._compiledTemplateCache.get(compType);
      if (!compiledTemplate) {
        throw new exceptions_1.BaseException("Illegal state: CompiledTemplate for " + lang_1.stringify(compType) + " (isHost: " + isHost + ") does not exist!");
      }
      return compiledTemplate;
    };
    RuntimeCompiler.prototype._assertComponentLoaded = function(compType, isHost) {
      var compiledTemplate = this._assertComponentKnown(compType, isHost);
      if (compiledTemplate.loading) {
        throw new exceptions_1.BaseException("Illegal state: CompiledTemplate for " + lang_1.stringify(compType) + " (isHost: " + isHost + ") is still loading!");
      }
      return compiledTemplate;
    };
    RuntimeCompiler.prototype._compileTemplate = function(template) {
      var _this = this;
      if (template.isCompiled) {
        return;
      }
      var compMeta = template.normalizedCompMeta;
      var externalStylesheetsByModuleUrl = new Map();
      var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
      stylesCompileResult.externalStylesheets.forEach(function(r) {
        externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r);
      });
      this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
      var viewCompMetas = template.viewComponentTypes.map(function(compType) {
        return _this._assertComponentLoaded(compType, false).normalizedCompMeta;
      });
      var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, template.viewDirectives.concat(viewCompMetas), template.viewPipes, template.schemas, compMeta.type.name);
      var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, ir.variable(stylesCompileResult.componentStylesheet.stylesVar), template.viewPipes);
      compileResult.dependencies.forEach(function(dep) {
        var depTemplate;
        if (dep instanceof view_compiler_1.ViewFactoryDependency) {
          var vfd = dep;
          depTemplate = _this._assertComponentLoaded(vfd.comp.runtime, false);
          vfd.placeholder.runtime = depTemplate.proxyViewFactory;
          vfd.placeholder.name = "viewFactory_" + vfd.comp.name;
        } else if (dep instanceof view_compiler_1.ComponentFactoryDependency) {
          var cfd = dep;
          depTemplate = _this._assertComponentLoaded(cfd.comp.runtime, true);
          cfd.placeholder.runtime = depTemplate.proxyComponentFactory;
          cfd.placeholder.name = "compFactory_" + cfd.comp.name;
        }
      });
      var statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);
      var factory;
      if (!this._compilerConfig.useJit) {
        factory = output_interpreter_1.interpretStatements(statements, compileResult.viewFactoryVar);
      } else {
        factory = output_jit_1.jitStatements(template.compType.name + ".ngfactory.js", statements, compileResult.viewFactoryVar);
      }
      template.compiled(factory);
    };
    RuntimeCompiler.prototype._resolveStylesCompileResult = function(result, externalStylesheetsByModuleUrl) {
      var _this = this;
      result.dependencies.forEach(function(dep, i) {
        var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
        var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
        dep.valuePlaceholder.runtime = nestedStylesArr;
        dep.valuePlaceholder.name = "importedStyles" + i;
      });
    };
    RuntimeCompiler.prototype._resolveAndEvalStylesCompileResult = function(result, externalStylesheetsByModuleUrl) {
      this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
      if (!this._compilerConfig.useJit) {
        return output_interpreter_1.interpretStatements(result.statements, result.stylesVar);
      } else {
        return output_jit_1.jitStatements(result.meta.moduleUrl + ".css.js", result.statements, result.stylesVar);
      }
    };
    RuntimeCompiler.decorators = [{type: core_1.Injectable}];
    RuntimeCompiler.ctorParameters = [{type: core_1.Injector}, {type: metadata_resolver_1.CompileMetadataResolver}, {type: directive_normalizer_1.DirectiveNormalizer}, {type: template_parser_1.TemplateParser}, {type: style_compiler_1.StyleCompiler}, {type: view_compiler_1.ViewCompiler}, {type: ng_module_compiler_1.NgModuleCompiler}, {type: config_1.CompilerConfig}, {type: core_private_1.Console}];
    return RuntimeCompiler;
  }());
  exports.RuntimeCompiler = RuntimeCompiler;
  var CompiledTemplate = (function() {
    function CompiledTemplate(isHost, selector, compType, viewDirectivesAndComponents, viewPipes, schemas, _normalizeResult) {
      var _this = this;
      this.isHost = isHost;
      this.compType = compType;
      this.viewPipes = viewPipes;
      this.schemas = schemas;
      this._viewFactory = null;
      this.loading = null;
      this._normalizedCompMeta = null;
      this.isCompiled = false;
      this.isCompiledWithDeps = false;
      this.viewComponentTypes = [];
      this.viewDirectives = [];
      viewDirectivesAndComponents.forEach(function(dirMeta) {
        if (dirMeta.isComponent) {
          _this.viewComponentTypes.push(dirMeta.type.runtime);
        } else {
          _this.viewDirectives.push(dirMeta);
        }
      });
      this.proxyViewFactory = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i - 0] = arguments[_i];
        }
        if (!_this._viewFactory) {
          throw new exceptions_1.BaseException("Illegal state: CompiledTemplate for " + lang_1.stringify(_this.compType) + " is not compiled yet!");
        }
        return _this._viewFactory.apply(null, args);
      };
      this.proxyComponentFactory = isHost ? new core_1.ComponentFactory(selector, this.proxyViewFactory, compType.runtime) : null;
      if (_normalizeResult.syncResult) {
        this._normalizedCompMeta = _normalizeResult.syncResult;
      } else {
        this.loading = _normalizeResult.asyncResult.then(function(normalizedCompMeta) {
          _this._normalizedCompMeta = normalizedCompMeta;
          _this.loading = null;
        });
      }
    }
    Object.defineProperty(CompiledTemplate.prototype, "normalizedCompMeta", {
      get: function() {
        if (this.loading) {
          throw new exceptions_1.BaseException("Template is still loading for " + this.compType.name + "!");
        }
        return this._normalizedCompMeta;
      },
      enumerable: true,
      configurable: true
    });
    CompiledTemplate.prototype.compiled = function(viewFactory) {
      this._viewFactory = viewFactory;
      this.isCompiled = true;
    };
    CompiledTemplate.prototype.depsCompiled = function() {
      this.isCompiledWithDeps = true;
    };
    return CompiledTemplate;
  }());
  function assertComponent(meta) {
    if (!meta.isComponent) {
      throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
  }
  var ModuleBoundCompiler = (function() {
    function ModuleBoundCompiler(_delegate, _ngModule, _parentComponentResolver, _console) {
      this._delegate = _delegate;
      this._ngModule = _ngModule;
      this._parentComponentResolver = _parentComponentResolver;
      this._console = _console;
      this._warnOnComponentResolver = true;
    }
    Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
      get: function() {
        return this._delegate.injector;
      },
      enumerable: true,
      configurable: true
    });
    ModuleBoundCompiler.prototype.resolveComponent = function(component) {
      if (lang_1.isString(component)) {
        if (this._parentComponentResolver) {
          return this._parentComponentResolver.resolveComponent(component);
        } else {
          return Promise.reject(new exceptions_1.BaseException("Cannot resolve component using '" + component + "'."));
        }
      }
      if (this._warnOnComponentResolver) {
        this._console.warn(core_1.ComponentResolver.DynamicCompilationDeprecationMsg);
        this._warnOnComponentResolver = false;
      }
      return this.compileComponentAsync(component);
    };
    ModuleBoundCompiler.prototype.compileComponentAsync = function(compType, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      return this._delegate.compileComponentAsync(compType, ngModule ? ngModule : this._ngModule);
    };
    ModuleBoundCompiler.prototype.compileComponentSync = function(compType, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      return this._delegate.compileComponentSync(compType, ngModule ? ngModule : this._ngModule);
    };
    ModuleBoundCompiler.prototype.compileModuleSync = function(moduleType) {
      return this._delegate.compileModuleSync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAsync = function(moduleType) {
      return this._delegate.compileModuleAsync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      return this._delegate.compileModuleAndAllComponentsSync(moduleType);
    };
    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
    };
    ModuleBoundCompiler.prototype.clearCache = function() {
      this._delegate.clearCache();
      if (this._parentComponentResolver) {
        this._parentComponentResolver.clearCache();
      }
    };
    ModuleBoundCompiler.prototype.clearCacheFor = function(type) {
      this._delegate.clearCacheFor(type);
    };
    return ModuleBoundCompiler;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/compiler.js", ["@angular/core", "./template_parser/template_ast", "./template_parser/template_parser", "./config", "./compile_metadata", "./offline_compiler", "./runtime_compiler", "./url_resolver", "./xhr", "./directive_resolver", "./pipe_resolver", "./ng_module_resolver", "./facade/lang", "./facade/collection", "./ml_parser/html_parser", "./directive_normalizer", "./metadata_resolver", "./style_compiler", "./view_compiler/view_compiler", "./ng_module_compiler", "./schema/element_schema_registry", "./schema/dom_element_schema_registry", "./expression_parser/parser", "./expression_parser/lexer", "../core_private"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  var core_1 = $__require('@angular/core');
  __export($__require('./template_parser/template_ast'));
  var template_parser_1 = $__require('./template_parser/template_parser');
  exports.TEMPLATE_TRANSFORMS = template_parser_1.TEMPLATE_TRANSFORMS;
  var config_1 = $__require('./config');
  exports.CompilerConfig = config_1.CompilerConfig;
  exports.RenderTypes = config_1.RenderTypes;
  __export($__require('./compile_metadata'));
  __export($__require('./offline_compiler'));
  var runtime_compiler_1 = $__require('./runtime_compiler');
  exports.RuntimeCompiler = runtime_compiler_1.RuntimeCompiler;
  __export($__require('./url_resolver'));
  __export($__require('./xhr'));
  var directive_resolver_1 = $__require('./directive_resolver');
  exports.DirectiveResolver = directive_resolver_1.DirectiveResolver;
  var pipe_resolver_1 = $__require('./pipe_resolver');
  exports.PipeResolver = pipe_resolver_1.PipeResolver;
  var ng_module_resolver_1 = $__require('./ng_module_resolver');
  exports.NgModuleResolver = ng_module_resolver_1.NgModuleResolver;
  var lang_1 = $__require('./facade/lang');
  var collection_1 = $__require('./facade/collection');
  var template_parser_2 = $__require('./template_parser/template_parser');
  var html_parser_1 = $__require('./ml_parser/html_parser');
  var directive_normalizer_1 = $__require('./directive_normalizer');
  var metadata_resolver_1 = $__require('./metadata_resolver');
  var style_compiler_1 = $__require('./style_compiler');
  var view_compiler_1 = $__require('./view_compiler/view_compiler');
  var ng_module_compiler_1 = $__require('./ng_module_compiler');
  var config_2 = $__require('./config');
  var runtime_compiler_2 = $__require('./runtime_compiler');
  var element_schema_registry_1 = $__require('./schema/element_schema_registry');
  var dom_element_schema_registry_1 = $__require('./schema/dom_element_schema_registry');
  var url_resolver_2 = $__require('./url_resolver');
  var parser_1 = $__require('./expression_parser/parser');
  var lexer_1 = $__require('./expression_parser/lexer');
  var directive_resolver_2 = $__require('./directive_resolver');
  var pipe_resolver_2 = $__require('./pipe_resolver');
  var ng_module_resolver_2 = $__require('./ng_module_resolver');
  var core_private_1 = $__require('../core_private');
  var xhr_2 = $__require('./xhr');
  var _NO_XHR = {get: function(url) {
      throw new Error("No XHR implementation has been provided. Can't read the url \"" + url + "\"");
    }};
  exports.COMPILER_PROVIDERS = [{
    provide: core_private_1.Reflector,
    useValue: core_private_1.reflector
  }, {
    provide: core_private_1.ReflectorReader,
    useExisting: core_private_1.Reflector
  }, {
    provide: xhr_2.XHR,
    useValue: _NO_XHR
  }, core_private_1.Console, lexer_1.Lexer, parser_1.Parser, html_parser_1.HtmlParser, template_parser_2.TemplateParser, directive_normalizer_1.DirectiveNormalizer, metadata_resolver_1.CompileMetadataResolver, url_resolver_2.DEFAULT_PACKAGE_URL_PROVIDER, style_compiler_1.StyleCompiler, view_compiler_1.ViewCompiler, ng_module_compiler_1.NgModuleCompiler, {
    provide: config_2.CompilerConfig,
    useValue: new config_2.CompilerConfig()
  }, runtime_compiler_2.RuntimeCompiler, {
    provide: core_1.Compiler,
    useExisting: runtime_compiler_2.RuntimeCompiler
  }, dom_element_schema_registry_1.DomElementSchemaRegistry, {
    provide: element_schema_registry_1.ElementSchemaRegistry,
    useExisting: dom_element_schema_registry_1.DomElementSchemaRegistry
  }, url_resolver_2.UrlResolver, directive_resolver_2.DirectiveResolver, pipe_resolver_2.PipeResolver, ng_module_resolver_2.NgModuleResolver];
  function analyzeAppProvidersForDeprecatedConfiguration(appProviders) {
    if (appProviders === void 0) {
      appProviders = [];
    }
    var platformDirectives = [];
    var platformPipes = [];
    var compilerProviders = [];
    var useDebug;
    var useJit;
    var defaultEncapsulation;
    var deprecationMessages = [];
    var tempInj = core_1.ReflectiveInjector.resolveAndCreate(appProviders);
    var compilerConfig = tempInj.get(config_2.CompilerConfig, null);
    if (compilerConfig) {
      platformDirectives = compilerConfig.platformDirectives;
      platformPipes = compilerConfig.platformPipes;
      useJit = compilerConfig.useJit;
      useDebug = compilerConfig.genDebugInfo;
      defaultEncapsulation = compilerConfig.defaultEncapsulation;
      deprecationMessages.push("Passing CompilerConfig as a regular provider is deprecated. Use the \"compilerOptions\" parameter of \"bootstrap()\" or use a custom \"CompilerFactory\" platform provider instead.");
    } else {
      platformDirectives = tempInj.get(core_1.PLATFORM_DIRECTIVES, []);
      platformPipes = tempInj.get(core_1.PLATFORM_PIPES, []);
    }
    platformDirectives = collection_1.ListWrapper.flatten(platformDirectives);
    platformPipes = collection_1.ListWrapper.flatten(platformPipes);
    var xhr = tempInj.get(xhr_2.XHR, null);
    if (xhr) {
      compilerProviders.push([{
        provide: xhr_2.XHR,
        useValue: xhr
      }]);
      deprecationMessages.push("Passing XHR as regular provider is deprecated. Pass the provider via \"compilerOptions\" instead.");
    }
    if (platformDirectives.length > 0) {
      deprecationMessages.push("The PLATFORM_DIRECTIVES provider and CompilerConfig.platformDirectives is deprecated. Add the directives to an NgModule instead! " + ("(Directives: " + platformDirectives.map(function(type) {
        return lang_1.stringify(type);
      }) + ")"));
    }
    if (platformPipes.length > 0) {
      deprecationMessages.push("The PLATFORM_PIPES provider and CompilerConfig.platformPipes is deprecated. Add the pipes to an NgModule instead! " + ("(Pipes: " + platformPipes.map(function(type) {
        return lang_1.stringify(type);
      }) + ")"));
    }
    var compilerOptions = {
      useJit: useJit,
      useDebug: useDebug,
      defaultEncapsulation: defaultEncapsulation,
      providers: compilerProviders
    };
    var DynamicComponent = (function() {
      function DynamicComponent() {}
      DynamicComponent.decorators = [{
        type: core_1.Component,
        args: [{
          directives: platformDirectives,
          pipes: platformPipes,
          template: ''
        }]
      }];
      return DynamicComponent;
    }());
    return {
      compilerOptions: compilerOptions,
      moduleDeclarations: [DynamicComponent],
      deprecationMessages: deprecationMessages
    };
  }
  exports.analyzeAppProvidersForDeprecatedConfiguration = analyzeAppProvidersForDeprecatedConfiguration;
  var RuntimeCompilerFactory = (function() {
    function RuntimeCompilerFactory(defaultOptions) {
      this._defaultOptions = [{
        useDebug: core_1.isDevMode(),
        useJit: true,
        defaultEncapsulation: core_1.ViewEncapsulation.Emulated
      }].concat(defaultOptions);
    }
    RuntimeCompilerFactory.prototype.createCompiler = function(options) {
      if (options === void 0) {
        options = [];
      }
      var mergedOptions = _mergeOptions(this._defaultOptions.concat(options));
      var injector = core_1.ReflectiveInjector.resolveAndCreate([exports.COMPILER_PROVIDERS, {
        provide: config_2.CompilerConfig,
        useFactory: function() {
          return new config_2.CompilerConfig({
            genDebugInfo: mergedOptions.useDebug,
            useJit: mergedOptions.useJit,
            defaultEncapsulation: mergedOptions.defaultEncapsulation,
            logBindingUpdate: mergedOptions.useDebug
          });
        },
        deps: []
      }, mergedOptions.providers]);
      return injector.get(core_1.Compiler);
    };
    RuntimeCompilerFactory.decorators = [{type: core_1.Injectable}];
    RuntimeCompilerFactory.ctorParameters = [{
      type: Array,
      decorators: [{
        type: core_1.Inject,
        args: [core_1.COMPILER_OPTIONS]
      }]
    }];
    return RuntimeCompilerFactory;
  }());
  exports.RuntimeCompilerFactory = RuntimeCompilerFactory;
  function _initReflector() {
    core_private_1.reflector.reflectionCapabilities = new core_private_1.ReflectionCapabilities();
  }
  exports.platformCoreDynamic = core_1.createPlatformFactory(core_1.platformCore, 'coreDynamic', [{
    provide: core_1.COMPILER_OPTIONS,
    useValue: {},
    multi: true
  }, {
    provide: core_1.CompilerFactory,
    useClass: RuntimeCompilerFactory
  }, {
    provide: core_1.PLATFORM_INITIALIZER,
    useValue: _initReflector,
    multi: true
  }]);
  function _mergeOptions(optionsArr) {
    return {
      useDebug: _lastDefined(optionsArr.map(function(options) {
        return options.useDebug;
      })),
      useJit: _lastDefined(optionsArr.map(function(options) {
        return options.useJit;
      })),
      defaultEncapsulation: _lastDefined(optionsArr.map(function(options) {
        return options.defaultEncapsulation;
      })),
      providers: _mergeArrays(optionsArr.map(function(options) {
        return options.providers;
      }))
    };
  }
  function _lastDefined(args) {
    for (var i = args.length - 1; i >= 0; i--) {
      if (args[i] !== undefined) {
        return args[i];
      }
    }
    return undefined;
  }
  function _mergeArrays(parts) {
    var result = [];
    parts.forEach(function(part) {
      return part && result.push.apply(result, part);
    });
    return result;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/xhr.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var XHR = (function() {
    function XHR() {}
    XHR.prototype.get = function(url) {
      return null;
    };
    return XHR;
  }());
  exports.XHR = XHR;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/directive_normalizer.js", ["@angular/core", "./compile_metadata", "./config", "./facade/collection", "./facade/exceptions", "./facade/lang", "./ml_parser/ast", "./ml_parser/html_parser", "./ml_parser/interpolation_config", "./style_url_resolver", "./template_parser/template_preparser", "./url_resolver", "./util", "./xhr"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var compile_metadata_1 = $__require('./compile_metadata');
  var config_1 = $__require('./config');
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var html = $__require('./ml_parser/ast');
  var html_parser_1 = $__require('./ml_parser/html_parser');
  var interpolation_config_1 = $__require('./ml_parser/interpolation_config');
  var style_url_resolver_1 = $__require('./style_url_resolver');
  var template_preparser_1 = $__require('./template_parser/template_preparser');
  var url_resolver_1 = $__require('./url_resolver');
  var util_1 = $__require('./util');
  var xhr_1 = $__require('./xhr');
  var DirectiveNormalizer = (function() {
    function DirectiveNormalizer(_xhr, _urlResolver, _htmlParser, _config) {
      this._xhr = _xhr;
      this._urlResolver = _urlResolver;
      this._htmlParser = _htmlParser;
      this._config = _config;
      this._xhrCache = new Map();
    }
    DirectiveNormalizer.prototype.clearCache = function() {
      this._xhrCache.clear();
    };
    DirectiveNormalizer.prototype.clearCacheFor = function(normalizedDirective) {
      var _this = this;
      if (!normalizedDirective.isComponent) {
        return;
      }
      this._xhrCache.delete(normalizedDirective.template.templateUrl);
      normalizedDirective.template.externalStylesheets.forEach(function(stylesheet) {
        _this._xhrCache.delete(stylesheet.moduleUrl);
      });
    };
    DirectiveNormalizer.prototype._fetch = function(url) {
      var result = this._xhrCache.get(url);
      if (!result) {
        result = this._xhr.get(url);
        this._xhrCache.set(url, result);
      }
      return result;
    };
    DirectiveNormalizer.prototype.normalizeDirective = function(directive) {
      var _this = this;
      if (!directive.isComponent) {
        return new util_1.SyncAsyncResult(directive, Promise.resolve(directive));
      }
      var normalizedTemplateSync = null;
      var normalizedTemplateAsync;
      if (lang_1.isPresent(directive.template.template)) {
        normalizedTemplateSync = this.normalizeTemplateSync(directive.type, directive.template);
        normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
      } else if (directive.template.templateUrl) {
        normalizedTemplateAsync = this.normalizeTemplateAsync(directive.type, directive.template);
      } else {
        throw new exceptions_1.BaseException("No template specified for component " + directive.type.name);
      }
      if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
        var normalizedDirective = _cloneDirectiveWithTemplate(directive, normalizedTemplateSync);
        return new util_1.SyncAsyncResult(normalizedDirective, Promise.resolve(normalizedDirective));
      } else {
        return new util_1.SyncAsyncResult(null, normalizedTemplateAsync.then(function(normalizedTemplate) {
          return _this.normalizeExternalStylesheets(normalizedTemplate);
        }).then(function(normalizedTemplate) {
          return _cloneDirectiveWithTemplate(directive, normalizedTemplate);
        }));
      }
    };
    DirectiveNormalizer.prototype.normalizeTemplateSync = function(directiveType, template) {
      return this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl);
    };
    DirectiveNormalizer.prototype.normalizeTemplateAsync = function(directiveType, template) {
      var _this = this;
      var templateUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
      return this._fetch(templateUrl).then(function(value) {
        return _this.normalizeLoadedTemplate(directiveType, template, value, templateUrl);
      });
    };
    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function(directiveType, templateMeta, template, templateAbsUrl) {
      var interpolationConfig = interpolation_config_1.InterpolationConfig.fromArray(templateMeta.interpolation);
      var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name, false, interpolationConfig);
      if (rootNodesAndErrors.errors.length > 0) {
        var errorString = rootNodesAndErrors.errors.join('\n');
        throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
      }
      var templateMetadataStyles = this.normalizeStylesheet(new compile_metadata_1.CompileStylesheetMetadata({
        styles: templateMeta.styles,
        styleUrls: templateMeta.styleUrls,
        moduleUrl: directiveType.moduleUrl
      }));
      var visitor = new TemplatePreparseVisitor();
      html.visitAll(visitor, rootNodesAndErrors.rootNodes);
      var templateStyles = this.normalizeStylesheet(new compile_metadata_1.CompileStylesheetMetadata({
        styles: visitor.styles,
        styleUrls: visitor.styleUrls,
        moduleUrl: templateAbsUrl
      }));
      var allStyles = templateMetadataStyles.styles.concat(templateStyles.styles);
      var allStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
      var encapsulation = templateMeta.encapsulation;
      if (lang_1.isBlank(encapsulation)) {
        encapsulation = this._config.defaultEncapsulation;
      }
      if (encapsulation === core_1.ViewEncapsulation.Emulated && allStyles.length === 0 && allStyleUrls.length === 0) {
        encapsulation = core_1.ViewEncapsulation.None;
      }
      return new compile_metadata_1.CompileTemplateMetadata({
        encapsulation: encapsulation,
        template: template,
        templateUrl: templateAbsUrl,
        styles: allStyles,
        styleUrls: allStyleUrls,
        externalStylesheets: templateMeta.externalStylesheets,
        ngContentSelectors: visitor.ngContentSelectors,
        animations: templateMeta.animations,
        interpolation: templateMeta.interpolation
      });
    };
    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function(templateMeta) {
      return this._loadMissingExternalStylesheets(templateMeta.styleUrls).then(function(externalStylesheets) {
        return new compile_metadata_1.CompileTemplateMetadata({
          encapsulation: templateMeta.encapsulation,
          template: templateMeta.template,
          templateUrl: templateMeta.templateUrl,
          styles: templateMeta.styles,
          styleUrls: templateMeta.styleUrls,
          externalStylesheets: externalStylesheets,
          ngContentSelectors: templateMeta.ngContentSelectors,
          animations: templateMeta.animations,
          interpolation: templateMeta.interpolation
        });
      });
    };
    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function(styleUrls, loadedStylesheets) {
      var _this = this;
      if (loadedStylesheets === void 0) {
        loadedStylesheets = new Map();
      }
      return Promise.all(styleUrls.filter(function(styleUrl) {
        return !loadedStylesheets.has(styleUrl);
      }).map(function(styleUrl) {
        return _this._fetch(styleUrl).then(function(loadedStyle) {
          var stylesheet = _this.normalizeStylesheet(new compile_metadata_1.CompileStylesheetMetadata({
            styles: [loadedStyle],
            moduleUrl: styleUrl
          }));
          loadedStylesheets.set(styleUrl, stylesheet);
          return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
        });
      })).then(function(_) {
        return collection_1.MapWrapper.values(loadedStylesheets);
      });
    };
    DirectiveNormalizer.prototype.normalizeStylesheet = function(stylesheet) {
      var _this = this;
      var allStyleUrls = stylesheet.styleUrls.filter(style_url_resolver_1.isStyleUrlResolvable).map(function(url) {
        return _this._urlResolver.resolve(stylesheet.moduleUrl, url);
      });
      var allStyles = stylesheet.styles.map(function(style) {
        var styleWithImports = style_url_resolver_1.extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);
        allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
        return styleWithImports.style;
      });
      return new compile_metadata_1.CompileStylesheetMetadata({
        styles: allStyles,
        styleUrls: allStyleUrls,
        moduleUrl: stylesheet.moduleUrl
      });
    };
    DirectiveNormalizer.decorators = [{type: core_1.Injectable}];
    DirectiveNormalizer.ctorParameters = [{type: xhr_1.XHR}, {type: url_resolver_1.UrlResolver}, {type: html_parser_1.HtmlParser}, {type: config_1.CompilerConfig}];
    return DirectiveNormalizer;
  }());
  exports.DirectiveNormalizer = DirectiveNormalizer;
  var TemplatePreparseVisitor = (function() {
    function TemplatePreparseVisitor() {
      this.ngContentSelectors = [];
      this.styles = [];
      this.styleUrls = [];
      this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function(ast, context) {
      var preparsedElement = template_preparser_1.preparseElement(ast);
      switch (preparsedElement.type) {
        case template_preparser_1.PreparsedElementType.NG_CONTENT:
          if (this.ngNonBindableStackCount === 0) {
            this.ngContentSelectors.push(preparsedElement.selectAttr);
          }
          break;
        case template_preparser_1.PreparsedElementType.STYLE:
          var textContent = '';
          ast.children.forEach(function(child) {
            if (child instanceof html.Text) {
              textContent += child.value;
            }
          });
          this.styles.push(textContent);
          break;
        case template_preparser_1.PreparsedElementType.STYLESHEET:
          this.styleUrls.push(preparsedElement.hrefAttr);
          break;
        default:
          break;
      }
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount++;
      }
      html.visitAll(this, ast.children);
      if (preparsedElement.nonBindable) {
        this.ngNonBindableStackCount--;
      }
      return null;
    };
    TemplatePreparseVisitor.prototype.visitComment = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitAttribute = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitText = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitExpansion = function(ast, context) {
      return null;
    };
    TemplatePreparseVisitor.prototype.visitExpansionCase = function(ast, context) {
      return null;
    };
    return TemplatePreparseVisitor;
  }());
  function _cloneDirectiveWithTemplate(directive, template) {
    return new compile_metadata_1.CompileDirectiveMetadata({
      type: directive.type,
      isComponent: directive.isComponent,
      selector: directive.selector,
      exportAs: directive.exportAs,
      changeDetection: directive.changeDetection,
      inputs: directive.inputs,
      outputs: directive.outputs,
      hostListeners: directive.hostListeners,
      hostProperties: directive.hostProperties,
      hostAttributes: directive.hostAttributes,
      providers: directive.providers,
      viewProviders: directive.viewProviders,
      queries: directive.queries,
      viewQueries: directive.viewQueries,
      entryComponents: directive.entryComponents,
      template: template
    });
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/directive_resolver.js", ["@angular/core", "../core_private", "./facade/collection", "./facade/exceptions", "./facade/lang", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var util_1 = $__require('./util');
  function _isDirectiveMetadata(type) {
    return type instanceof core_1.DirectiveMetadata;
  }
  var DirectiveResolver = (function() {
    function DirectiveResolver(_reflector) {
      if (_reflector === void 0) {
        _reflector = core_private_1.reflector;
      }
      this._reflector = _reflector;
    }
    DirectiveResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var typeMetadata = this._reflector.annotations(core_1.resolveForwardRef(type));
      if (lang_1.isPresent(typeMetadata)) {
        var metadata = typeMetadata.find(_isDirectiveMetadata);
        if (lang_1.isPresent(metadata)) {
          var propertyMetadata = this._reflector.propMetadata(type);
          return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
        }
      }
      if (throwIfNotFound) {
        throw new exceptions_1.BaseException("No Directive annotation found on " + lang_1.stringify(type));
      }
      return null;
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function(dm, propertyMetadata, directiveType) {
      var inputs = [];
      var outputs = [];
      var host = {};
      var queries = {};
      collection_1.StringMapWrapper.forEach(propertyMetadata, function(metadata, propName) {
        metadata.forEach(function(a) {
          if (a instanceof core_1.InputMetadata) {
            if (lang_1.isPresent(a.bindingPropertyName)) {
              inputs.push(propName + ": " + a.bindingPropertyName);
            } else {
              inputs.push(propName);
            }
          } else if (a instanceof core_1.OutputMetadata) {
            if (lang_1.isPresent(a.bindingPropertyName)) {
              outputs.push(propName + ": " + a.bindingPropertyName);
            } else {
              outputs.push(propName);
            }
          } else if (a instanceof core_1.HostBindingMetadata) {
            if (lang_1.isPresent(a.hostPropertyName)) {
              host[("[" + a.hostPropertyName + "]")] = propName;
            } else {
              host[("[" + propName + "]")] = propName;
            }
          } else if (a instanceof core_1.HostListenerMetadata) {
            var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';
            host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
          } else if (a instanceof core_1.QueryMetadata) {
            queries[propName] = a;
          }
        });
      });
      return this._merge(dm, inputs, outputs, host, queries, directiveType);
    };
    DirectiveResolver.prototype._extractPublicName = function(def) {
      return util_1.splitAtColon(def, [null, def])[1].trim();
    };
    DirectiveResolver.prototype._merge = function(dm, inputs, outputs, host, queries, directiveType) {
      var _this = this;
      var mergedInputs;
      if (lang_1.isPresent(dm.inputs)) {
        var inputNames_1 = dm.inputs.map(function(def) {
          return _this._extractPublicName(def);
        });
        inputs.forEach(function(inputDef) {
          var publicName = _this._extractPublicName(inputDef);
          if (inputNames_1.indexOf(publicName) > -1) {
            throw new exceptions_1.BaseException("Input '" + publicName + "' defined multiple times in '" + lang_1.stringify(directiveType) + "'");
          }
        });
        mergedInputs = dm.inputs.concat(inputs);
      } else {
        mergedInputs = inputs;
      }
      var mergedOutputs;
      if (lang_1.isPresent(dm.outputs)) {
        var outputNames_1 = dm.outputs.map(function(def) {
          return _this._extractPublicName(def);
        });
        outputs.forEach(function(outputDef) {
          var publicName = _this._extractPublicName(outputDef);
          if (outputNames_1.indexOf(publicName) > -1) {
            throw new exceptions_1.BaseException("Output event '" + publicName + "' defined multiple times in '" + lang_1.stringify(directiveType) + "'");
          }
        });
        mergedOutputs = dm.outputs.concat(outputs);
      } else {
        mergedOutputs = outputs;
      }
      var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;
      var mergedQueries = lang_1.isPresent(dm.queries) ? collection_1.StringMapWrapper.merge(dm.queries, queries) : queries;
      if (dm instanceof core_1.ComponentMetadata) {
        return new core_1.ComponentMetadata({
          selector: dm.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: dm.exportAs,
          moduleId: dm.moduleId,
          queries: mergedQueries,
          changeDetection: dm.changeDetection,
          providers: dm.providers,
          viewProviders: dm.viewProviders,
          entryComponents: dm.entryComponents,
          directives: dm.directives,
          pipes: dm.pipes,
          template: dm.template,
          templateUrl: dm.templateUrl,
          styles: dm.styles,
          styleUrls: dm.styleUrls,
          encapsulation: dm.encapsulation,
          animations: dm.animations,
          interpolation: dm.interpolation
        });
      } else {
        return new core_1.DirectiveMetadata({
          selector: dm.selector,
          inputs: mergedInputs,
          outputs: mergedOutputs,
          host: mergedHost,
          exportAs: dm.exportAs,
          queries: mergedQueries,
          providers: dm.providers
        });
      }
    };
    DirectiveResolver.decorators = [{type: core_1.Injectable}];
    DirectiveResolver.ctorParameters = [{type: core_private_1.ReflectorReader}];
    return DirectiveResolver;
  }());
  exports.DirectiveResolver = DirectiveResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/lifecycle_reflector.js", ["@angular/core", "../core_private", "./facade/collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var collection_1 = $__require('./facade/collection');
  var LIFECYCLE_INTERFACES = collection_1.MapWrapper.createFromPairs([[core_private_1.LifecycleHooks.OnInit, core_1.OnInit], [core_private_1.LifecycleHooks.OnDestroy, core_1.OnDestroy], [core_private_1.LifecycleHooks.DoCheck, core_1.DoCheck], [core_private_1.LifecycleHooks.OnChanges, core_1.OnChanges], [core_private_1.LifecycleHooks.AfterContentInit, core_1.AfterContentInit], [core_private_1.LifecycleHooks.AfterContentChecked, core_1.AfterContentChecked], [core_private_1.LifecycleHooks.AfterViewInit, core_1.AfterViewInit], [core_private_1.LifecycleHooks.AfterViewChecked, core_1.AfterViewChecked]]);
  var LIFECYCLE_PROPS = collection_1.MapWrapper.createFromPairs([[core_private_1.LifecycleHooks.OnInit, 'ngOnInit'], [core_private_1.LifecycleHooks.OnDestroy, 'ngOnDestroy'], [core_private_1.LifecycleHooks.DoCheck, 'ngDoCheck'], [core_private_1.LifecycleHooks.OnChanges, 'ngOnChanges'], [core_private_1.LifecycleHooks.AfterContentInit, 'ngAfterContentInit'], [core_private_1.LifecycleHooks.AfterContentChecked, 'ngAfterContentChecked'], [core_private_1.LifecycleHooks.AfterViewInit, 'ngAfterViewInit'], [core_private_1.LifecycleHooks.AfterViewChecked, 'ngAfterViewChecked']]);
  function hasLifecycleHook(hook, token) {
    var lcInterface = LIFECYCLE_INTERFACES.get(hook);
    var lcProp = LIFECYCLE_PROPS.get(hook);
    return core_private_1.reflector.hasLifecycleHook(token, lcInterface, lcProp);
  }
  exports.hasLifecycleHook = hasLifecycleHook;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ng_module_resolver.js", ["@angular/core", "../core_private", "../src/facade/exceptions", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var exceptions_1 = $__require('../src/facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  function _isNgModuleMetadata(obj) {
    return obj instanceof core_1.NgModuleMetadata;
  }
  var NgModuleResolver = (function() {
    function NgModuleResolver(_reflector) {
      if (_reflector === void 0) {
        _reflector = core_private_1.reflector;
      }
      this._reflector = _reflector;
    }
    NgModuleResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var ngModuleMeta = this._reflector.annotations(type).find(_isNgModuleMetadata);
      if (lang_1.isPresent(ngModuleMeta)) {
        return ngModuleMeta;
      } else {
        if (throwIfNotFound) {
          throw new exceptions_1.BaseException("No NgModule metadata found for '" + lang_1.stringify(type) + "'.");
        }
        return null;
      }
    };
    NgModuleResolver.decorators = [{type: core_1.Injectable}];
    NgModuleResolver.ctorParameters = [{type: core_private_1.ReflectorReader}];
    return NgModuleResolver;
  }());
  exports.NgModuleResolver = NgModuleResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/pipe_resolver.js", ["@angular/core", "../core_private", "./facade/exceptions", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  function _isPipeMetadata(type) {
    return type instanceof core_1.PipeMetadata;
  }
  var PipeResolver = (function() {
    function PipeResolver(_reflector) {
      if (_reflector === void 0) {
        _reflector = core_private_1.reflector;
      }
      this._reflector = _reflector;
    }
    PipeResolver.prototype.resolve = function(type, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      var metas = this._reflector.annotations(core_1.resolveForwardRef(type));
      if (lang_1.isPresent(metas)) {
        var annotation = metas.find(_isPipeMetadata);
        if (lang_1.isPresent(annotation)) {
          return annotation;
        }
      }
      if (throwIfNotFound) {
        throw new exceptions_1.BaseException("No Pipe decorator found on " + lang_1.stringify(type));
      }
      return null;
    };
    PipeResolver.decorators = [{type: core_1.Injectable}];
    PipeResolver.ctorParameters = [{type: core_private_1.ReflectorReader}];
    return PipeResolver;
  }());
  exports.PipeResolver = PipeResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/metadata_resolver.js", ["@angular/core", "../core_private", "../src/facade/collection", "./assertions", "./compile_metadata", "./config", "./directive_resolver", "./facade/exceptions", "./facade/lang", "./identifiers", "./lifecycle_reflector", "./ng_module_resolver", "./pipe_resolver", "./schema/element_schema_registry", "./url_resolver", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var collection_1 = $__require('../src/facade/collection');
  var assertions_1 = $__require('./assertions');
  var cpl = $__require('./compile_metadata');
  var config_1 = $__require('./config');
  var directive_resolver_1 = $__require('./directive_resolver');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var identifiers_1 = $__require('./identifiers');
  var lifecycle_reflector_1 = $__require('./lifecycle_reflector');
  var ng_module_resolver_1 = $__require('./ng_module_resolver');
  var pipe_resolver_1 = $__require('./pipe_resolver');
  var element_schema_registry_1 = $__require('./schema/element_schema_registry');
  var url_resolver_1 = $__require('./url_resolver');
  var util_1 = $__require('./util');
  var CompileMetadataResolver = (function() {
    function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _config, _console, _schemaRegistry, _reflector) {
      if (_reflector === void 0) {
        _reflector = core_private_1.reflector;
      }
      this._ngModuleResolver = _ngModuleResolver;
      this._directiveResolver = _directiveResolver;
      this._pipeResolver = _pipeResolver;
      this._config = _config;
      this._console = _console;
      this._schemaRegistry = _schemaRegistry;
      this._reflector = _reflector;
      this._directiveCache = new Map();
      this._pipeCache = new Map();
      this._ngModuleCache = new Map();
      this._ngModuleOfTypes = new Map();
      this._anonymousTypes = new Map();
      this._anonymousTypeIndex = 0;
    }
    CompileMetadataResolver.prototype.sanitizeTokenName = function(token) {
      var identifier = lang_1.stringify(token);
      if (identifier.indexOf('(') >= 0) {
        var found = this._anonymousTypes.get(token);
        if (lang_1.isBlank(found)) {
          this._anonymousTypes.set(token, this._anonymousTypeIndex++);
          found = this._anonymousTypes.get(token);
        }
        identifier = "anonymous_token_" + found + "_";
      }
      return util_1.sanitizeIdentifier(identifier);
    };
    CompileMetadataResolver.prototype.clearCacheFor = function(type) {
      this._directiveCache.delete(type);
      this._pipeCache.delete(type);
      this._ngModuleOfTypes.delete(type);
      this._ngModuleCache.clear();
    };
    CompileMetadataResolver.prototype.clearCache = function() {
      this._directiveCache.clear();
      this._pipeCache.clear();
      this._ngModuleCache.clear();
      this._ngModuleOfTypes.clear();
    };
    CompileMetadataResolver.prototype.getAnimationEntryMetadata = function(entry) {
      var _this = this;
      var defs = entry.definitions.map(function(def) {
        return _this.getAnimationStateMetadata(def);
      });
      return new cpl.CompileAnimationEntryMetadata(entry.name, defs);
    };
    CompileMetadataResolver.prototype.getAnimationStateMetadata = function(value) {
      if (value instanceof core_1.AnimationStateDeclarationMetadata) {
        var styles = this.getAnimationStyleMetadata(value.styles);
        return new cpl.CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
      } else if (value instanceof core_1.AnimationStateTransitionMetadata) {
        return new cpl.CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this.getAnimationMetadata(value.steps));
      }
      return null;
    };
    CompileMetadataResolver.prototype.getAnimationStyleMetadata = function(value) {
      return new cpl.CompileAnimationStyleMetadata(value.offset, value.styles);
    };
    CompileMetadataResolver.prototype.getAnimationMetadata = function(value) {
      var _this = this;
      if (value instanceof core_1.AnimationStyleMetadata) {
        return this.getAnimationStyleMetadata(value);
      } else if (value instanceof core_1.AnimationKeyframesSequenceMetadata) {
        return new cpl.CompileAnimationKeyframesSequenceMetadata(value.steps.map(function(entry) {
          return _this.getAnimationStyleMetadata(entry);
        }));
      } else if (value instanceof core_1.AnimationAnimateMetadata) {
        var animateData = this.getAnimationMetadata(value.styles);
        return new cpl.CompileAnimationAnimateMetadata(value.timings, animateData);
      } else if (value instanceof core_1.AnimationWithStepsMetadata) {
        var steps = value.steps.map(function(step) {
          return _this.getAnimationMetadata(step);
        });
        if (value instanceof core_1.AnimationGroupMetadata) {
          return new cpl.CompileAnimationGroupMetadata(steps);
        } else {
          return new cpl.CompileAnimationSequenceMetadata(steps);
        }
      }
      return null;
    };
    CompileMetadataResolver.prototype.getDirectiveMetadata = function(directiveType, throwIfNotFound) {
      var _this = this;
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      directiveType = core_1.resolveForwardRef(directiveType);
      var meta = this._directiveCache.get(directiveType);
      if (lang_1.isBlank(meta)) {
        var dirMeta = this._directiveResolver.resolve(directiveType, throwIfNotFound);
        if (!dirMeta) {
          return null;
        }
        var templateMeta = null;
        var changeDetectionStrategy = null;
        var viewProviders = [];
        var moduleUrl = staticTypeModuleUrl(directiveType);
        var viewDirectiveTypes = [];
        var viewPipeTypes = [];
        var entryComponentTypes = [];
        var selector = dirMeta.selector;
        if (dirMeta instanceof core_1.ComponentMetadata) {
          var cmpMeta = dirMeta;
          assertions_1.assertArrayOfStrings('styles', cmpMeta.styles);
          assertions_1.assertInterpolationSymbols('interpolation', cmpMeta.interpolation);
          var animations = lang_1.isPresent(cmpMeta.animations) ? cmpMeta.animations.map(function(e) {
            return _this.getAnimationEntryMetadata(e);
          }) : null;
          assertions_1.assertArrayOfStrings('styles', cmpMeta.styles);
          assertions_1.assertArrayOfStrings('styleUrls', cmpMeta.styleUrls);
          templateMeta = new cpl.CompileTemplateMetadata({
            encapsulation: cmpMeta.encapsulation,
            template: cmpMeta.template,
            templateUrl: cmpMeta.templateUrl,
            styles: cmpMeta.styles,
            styleUrls: cmpMeta.styleUrls,
            animations: animations,
            interpolation: cmpMeta.interpolation
          });
          changeDetectionStrategy = cmpMeta.changeDetection;
          if (lang_1.isPresent(dirMeta.viewProviders)) {
            viewProviders = this.getProvidersMetadata(verifyNonBlankProviders(directiveType, dirMeta.viewProviders, 'viewProviders'), []);
          }
          moduleUrl = componentModuleUrl(this._reflector, directiveType, cmpMeta);
          if (cmpMeta.entryComponents) {
            entryComponentTypes = flattenArray(cmpMeta.entryComponents).map(function(type) {
              return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
            });
          }
          if (cmpMeta.directives) {
            viewDirectiveTypes = flattenArray(cmpMeta.directives).map(function(type) {
              if (!type) {
                throw new exceptions_1.BaseException("Unexpected directive value '" + type + "' on the View of component '" + lang_1.stringify(directiveType) + "'");
              }
              return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
            });
          }
          if (cmpMeta.pipes) {
            viewPipeTypes = flattenArray(cmpMeta.pipes).map(function(type) {
              if (!type) {
                throw new exceptions_1.BaseException("Unexpected pipe value '" + type + "' on the View of component '" + lang_1.stringify(directiveType) + "'");
              }
              return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
            });
          }
          if (!selector) {
            selector = this._schemaRegistry.getDefaultComponentElementName();
          }
        } else {
          if (!selector) {
            throw new exceptions_1.BaseException("Directive " + lang_1.stringify(directiveType) + " has no selector, please add it!");
          }
        }
        var providers = [];
        if (lang_1.isPresent(dirMeta.providers)) {
          providers = this.getProvidersMetadata(verifyNonBlankProviders(directiveType, dirMeta.providers, 'providers'), entryComponentTypes);
        }
        var queries = [];
        var viewQueries = [];
        if (lang_1.isPresent(dirMeta.queries)) {
          queries = this.getQueriesMetadata(dirMeta.queries, false, directiveType);
          viewQueries = this.getQueriesMetadata(dirMeta.queries, true, directiveType);
        }
        meta = cpl.CompileDirectiveMetadata.create({
          selector: selector,
          exportAs: dirMeta.exportAs,
          isComponent: lang_1.isPresent(templateMeta),
          type: this.getTypeMetadata(directiveType, moduleUrl),
          template: templateMeta,
          changeDetection: changeDetectionStrategy,
          inputs: dirMeta.inputs,
          outputs: dirMeta.outputs,
          host: dirMeta.host,
          providers: providers,
          viewProviders: viewProviders,
          queries: queries,
          viewQueries: viewQueries,
          viewDirectives: viewDirectiveTypes,
          viewPipes: viewPipeTypes,
          entryComponents: entryComponentTypes
        });
        this._directiveCache.set(directiveType, meta);
      }
      return meta;
    };
    CompileMetadataResolver.prototype.getNgModuleMetadata = function(moduleType, throwIfNotFound) {
      var _this = this;
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      moduleType = core_1.resolveForwardRef(moduleType);
      var compileMeta = this._ngModuleCache.get(moduleType);
      if (!compileMeta) {
        var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
        if (!meta) {
          return null;
        }
        var declaredDirectives_1 = [];
        var exportedDirectives_1 = [];
        var declaredPipes_1 = [];
        var exportedPipes_1 = [];
        var importedModules_1 = [];
        var exportedModules_1 = [];
        var providers_1 = [];
        var entryComponents_1 = [];
        var bootstrapComponents = [];
        var schemas = [];
        if (meta.imports) {
          flattenArray(meta.imports).forEach(function(importedType) {
            var importedModuleType;
            if (isValidType(importedType)) {
              importedModuleType = importedType;
            } else if (importedType && importedType.ngModule) {
              var moduleWithProviders = importedType;
              importedModuleType = moduleWithProviders.ngModule;
              if (moduleWithProviders.providers) {
                providers_1.push.apply(providers_1, _this.getProvidersMetadata(moduleWithProviders.providers, entryComponents_1));
              }
            }
            if (importedModuleType) {
              importedModules_1.push(_this.getNgModuleMetadata(importedModuleType, false));
            } else {
              throw new exceptions_1.BaseException("Unexpected value '" + lang_1.stringify(importedType) + "' imported by the module '" + lang_1.stringify(moduleType) + "'");
            }
          });
        }
        if (meta.exports) {
          flattenArray(meta.exports).forEach(function(exportedType) {
            if (!isValidType(exportedType)) {
              throw new exceptions_1.BaseException("Unexpected value '" + lang_1.stringify(exportedType) + "' exported by the module '" + lang_1.stringify(moduleType) + "'");
            }
            var exportedDirMeta;
            var exportedPipeMeta;
            var exportedModuleMeta;
            if (exportedDirMeta = _this.getDirectiveMetadata(exportedType, false)) {
              exportedDirectives_1.push(exportedDirMeta);
            } else if (exportedPipeMeta = _this.getPipeMetadata(exportedType, false)) {
              exportedPipes_1.push(exportedPipeMeta);
            } else if (exportedModuleMeta = _this.getNgModuleMetadata(exportedType, false)) {
              exportedModules_1.push(exportedModuleMeta);
            } else {
              throw new exceptions_1.BaseException("Unexpected value '" + lang_1.stringify(exportedType) + "' exported by the module '" + lang_1.stringify(moduleType) + "'");
            }
          });
        }
        var transitiveModule_1 = this._getTransitiveNgModuleMetadata(importedModules_1, exportedModules_1);
        if (meta.declarations) {
          flattenArray(meta.declarations).forEach(function(declaredType) {
            if (!isValidType(declaredType)) {
              throw new exceptions_1.BaseException("Unexpected value '" + lang_1.stringify(declaredType) + "' declared by the module '" + lang_1.stringify(moduleType) + "'");
            }
            var declaredDirMeta;
            var declaredPipeMeta;
            if (declaredDirMeta = _this.getDirectiveMetadata(declaredType, false)) {
              _this._addDirectiveToModule(declaredDirMeta, moduleType, transitiveModule_1, declaredDirectives_1, true);
            } else if (declaredPipeMeta = _this.getPipeMetadata(declaredType, false)) {
              _this._addPipeToModule(declaredPipeMeta, moduleType, transitiveModule_1, declaredPipes_1, true);
            } else {
              throw new exceptions_1.BaseException("Unexpected value '" + lang_1.stringify(declaredType) + "' declared by the module '" + lang_1.stringify(moduleType) + "'");
            }
          });
        }
        if (meta.providers) {
          providers_1.push.apply(providers_1, this.getProvidersMetadata(meta.providers, entryComponents_1));
        }
        if (meta.entryComponents) {
          entryComponents_1.push.apply(entryComponents_1, flattenArray(meta.entryComponents).map(function(type) {
            return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
          }));
        }
        if (meta.bootstrap) {
          bootstrapComponents.push.apply(bootstrapComponents, flattenArray(meta.bootstrap).map(function(type) {
            return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
          }));
        }
        entryComponents_1.push.apply(entryComponents_1, bootstrapComponents);
        if (meta.schemas) {
          schemas.push.apply(schemas, flattenArray(meta.schemas));
        }
        (_a = transitiveModule_1.entryComponents).push.apply(_a, entryComponents_1);
        (_b = transitiveModule_1.providers).push.apply(_b, providers_1);
        compileMeta = new cpl.CompileNgModuleMetadata({
          type: this.getTypeMetadata(moduleType, staticTypeModuleUrl(moduleType)),
          providers: providers_1,
          entryComponents: entryComponents_1,
          bootstrapComponents: bootstrapComponents,
          schemas: schemas,
          declaredDirectives: declaredDirectives_1,
          exportedDirectives: exportedDirectives_1,
          declaredPipes: declaredPipes_1,
          exportedPipes: exportedPipes_1,
          importedModules: importedModules_1,
          exportedModules: exportedModules_1,
          transitiveModule: transitiveModule_1
        });
        transitiveModule_1.modules.push(compileMeta);
        this._verifyModule(compileMeta);
        this._ngModuleCache.set(moduleType, compileMeta);
      }
      return compileMeta;
      var _a,
          _b;
    };
    CompileMetadataResolver.prototype.addComponentToModule = function(moduleType, compType) {
      var moduleMeta = this.getNgModuleMetadata(moduleType);
      var compMeta = this.getDirectiveMetadata(compType, false);
      this._addDirectiveToModule(compMeta, moduleMeta.type.runtime, moduleMeta.transitiveModule, moduleMeta.declaredDirectives);
      moduleMeta.transitiveModule.entryComponents.push(compMeta.type);
      moduleMeta.entryComponents.push(compMeta.type);
      this._verifyModule(moduleMeta);
    };
    CompileMetadataResolver.prototype._verifyModule = function(moduleMeta) {
      var _this = this;
      moduleMeta.exportedDirectives.forEach(function(dirMeta) {
        if (!moduleMeta.transitiveModule.directivesSet.has(dirMeta.type.runtime)) {
          throw new exceptions_1.BaseException("Can't export directive " + lang_1.stringify(dirMeta.type.runtime) + " from " + lang_1.stringify(moduleMeta.type.runtime) + " as it was neither declared nor imported!");
        }
      });
      moduleMeta.exportedPipes.forEach(function(pipeMeta) {
        if (!moduleMeta.transitiveModule.pipesSet.has(pipeMeta.type.runtime)) {
          throw new exceptions_1.BaseException("Can't export pipe " + lang_1.stringify(pipeMeta.type.runtime) + " from " + lang_1.stringify(moduleMeta.type.runtime) + " as it was neither declared nor imported!");
        }
      });
      moduleMeta.entryComponents.forEach(function(entryComponentType) {
        if (!moduleMeta.transitiveModule.directivesSet.has(entryComponentType.runtime)) {
          _this._addDirectiveToModule(_this.getDirectiveMetadata(entryComponentType.runtime), moduleMeta.type.runtime, moduleMeta.transitiveModule, moduleMeta.declaredDirectives);
          _this._console.warn("NgModule " + lang_1.stringify(moduleMeta.type.runtime) + " uses " + lang_1.stringify(entryComponentType.runtime) + " via \"entryComponents\" but it was neither declared nor imported! This warning will become an error after final.");
        }
      });
      moduleMeta.declaredDirectives.forEach(function(dirMeta) {
        _this._getTransitiveViewDirectivesAndPipes(dirMeta, moduleMeta);
      });
    };
    CompileMetadataResolver.prototype._addTypeToModule = function(type, moduleType) {
      var oldModule = this._ngModuleOfTypes.get(type);
      if (oldModule && oldModule !== moduleType) {
        throw new exceptions_1.BaseException("Type " + lang_1.stringify(type) + " is part of the declarations of 2 modules: " + lang_1.stringify(oldModule) + " and " + lang_1.stringify(moduleType) + "!");
      }
      this._ngModuleOfTypes.set(type, moduleType);
    };
    CompileMetadataResolver.prototype._getTransitiveViewDirectivesAndPipes = function(compMeta, moduleMeta) {
      var _this = this;
      if (!compMeta.isComponent) {
        return;
      }
      var addPipe = function(pipeType) {
        var pipeMeta = _this.getPipeMetadata(pipeType);
        _this._addPipeToModule(pipeMeta, moduleMeta.type.runtime, moduleMeta.transitiveModule, moduleMeta.declaredPipes);
      };
      var addDirective = function(dirType) {
        var dirMeta = _this.getDirectiveMetadata(dirType);
        if (_this._addDirectiveToModule(dirMeta, moduleMeta.type.runtime, moduleMeta.transitiveModule, moduleMeta.declaredDirectives)) {
          _this._getTransitiveViewDirectivesAndPipes(dirMeta, moduleMeta);
        }
      };
      if (compMeta.viewPipes) {
        compMeta.viewPipes.forEach(function(cplType) {
          return addPipe(cplType.runtime);
        });
      }
      if (compMeta.viewDirectives) {
        compMeta.viewDirectives.forEach(function(cplType) {
          return addDirective(cplType.runtime);
        });
      }
      compMeta.entryComponents.forEach(function(entryComponentType) {
        if (!moduleMeta.transitiveModule.directivesSet.has(entryComponentType.runtime)) {
          _this._console.warn("Component " + lang_1.stringify(compMeta.type.runtime) + " in NgModule " + lang_1.stringify(moduleMeta.type.runtime) + " uses " + lang_1.stringify(entryComponentType.runtime) + " via \"entryComponents\" but it was neither declared nor imported into the module! This warning will become an error after final.");
          addDirective(entryComponentType.runtime);
        }
      });
    };
    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function(importedModules, exportedModules) {
      var transitiveModules = getTransitiveModules(importedModules.concat(exportedModules), true);
      var providers = flattenArray(transitiveModules.map(function(ngModule) {
        return ngModule.providers;
      }));
      var entryComponents = flattenArray(transitiveModules.map(function(ngModule) {
        return ngModule.entryComponents;
      }));
      var transitiveExportedModules = getTransitiveModules(importedModules, false);
      var directives = flattenArray(transitiveExportedModules.map(function(ngModule) {
        return ngModule.exportedDirectives;
      }));
      var pipes = flattenArray(transitiveExportedModules.map(function(ngModule) {
        return ngModule.exportedPipes;
      }));
      return new cpl.TransitiveCompileNgModuleMetadata(transitiveModules, providers, entryComponents, directives, pipes);
    };
    CompileMetadataResolver.prototype._addDirectiveToModule = function(dirMeta, moduleType, transitiveModule, declaredDirectives, force) {
      if (force === void 0) {
        force = false;
      }
      if (force || !transitiveModule.directivesSet.has(dirMeta.type.runtime)) {
        transitiveModule.directivesSet.add(dirMeta.type.runtime);
        transitiveModule.directives.push(dirMeta);
        declaredDirectives.push(dirMeta);
        this._addTypeToModule(dirMeta.type.runtime, moduleType);
        return true;
      }
      return false;
    };
    CompileMetadataResolver.prototype._addPipeToModule = function(pipeMeta, moduleType, transitiveModule, declaredPipes, force) {
      if (force === void 0) {
        force = false;
      }
      if (force || !transitiveModule.pipesSet.has(pipeMeta.type.runtime)) {
        transitiveModule.pipesSet.add(pipeMeta.type.runtime);
        transitiveModule.pipes.push(pipeMeta);
        declaredPipes.push(pipeMeta);
        this._addTypeToModule(pipeMeta.type.runtime, moduleType);
        return true;
      }
      return false;
    };
    CompileMetadataResolver.prototype.getTypeMetadata = function(type, moduleUrl, dependencies) {
      if (dependencies === void 0) {
        dependencies = null;
      }
      type = core_1.resolveForwardRef(type);
      return new cpl.CompileTypeMetadata({
        name: this.sanitizeTokenName(type),
        moduleUrl: moduleUrl,
        runtime: type,
        diDeps: this.getDependenciesMetadata(type, dependencies),
        lifecycleHooks: core_private_1.LIFECYCLE_HOOKS_VALUES.filter(function(hook) {
          return lifecycle_reflector_1.hasLifecycleHook(hook, type);
        })
      });
    };
    CompileMetadataResolver.prototype.getFactoryMetadata = function(factory, moduleUrl, dependencies) {
      if (dependencies === void 0) {
        dependencies = null;
      }
      factory = core_1.resolveForwardRef(factory);
      return new cpl.CompileFactoryMetadata({
        name: this.sanitizeTokenName(factory),
        moduleUrl: moduleUrl,
        runtime: factory,
        diDeps: this.getDependenciesMetadata(factory, dependencies)
      });
    };
    CompileMetadataResolver.prototype.getPipeMetadata = function(pipeType, throwIfNotFound) {
      if (throwIfNotFound === void 0) {
        throwIfNotFound = true;
      }
      pipeType = core_1.resolveForwardRef(pipeType);
      var meta = this._pipeCache.get(pipeType);
      if (lang_1.isBlank(meta)) {
        var pipeMeta = this._pipeResolver.resolve(pipeType, throwIfNotFound);
        if (!pipeMeta) {
          return null;
        }
        meta = new cpl.CompilePipeMetadata({
          type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
          name: pipeMeta.name,
          pure: pipeMeta.pure
        });
        this._pipeCache.set(pipeType, meta);
      }
      return meta;
    };
    CompileMetadataResolver.prototype.getDependenciesMetadata = function(typeOrFunc, dependencies) {
      var _this = this;
      var hasUnknownDeps = false;
      var params = lang_1.isPresent(dependencies) ? dependencies : this._reflector.parameters(typeOrFunc);
      if (lang_1.isBlank(params)) {
        params = [];
      }
      var dependenciesMetadata = params.map(function(param) {
        var isAttribute = false;
        var isHost = false;
        var isSelf = false;
        var isSkipSelf = false;
        var isOptional = false;
        var query = null;
        var viewQuery = null;
        var token = null;
        if (lang_1.isArray(param)) {
          param.forEach(function(paramEntry) {
            if (paramEntry instanceof core_1.HostMetadata) {
              isHost = true;
            } else if (paramEntry instanceof core_1.SelfMetadata) {
              isSelf = true;
            } else if (paramEntry instanceof core_1.SkipSelfMetadata) {
              isSkipSelf = true;
            } else if (paramEntry instanceof core_1.OptionalMetadata) {
              isOptional = true;
            } else if (paramEntry instanceof core_1.AttributeMetadata) {
              isAttribute = true;
              token = paramEntry.attributeName;
            } else if (paramEntry instanceof core_1.QueryMetadata) {
              if (paramEntry.isViewQuery) {
                viewQuery = paramEntry;
              } else {
                query = paramEntry;
              }
            } else if (paramEntry instanceof core_1.InjectMetadata) {
              token = paramEntry.token;
            } else if (isValidType(paramEntry) && lang_1.isBlank(token)) {
              token = paramEntry;
            }
          });
        } else {
          token = param;
        }
        if (lang_1.isBlank(token)) {
          hasUnknownDeps = true;
          return null;
        }
        return new cpl.CompileDiDependencyMetadata({
          isAttribute: isAttribute,
          isHost: isHost,
          isSelf: isSelf,
          isSkipSelf: isSkipSelf,
          isOptional: isOptional,
          query: lang_1.isPresent(query) ? _this.getQueryMetadata(query, null, typeOrFunc) : null,
          viewQuery: lang_1.isPresent(viewQuery) ? _this.getQueryMetadata(viewQuery, null, typeOrFunc) : null,
          token: _this.getTokenMetadata(token)
        });
      });
      if (hasUnknownDeps) {
        var depsTokens = dependenciesMetadata.map(function(dep) {
          return dep ? lang_1.stringify(dep.token) : '?';
        }).join(', ');
        throw new exceptions_1.BaseException("Can't resolve all parameters for " + lang_1.stringify(typeOrFunc) + ": (" + depsTokens + ").");
      }
      return dependenciesMetadata;
    };
    CompileMetadataResolver.prototype.getTokenMetadata = function(token) {
      token = core_1.resolveForwardRef(token);
      var compileToken;
      if (lang_1.isString(token)) {
        compileToken = new cpl.CompileTokenMetadata({value: token});
      } else {
        compileToken = new cpl.CompileTokenMetadata({identifier: new cpl.CompileIdentifierMetadata({
            runtime: token,
            name: this.sanitizeTokenName(token),
            moduleUrl: staticTypeModuleUrl(token)
          })});
      }
      return compileToken;
    };
    CompileMetadataResolver.prototype.getProvidersMetadata = function(providers, targetEntryComponents) {
      var _this = this;
      var compileProviders = [];
      providers.forEach(function(provider) {
        provider = core_1.resolveForwardRef(provider);
        if (core_private_1.isProviderLiteral(provider)) {
          provider = core_private_1.createProvider(provider);
        }
        var compileProvider;
        if (lang_1.isArray(provider)) {
          compileProvider = _this.getProvidersMetadata(provider, targetEntryComponents);
        } else if (provider instanceof core_1.Provider) {
          var tokenMeta = _this.getTokenMetadata(provider.token);
          if (tokenMeta.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS))) {
            targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(provider));
          } else {
            compileProvider = _this.getProviderMetadata(provider);
          }
        } else if (isValidType(provider)) {
          compileProvider = _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
        } else {
          throw new exceptions_1.BaseException("Invalid provider - only instances of Provider and Type are allowed, got: " + lang_1.stringify(provider));
        }
        if (compileProvider) {
          compileProviders.push(compileProvider);
        }
      });
      return compileProviders;
    };
    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function(provider) {
      var _this = this;
      var components = [];
      var collectedIdentifiers = [];
      if (provider.useFactory || provider.useExisting || provider.useClass) {
        throw new exceptions_1.BaseException("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!");
      }
      if (!provider.multi) {
        throw new exceptions_1.BaseException("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!");
      }
      convertToCompileValue(provider.useValue, collectedIdentifiers);
      collectedIdentifiers.forEach(function(identifier) {
        var dirMeta = _this.getDirectiveMetadata(identifier.runtime, false);
        if (dirMeta) {
          components.push(dirMeta.type);
        }
      });
      return components;
    };
    CompileMetadataResolver.prototype.getProviderMetadata = function(provider) {
      var compileDeps;
      var compileTypeMetadata = null;
      var compileFactoryMetadata = null;
      if (lang_1.isPresent(provider.useClass)) {
        compileTypeMetadata = this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);
        compileDeps = compileTypeMetadata.diDeps;
      } else if (lang_1.isPresent(provider.useFactory)) {
        compileFactoryMetadata = this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);
        compileDeps = compileFactoryMetadata.diDeps;
      }
      return new cpl.CompileProviderMetadata({
        token: this.getTokenMetadata(provider.token),
        useClass: compileTypeMetadata,
        useValue: convertToCompileValue(provider.useValue, []),
        useFactory: compileFactoryMetadata,
        useExisting: lang_1.isPresent(provider.useExisting) ? this.getTokenMetadata(provider.useExisting) : null,
        deps: compileDeps,
        multi: provider.multi
      });
    };
    CompileMetadataResolver.prototype.getQueriesMetadata = function(queries, isViewQuery, directiveType) {
      var _this = this;
      var res = [];
      collection_1.StringMapWrapper.forEach(queries, function(query, propertyName) {
        if (query.isViewQuery === isViewQuery) {
          res.push(_this.getQueryMetadata(query, propertyName, directiveType));
        }
      });
      return res;
    };
    CompileMetadataResolver.prototype.getQueryMetadata = function(q, propertyName, typeOrFunc) {
      var _this = this;
      var selectors;
      if (q.isVarBindingQuery) {
        selectors = q.varBindings.map(function(varName) {
          return _this.getTokenMetadata(varName);
        });
      } else {
        if (!lang_1.isPresent(q.selector)) {
          throw new exceptions_1.BaseException("Can't construct a query for the property \"" + propertyName + "\" of \"" + lang_1.stringify(typeOrFunc) + "\" since the query selector wasn't defined.");
        }
        selectors = [this.getTokenMetadata(q.selector)];
      }
      return new cpl.CompileQueryMetadata({
        selectors: selectors,
        first: q.first,
        descendants: q.descendants,
        propertyName: propertyName,
        read: lang_1.isPresent(q.read) ? this.getTokenMetadata(q.read) : null
      });
    };
    CompileMetadataResolver.decorators = [{type: core_1.Injectable}];
    CompileMetadataResolver.ctorParameters = [{type: ng_module_resolver_1.NgModuleResolver}, {type: directive_resolver_1.DirectiveResolver}, {type: pipe_resolver_1.PipeResolver}, {type: config_1.CompilerConfig}, {type: core_private_1.Console}, {type: element_schema_registry_1.ElementSchemaRegistry}, {type: core_private_1.ReflectorReader}];
    return CompileMetadataResolver;
  }());
  exports.CompileMetadataResolver = CompileMetadataResolver;
  function getTransitiveModules(modules, includeImports, targetModules, visitedModules) {
    if (targetModules === void 0) {
      targetModules = [];
    }
    if (visitedModules === void 0) {
      visitedModules = new Set();
    }
    modules.forEach(function(ngModule) {
      if (!visitedModules.has(ngModule.type.runtime)) {
        visitedModules.add(ngModule.type.runtime);
        var nestedModules = includeImports ? ngModule.importedModules.concat(ngModule.exportedModules) : ngModule.exportedModules;
        getTransitiveModules(nestedModules, includeImports, targetModules, visitedModules);
        targetModules.push(ngModule);
      }
    });
    return targetModules;
  }
  function flattenArray(tree, out) {
    if (out === void 0) {
      out = [];
    }
    if (tree) {
      for (var i = 0; i < tree.length; i++) {
        var item = core_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
          flattenArray(item, out);
        } else {
          out.push(item);
        }
      }
    }
    return out;
  }
  function verifyNonBlankProviders(directiveType, providersTree, providersType) {
    var flat = [];
    var errMsg;
    flattenArray(providersTree, flat);
    for (var i = 0; i < flat.length; i++) {
      if (lang_1.isBlank(flat[i])) {
        errMsg = flat.map(function(provider) {
          return lang_1.isBlank(provider) ? '?' : lang_1.stringify(provider);
        }).join(', ');
        throw new exceptions_1.BaseException("One or more of " + providersType + " for \"" + lang_1.stringify(directiveType) + "\" were not defined: [" + errMsg + "].");
      }
    }
    return providersTree;
  }
  function isValidType(value) {
    return cpl.isStaticSymbol(value) || (value instanceof lang_1.Type);
  }
  function staticTypeModuleUrl(value) {
    return cpl.isStaticSymbol(value) ? value.filePath : null;
  }
  function componentModuleUrl(reflector, type, cmpMetadata) {
    if (cpl.isStaticSymbol(type)) {
      return staticTypeModuleUrl(type);
    }
    if (lang_1.isPresent(cmpMetadata.moduleId)) {
      var moduleId = cmpMetadata.moduleId;
      var scheme = url_resolver_1.getUrlScheme(moduleId);
      return lang_1.isPresent(scheme) && scheme.length > 0 ? moduleId : "package:" + moduleId + util_1.MODULE_SUFFIX;
    }
    return reflector.importUri(type);
  }
  function convertToCompileValue(value, targetIdentifiers) {
    return util_1.visitValue(value, new _CompileValueConverter(), targetIdentifiers);
  }
  var _CompileValueConverter = (function(_super) {
    __extends(_CompileValueConverter, _super);
    function _CompileValueConverter() {
      _super.apply(this, arguments);
    }
    _CompileValueConverter.prototype.visitOther = function(value, targetIdentifiers) {
      var identifier;
      if (cpl.isStaticSymbol(value)) {
        identifier = new cpl.CompileIdentifierMetadata({
          name: value.name,
          moduleUrl: value.filePath,
          runtime: value
        });
      } else {
        identifier = new cpl.CompileIdentifierMetadata({runtime: value});
      }
      targetIdentifiers.push(identifier);
      return identifier;
    };
    return _CompileValueConverter;
  }(util_1.ValueTransformer));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ng_module_compiler.js", ["@angular/core", "../core_private", "./compile_metadata", "./facade/lang", "./identifiers", "./output/output_ast", "./output/value_util", "./parse_util", "./provider_analyzer", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var compile_metadata_1 = $__require('./compile_metadata');
  var lang_1 = $__require('./facade/lang');
  var identifiers_1 = $__require('./identifiers');
  var o = $__require('./output/output_ast');
  var value_util_1 = $__require('./output/value_util');
  var parse_util_1 = $__require('./parse_util');
  var provider_analyzer_1 = $__require('./provider_analyzer');
  var util_1 = $__require('./util');
  var ComponentFactoryDependency = (function() {
    function ComponentFactoryDependency(comp, placeholder) {
      this.comp = comp;
      this.placeholder = placeholder;
    }
    return ComponentFactoryDependency;
  }());
  exports.ComponentFactoryDependency = ComponentFactoryDependency;
  var NgModuleCompileResult = (function() {
    function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {
      this.statements = statements;
      this.ngModuleFactoryVar = ngModuleFactoryVar;
      this.dependencies = dependencies;
    }
    return NgModuleCompileResult;
  }());
  exports.NgModuleCompileResult = NgModuleCompileResult;
  var NgModuleCompiler = (function() {
    function NgModuleCompiler() {}
    NgModuleCompiler.prototype.compile = function(ngModuleMeta, extraProviders) {
      var sourceFileName = lang_1.isPresent(ngModuleMeta.type.moduleUrl) ? "in NgModule " + ngModuleMeta.type.name + " in " + ngModuleMeta.type.moduleUrl : "in NgModule " + ngModuleMeta.type.name;
      var sourceFile = new parse_util_1.ParseSourceFile('', sourceFileName);
      var sourceSpan = new parse_util_1.ParseSourceSpan(new parse_util_1.ParseLocation(sourceFile, null, null, null), new parse_util_1.ParseLocation(sourceFile, null, null, null));
      var deps = [];
      var bootstrapComponentFactories = [];
      var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function(entryComponent) {
        var id = new compile_metadata_1.CompileIdentifierMetadata({name: entryComponent.name});
        if (ngModuleMeta.bootstrapComponents.indexOf(entryComponent) > -1) {
          bootstrapComponentFactories.push(id);
        }
        deps.push(new ComponentFactoryDependency(entryComponent, id));
        return id;
      });
      var builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);
      var providerParser = new provider_analyzer_1.NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);
      providerParser.parse().forEach(function(provider) {
        return builder.addProvider(provider);
      });
      var injectorClass = builder.build();
      var ngModuleFactoryVar = ngModuleMeta.type.name + "NgFactory";
      var ngModuleFactoryStmt = o.variable(ngModuleFactoryVar).set(o.importExpr(identifiers_1.Identifiers.NgModuleFactory).instantiate([o.variable(injectorClass.name), o.importExpr(ngModuleMeta.type)], o.importType(identifiers_1.Identifiers.NgModuleFactory, [o.importType(ngModuleMeta.type)], [o.TypeModifier.Const]))).toDeclStmt(null, [o.StmtModifier.Final]);
      return new NgModuleCompileResult([injectorClass, ngModuleFactoryStmt], ngModuleFactoryVar, deps);
    };
    NgModuleCompiler.decorators = [{type: core_1.Injectable}];
    return NgModuleCompiler;
  }());
  exports.NgModuleCompiler = NgModuleCompiler;
  var _InjectorBuilder = (function() {
    function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {
      this._ngModuleMeta = _ngModuleMeta;
      this._entryComponentFactories = _entryComponentFactories;
      this._bootstrapComponentFactories = _bootstrapComponentFactories;
      this._sourceSpan = _sourceSpan;
      this._instances = new compile_metadata_1.CompileIdentifierMap();
      this._fields = [];
      this._createStmts = [];
      this._destroyStmts = [];
      this._getters = [];
    }
    _InjectorBuilder.prototype.addProvider = function(resolvedProvider) {
      var _this = this;
      var providerValueExpressions = resolvedProvider.providers.map(function(provider) {
        return _this._getProviderValue(provider);
      });
      var propName = "_" + resolvedProvider.token.name + "_" + this._instances.size;
      var instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);
      if (resolvedProvider.lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnDestroy) !== -1) {
        this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());
      }
      this._instances.add(resolvedProvider.token, instance);
    };
    _InjectorBuilder.prototype.build = function() {
      var _this = this;
      var getMethodStmts = this._instances.keys().map(function(token) {
        var providerExpr = _this._instances.get(token);
        return new o.IfStmt(InjectMethodVars.token.identical(util_1.createDiTokenExpression(token)), [new o.ReturnStatement(providerExpr)]);
      });
      var methods = [new o.ClassMethod('createInternal', [], this._createStmts.concat(new o.ReturnStatement(this._instances.get(identifiers_1.identifierToken(this._ngModuleMeta.type)))), o.importType(this._ngModuleMeta.type)), new o.ClassMethod('getInternal', [new o.FnParam(InjectMethodVars.token.name, o.DYNAMIC_TYPE), new o.FnParam(InjectMethodVars.notFoundResult.name, o.DYNAMIC_TYPE)], getMethodStmts.concat([new o.ReturnStatement(InjectMethodVars.notFoundResult)]), o.DYNAMIC_TYPE), new o.ClassMethod('destroyInternal', [], this._destroyStmts)];
      var ctor = new o.ClassMethod(null, [new o.FnParam(InjectorProps.parent.name, o.importType(identifiers_1.Identifiers.Injector))], [o.SUPER_EXPR.callFn([o.variable(InjectorProps.parent.name), o.literalArr(this._entryComponentFactories.map(function(componentFactory) {
        return o.importExpr(componentFactory);
      })), o.literalArr(this._bootstrapComponentFactories.map(function(componentFactory) {
        return o.importExpr(componentFactory);
      }))]).toStmt()]);
      var injClassName = this._ngModuleMeta.type.name + "Injector";
      return new o.ClassStmt(injClassName, o.importExpr(identifiers_1.Identifiers.NgModuleInjector, [o.importType(this._ngModuleMeta.type)]), this._fields, this._getters, ctor, methods);
    };
    _InjectorBuilder.prototype._getProviderValue = function(provider) {
      var _this = this;
      var result;
      if (lang_1.isPresent(provider.useExisting)) {
        result = this._getDependency(new compile_metadata_1.CompileDiDependencyMetadata({token: provider.useExisting}));
      } else if (lang_1.isPresent(provider.useFactory)) {
        var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
        var depsExpr = deps.map(function(dep) {
          return _this._getDependency(dep);
        });
        result = o.importExpr(provider.useFactory).callFn(depsExpr);
      } else if (lang_1.isPresent(provider.useClass)) {
        var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
        var depsExpr = deps.map(function(dep) {
          return _this._getDependency(dep);
        });
        result = o.importExpr(provider.useClass).instantiate(depsExpr, o.importType(provider.useClass));
      } else {
        result = value_util_1.convertValueToOutputAst(provider.useValue);
      }
      return result;
    };
    _InjectorBuilder.prototype._createProviderProperty = function(propName, provider, providerValueExpressions, isMulti, isEager) {
      var resolvedProviderValueExpr;
      var type;
      if (isMulti) {
        resolvedProviderValueExpr = o.literalArr(providerValueExpressions);
        type = new o.ArrayType(o.DYNAMIC_TYPE);
      } else {
        resolvedProviderValueExpr = providerValueExpressions[0];
        type = providerValueExpressions[0].type;
      }
      if (lang_1.isBlank(type)) {
        type = o.DYNAMIC_TYPE;
      }
      if (isEager) {
        this._fields.push(new o.ClassField(propName, type));
        this._createStmts.push(o.THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
      } else {
        var internalField = "_" + propName;
        this._fields.push(new o.ClassField(internalField, type));
        var getterStmts = [new o.IfStmt(o.THIS_EXPR.prop(internalField).isBlank(), [o.THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]), new o.ReturnStatement(o.THIS_EXPR.prop(internalField))];
        this._getters.push(new o.ClassGetter(propName, getterStmts, type));
      }
      return o.THIS_EXPR.prop(propName);
    };
    _InjectorBuilder.prototype._getDependency = function(dep) {
      var result = null;
      if (dep.isValue) {
        result = o.literal(dep.value);
      }
      if (!dep.isSkipSelf) {
        if (dep.token && (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector)) || dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ComponentFactoryResolver)))) {
          result = o.THIS_EXPR;
        }
        if (lang_1.isBlank(result)) {
          result = this._instances.get(dep.token);
        }
      }
      if (lang_1.isBlank(result)) {
        var args = [util_1.createDiTokenExpression(dep.token)];
        if (dep.isOptional) {
          args.push(o.NULL_EXPR);
        }
        result = InjectorProps.parent.callMethod('get', args);
      }
      return result;
    };
    return _InjectorBuilder;
  }());
  var InjectorProps = (function() {
    function InjectorProps() {}
    InjectorProps.parent = o.THIS_EXPR.prop('parent');
    return InjectorProps;
  }());
  var InjectMethodVars = (function() {
    function InjectMethodVars() {}
    InjectMethodVars.token = o.variable('token');
    InjectMethodVars.notFoundResult = o.variable('notFoundResult');
    return InjectMethodVars;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/path_util.js", ["../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/;
  var ImportGenerator = (function() {
    function ImportGenerator() {}
    ImportGenerator.parseAssetUrl = function(url) {
      return AssetUrl.parse(url);
    };
    return ImportGenerator;
  }());
  exports.ImportGenerator = ImportGenerator;
  var AssetUrl = (function() {
    function AssetUrl(packageName, firstLevelDir, modulePath) {
      this.packageName = packageName;
      this.firstLevelDir = firstLevelDir;
      this.modulePath = modulePath;
    }
    AssetUrl.parse = function(url, allowNonMatching) {
      if (allowNonMatching === void 0) {
        allowNonMatching = true;
      }
      var match = url.match(_ASSET_URL_RE);
      if (match !== null) {
        return new AssetUrl(match[1], match[2], match[3]);
      }
      if (allowNonMatching) {
        return null;
      }
      throw new exceptions_1.BaseException("Url " + url + " is not a valid asset: url");
    };
    return AssetUrl;
  }());
  exports.AssetUrl = AssetUrl;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/abstract_emitter.js", ["../facade/exceptions", "../facade/lang", "./output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var o = $__require('./output_ast');
  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  exports.CATCH_ERROR_VAR = o.variable('error');
  exports.CATCH_STACK_VAR = o.variable('stack');
  var OutputEmitter = (function() {
    function OutputEmitter() {}
    return OutputEmitter;
  }());
  exports.OutputEmitter = OutputEmitter;
  var _EmittedLine = (function() {
    function _EmittedLine(indent) {
      this.indent = indent;
      this.parts = [];
    }
    return _EmittedLine;
  }());
  var EmitterVisitorContext = (function() {
    function EmitterVisitorContext(_exportedVars, _indent) {
      this._exportedVars = _exportedVars;
      this._indent = _indent;
      this._classes = [];
      this._lines = [new _EmittedLine(_indent)];
    }
    EmitterVisitorContext.createRoot = function(exportedVars) {
      return new EmitterVisitorContext(exportedVars, 0);
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
      get: function() {
        return this._lines[this._lines.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.isExportedVar = function(varName) {
      return this._exportedVars.indexOf(varName) !== -1;
    };
    EmitterVisitorContext.prototype.println = function(lastPart) {
      if (lastPart === void 0) {
        lastPart = '';
      }
      this.print(lastPart, true);
    };
    EmitterVisitorContext.prototype.lineIsEmpty = function() {
      return this._currentLine.parts.length === 0;
    };
    EmitterVisitorContext.prototype.print = function(part, newLine) {
      if (newLine === void 0) {
        newLine = false;
      }
      if (part.length > 0) {
        this._currentLine.parts.push(part);
      }
      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    };
    EmitterVisitorContext.prototype.removeEmptyLastLine = function() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    };
    EmitterVisitorContext.prototype.incIndent = function() {
      this._indent++;
      this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.decIndent = function() {
      this._indent--;
      this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.pushClass = function(clazz) {
      this._classes.push(clazz);
    };
    EmitterVisitorContext.prototype.popClass = function() {
      return this._classes.pop();
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
      get: function() {
        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
      },
      enumerable: true,
      configurable: true
    });
    EmitterVisitorContext.prototype.toSource = function() {
      var lines = this._lines;
      if (lines[lines.length - 1].parts.length === 0) {
        lines = lines.slice(0, lines.length - 1);
      }
      return lines.map(function(line) {
        if (line.parts.length > 0) {
          return _createIndent(line.indent) + line.parts.join('');
        } else {
          return '';
        }
      }).join('\n');
    };
    return EmitterVisitorContext;
  }());
  exports.EmitterVisitorContext = EmitterVisitorContext;
  var AbstractEmitterVisitor = (function() {
    function AbstractEmitterVisitor(_escapeDollarInStrings) {
      this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    AbstractEmitterVisitor.prototype.visitExpressionStmt = function(stmt, ctx) {
      stmt.expr.visitExpression(this, ctx);
      ctx.println(';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReturnStmt = function(stmt, ctx) {
      ctx.print("return ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(';');
      return null;
    };
    AbstractEmitterVisitor.prototype.visitIfStmt = function(stmt, ctx) {
      ctx.print("if (");
      stmt.condition.visitExpression(this, ctx);
      ctx.print(") {");
      var hasElseCase = lang_1.isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(" ");
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(" ");
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();
        if (hasElseCase) {
          ctx.println("} else {");
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }
      ctx.println("}");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitThrowStmt = function(stmt, ctx) {
      ctx.print("throw ");
      stmt.error.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitCommentStmt = function(stmt, ctx) {
      var lines = stmt.comment.split('\n');
      lines.forEach(function(line) {
        ctx.println("// " + line);
      });
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      ctx.print(expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print("[");
      expr.index.visitExpression(this, ctx);
      ctx.print("] = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitWritePropExpr = function(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print('(');
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print("." + expr.name + " = ");
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(')');
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function(expr, ctx) {
      expr.receiver.visitExpression(this, ctx);
      var name = expr.name;
      if (lang_1.isPresent(expr.builtin)) {
        name = this.getBuiltinMethodName(expr.builtin);
        if (lang_1.isBlank(name)) {
          return null;
        }
      }
      ctx.print("." + name + "(");
      this.visitAllExpressions(expr.args, ctx, ",");
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print("(");
      this.visitAllExpressions(expr.args, ctx, ',');
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadVarExpr = function(ast, ctx) {
      var varName = ast.name;
      if (lang_1.isPresent(ast.builtin)) {
        switch (ast.builtin) {
          case o.BuiltinVar.Super:
            varName = 'super';
            break;
          case o.BuiltinVar.This:
            varName = 'this';
            break;
          case o.BuiltinVar.CatchError:
            varName = exports.CATCH_ERROR_VAR.name;
            break;
          case o.BuiltinVar.CatchStack:
            varName = exports.CATCH_STACK_VAR.name;
            break;
          default:
            throw new exceptions_1.BaseException("Unknown builtin variable " + ast.builtin);
        }
      }
      ctx.print(varName);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function(ast, ctx) {
      ctx.print("new ");
      ast.classExpr.visitExpression(this, ctx);
      ctx.print("(");
      this.visitAllExpressions(ast.args, ctx, ',');
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralExpr = function(ast, ctx) {
      var value = ast.value;
      if (lang_1.isString(value)) {
        ctx.print(escapeSingleQuoteString(value, this._escapeDollarInStrings));
      } else if (lang_1.isBlank(value)) {
        ctx.print('null');
      } else {
        ctx.print("" + value);
      }
      return null;
    };
    AbstractEmitterVisitor.prototype.visitConditionalExpr = function(ast, ctx) {
      ctx.print("(");
      ast.condition.visitExpression(this, ctx);
      ctx.print('? ');
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(': ');
      ast.falseCase.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitNotExpr = function(ast, ctx) {
      ctx.print('!');
      ast.condition.visitExpression(this, ctx);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function(ast, ctx) {
      var opStr;
      switch (ast.operator) {
        case o.BinaryOperator.Equals:
          opStr = '==';
          break;
        case o.BinaryOperator.Identical:
          opStr = '===';
          break;
        case o.BinaryOperator.NotEquals:
          opStr = '!=';
          break;
        case o.BinaryOperator.NotIdentical:
          opStr = '!==';
          break;
        case o.BinaryOperator.And:
          opStr = '&&';
          break;
        case o.BinaryOperator.Or:
          opStr = '||';
          break;
        case o.BinaryOperator.Plus:
          opStr = '+';
          break;
        case o.BinaryOperator.Minus:
          opStr = '-';
          break;
        case o.BinaryOperator.Divide:
          opStr = '/';
          break;
        case o.BinaryOperator.Multiply:
          opStr = '*';
          break;
        case o.BinaryOperator.Modulo:
          opStr = '%';
          break;
        case o.BinaryOperator.Lower:
          opStr = '<';
          break;
        case o.BinaryOperator.LowerEquals:
          opStr = '<=';
          break;
        case o.BinaryOperator.Bigger:
          opStr = '>';
          break;
        case o.BinaryOperator.BiggerEquals:
          opStr = '>=';
          break;
        default:
          throw new exceptions_1.BaseException("Unknown operator " + ast.operator);
      }
      ctx.print("(");
      ast.lhs.visitExpression(this, ctx);
      ctx.print(" " + opStr + " ");
      ast.rhs.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadPropExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(".");
      ctx.print(ast.name);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print("[");
      ast.index.visitExpression(this, ctx);
      ctx.print("]");
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function(ast, ctx) {
      var useNewLine = ast.entries.length > 1;
      ctx.print("[", useNewLine);
      ctx.incIndent();
      this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
      ctx.decIndent();
      ctx.print("]", useNewLine);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function(ast, ctx) {
      var _this = this;
      var useNewLine = ast.entries.length > 1;
      ctx.print("{", useNewLine);
      ctx.incIndent();
      this.visitAllObjects(function(entry) {
        ctx.print(escapeSingleQuoteString(entry[0], _this._escapeDollarInStrings) + ": ");
        entry[1].visitExpression(_this, ctx);
      }, ast.entries, ctx, ',', useNewLine);
      ctx.decIndent();
      ctx.print("}", useNewLine);
      return null;
    };
    AbstractEmitterVisitor.prototype.visitAllExpressions = function(expressions, ctx, separator, newLine) {
      var _this = this;
      if (newLine === void 0) {
        newLine = false;
      }
      this.visitAllObjects(function(expr) {
        return expr.visitExpression(_this, ctx);
      }, expressions, ctx, separator, newLine);
    };
    AbstractEmitterVisitor.prototype.visitAllObjects = function(handler, expressions, ctx, separator, newLine) {
      if (newLine === void 0) {
        newLine = false;
      }
      for (var i = 0; i < expressions.length; i++) {
        if (i > 0) {
          ctx.print(separator, newLine);
        }
        handler(expressions[i]);
      }
      if (newLine) {
        ctx.println();
      }
    };
    AbstractEmitterVisitor.prototype.visitAllStatements = function(statements, ctx) {
      var _this = this;
      statements.forEach(function(stmt) {
        return stmt.visitStatement(_this, ctx);
      });
    };
    return AbstractEmitterVisitor;
  }());
  exports.AbstractEmitterVisitor = AbstractEmitterVisitor;
  function escapeSingleQuoteString(input, escapeDollar) {
    if (lang_1.isBlank(input)) {
      return null;
    }
    var body = lang_1.StringWrapper.replaceAllMapped(input, _SINGLE_QUOTE_ESCAPE_STRING_RE, function(match) {
      if (match[0] == '$') {
        return escapeDollar ? '\\$' : '$';
      } else if (match[0] == '\n') {
        return '\\n';
      } else if (match[0] == '\r') {
        return '\\r';
      } else {
        return "\\" + match[0];
      }
    });
    return "'" + body + "'";
  }
  exports.escapeSingleQuoteString = escapeSingleQuoteString;
  function _createIndent(count) {
    var res = '';
    for (var i = 0; i < count; i++) {
      res += '  ';
    }
    return res;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/ts_emitter.js", ["../facade/exceptions", "../facade/lang", "./abstract_emitter", "./output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var abstract_emitter_1 = $__require('./abstract_emitter');
  var o = $__require('./output_ast');
  var _debugModuleUrl = 'asset://debug/lib';
  function debugOutputAstAsTypeScript(ast) {
    var converter = new _TsEmitterVisitor(_debugModuleUrl);
    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot([]);
    var asts;
    if (lang_1.isArray(ast)) {
      asts = ast;
    } else {
      asts = [ast];
    }
    asts.forEach(function(ast) {
      if (ast instanceof o.Statement) {
        ast.visitStatement(converter, ctx);
      } else if (ast instanceof o.Expression) {
        ast.visitExpression(converter, ctx);
      } else if (ast instanceof o.Type) {
        ast.visitType(converter, ctx);
      } else {
        throw new exceptions_1.BaseException("Don't know how to print debug info for " + ast);
      }
    });
    return ctx.toSource();
  }
  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
  var TypeScriptEmitter = (function() {
    function TypeScriptEmitter(_importGenerator) {
      this._importGenerator = _importGenerator;
    }
    TypeScriptEmitter.prototype.emitStatements = function(moduleUrl, stmts, exportedVars) {
      var _this = this;
      var converter = new _TsEmitterVisitor(moduleUrl);
      var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot(exportedVars);
      converter.visitAllStatements(stmts, ctx);
      var srcParts = [];
      converter.importsWithPrefixes.forEach(function(prefix, importedModuleUrl) {
        srcParts.push("imp" + ("ort * as " + prefix + " from '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "';"));
      });
      srcParts.push(ctx.toSource());
      return srcParts.join('\n');
    };
    return TypeScriptEmitter;
  }());
  exports.TypeScriptEmitter = TypeScriptEmitter;
  var _TsEmitterVisitor = (function(_super) {
    __extends(_TsEmitterVisitor, _super);
    function _TsEmitterVisitor(_moduleUrl) {
      _super.call(this, false);
      this._moduleUrl = _moduleUrl;
      this.importsWithPrefixes = new Map();
    }
    _TsEmitterVisitor.prototype.visitType = function(t, ctx, defaultType) {
      if (defaultType === void 0) {
        defaultType = 'any';
      }
      if (lang_1.isPresent(t)) {
        t.visitType(this, ctx);
      } else {
        ctx.print(defaultType);
      }
    };
    _TsEmitterVisitor.prototype.visitExternalExpr = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function(stmt, ctx) {
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      if (stmt.hasModifier(o.StmtModifier.Final)) {
        ctx.print("const");
      } else {
        ctx.print("var");
      }
      ctx.print(" " + stmt.name + ":");
      this.visitType(stmt.type, ctx);
      ctx.print(" = ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(";");
      return null;
    };
    _TsEmitterVisitor.prototype.visitCastExpr = function(ast, ctx) {
      ctx.print("(<");
      ast.type.visitType(this, ctx);
      ctx.print(">");
      ast.value.visitExpression(this, ctx);
      ctx.print(")");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function(stmt, ctx) {
      var _this = this;
      ctx.pushClass(stmt);
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      ctx.print("class " + stmt.name);
      if (lang_1.isPresent(stmt.parent)) {
        ctx.print(" extends ");
        stmt.parent.visitExpression(this, ctx);
      }
      ctx.println(" {");
      ctx.incIndent();
      stmt.fields.forEach(function(field) {
        return _this._visitClassField(field, ctx);
      });
      if (lang_1.isPresent(stmt.constructorMethod)) {
        this._visitClassConstructor(stmt, ctx);
      }
      stmt.getters.forEach(function(getter) {
        return _this._visitClassGetter(getter, ctx);
      });
      stmt.methods.forEach(function(method) {
        return _this._visitClassMethod(method, ctx);
      });
      ctx.decIndent();
      ctx.println("}");
      ctx.popClass();
      return null;
    };
    _TsEmitterVisitor.prototype._visitClassField = function(field, ctx) {
      if (field.hasModifier(o.StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print(field.name);
      ctx.print(':');
      this.visitType(field.type, ctx);
      ctx.println(";");
    };
    _TsEmitterVisitor.prototype._visitClassGetter = function(getter, ctx) {
      if (getter.hasModifier(o.StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print("get " + getter.name + "()");
      ctx.print(':');
      this.visitType(getter.type, ctx);
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(getter.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassConstructor = function(stmt, ctx) {
      ctx.print("constructor(");
      this._visitParams(stmt.constructorMethod.params, ctx);
      ctx.println(") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.constructorMethod.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassMethod = function(method, ctx) {
      if (method.hasModifier(o.StmtModifier.Private)) {
        ctx.print("private ");
      }
      ctx.print(method.name + "(");
      this._visitParams(method.params, ctx);
      ctx.print("):");
      this.visitType(method.type, ctx, 'void');
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(method.body, ctx);
      ctx.decIndent();
      ctx.println("}");
    };
    _TsEmitterVisitor.prototype.visitFunctionExpr = function(ast, ctx) {
      ctx.print("(");
      this._visitParams(ast.params, ctx);
      ctx.print("):");
      this.visitType(ast.type, ctx, 'void');
      ctx.println(" => {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function(stmt, ctx) {
      if (ctx.isExportedVar(stmt.name)) {
        ctx.print("export ");
      }
      ctx.print("function " + stmt.name + "(");
      this._visitParams(stmt.params, ctx);
      ctx.print("):");
      this.visitType(stmt.type, ctx, 'void');
      ctx.println(" {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitTryCatchStmt = function(stmt, ctx) {
      ctx.println("try {");
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println("} catch (" + abstract_emitter_1.CATCH_ERROR_VAR.name + ") {");
      ctx.incIndent();
      var catchStmts = [abstract_emitter_1.CATCH_STACK_VAR.set(abstract_emitter_1.CATCH_ERROR_VAR.prop('stack')).toDeclStmt(null, [o.StmtModifier.Final])].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println("}");
      return null;
    };
    _TsEmitterVisitor.prototype.visitBuiltintType = function(type, ctx) {
      var typeStr;
      switch (type.name) {
        case o.BuiltinTypeName.Bool:
          typeStr = 'boolean';
          break;
        case o.BuiltinTypeName.Dynamic:
          typeStr = 'any';
          break;
        case o.BuiltinTypeName.Function:
          typeStr = 'Function';
          break;
        case o.BuiltinTypeName.Number:
          typeStr = 'number';
          break;
        case o.BuiltinTypeName.Int:
          typeStr = 'number';
          break;
        case o.BuiltinTypeName.String:
          typeStr = 'string';
          break;
        default:
          throw new exceptions_1.BaseException("Unsupported builtin type " + type.name);
      }
      ctx.print(typeStr);
      return null;
    };
    _TsEmitterVisitor.prototype.visitExternalType = function(ast, ctx) {
      this._visitIdentifier(ast.value, ast.typeParams, ctx);
      return null;
    };
    _TsEmitterVisitor.prototype.visitArrayType = function(type, ctx) {
      this.visitType(type.of, ctx);
      ctx.print("[]");
      return null;
    };
    _TsEmitterVisitor.prototype.visitMapType = function(type, ctx) {
      ctx.print("{[key: string]:");
      this.visitType(type.valueType, ctx);
      ctx.print("}");
      return null;
    };
    _TsEmitterVisitor.prototype.getBuiltinMethodName = function(method) {
      var name;
      switch (method) {
        case o.BuiltinMethod.ConcatArray:
          name = 'concat';
          break;
        case o.BuiltinMethod.SubscribeObservable:
          name = 'subscribe';
          break;
        case o.BuiltinMethod.bind:
          name = 'bind';
          break;
        default:
          throw new exceptions_1.BaseException("Unknown builtin method: " + method);
      }
      return name;
    };
    _TsEmitterVisitor.prototype._visitParams = function(params, ctx) {
      var _this = this;
      this.visitAllObjects(function(param) {
        ctx.print(param.name);
        ctx.print(':');
        _this.visitType(param.type, ctx);
      }, params, ctx, ',');
    };
    _TsEmitterVisitor.prototype._visitIdentifier = function(value, typeParams, ctx) {
      var _this = this;
      if (lang_1.isBlank(value.name)) {
        throw new exceptions_1.BaseException("Internal error: unknown identifier " + value);
      }
      if (lang_1.isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
        var prefix = this.importsWithPrefixes.get(value.moduleUrl);
        if (lang_1.isBlank(prefix)) {
          prefix = "import" + this.importsWithPrefixes.size;
          this.importsWithPrefixes.set(value.moduleUrl, prefix);
        }
        ctx.print(prefix + ".");
      }
      ctx.print(value.name);
      if (lang_1.isPresent(typeParams) && typeParams.length > 0) {
        ctx.print("<");
        this.visitAllObjects(function(type) {
          return type.visitType(_this, ctx);
        }, typeParams, ctx, ',');
        ctx.print(">");
      }
    };
    return _TsEmitterVisitor;
  }(abstract_emitter_1.AbstractEmitterVisitor));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/schema/dom_security_schema.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.SECURITY_SCHEMA = {};
  function registerContext(ctx, specs) {
    for (var _i = 0,
        specs_1 = specs; _i < specs_1.length; _i++) {
      var spec = specs_1[_i];
      exports.SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }
  }
  registerContext(core_1.SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
  registerContext(core_1.SecurityContext.STYLE, ['*|style']);
  registerContext(core_1.SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);
  registerContext(core_1.SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/schema/dom_element_schema_registry.js", ["@angular/core", "../facade/collection", "../facade/lang", "./dom_security_schema", "./element_schema_registry"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var dom_security_schema_1 = $__require('./dom_security_schema');
  var element_schema_registry_1 = $__require('./element_schema_registry');
  var EVENT = 'event';
  var BOOLEAN = 'boolean';
  var NUMBER = 'number';
  var STRING = 'string';
  var OBJECT = 'object';
  var SCHEMA = (['*|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop', '^*|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*autocomplete,*autocompleteerror,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,#volume', ':svg:^*|*abort,*autocomplete,*autocompleteerror,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerpolicy,rel,rev,search,shape,target,text,type,username', 'area|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerpolicy,search,shape,target,username', 'audio^media|', 'br|clear', 'base|href,target', 'body|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas|#height,#width', 'content|select', 'dl|!compact', 'datalist|', 'details|!open', 'dialog|!open,returnValue', 'dir|!compact', 'div|align', 'embed|align,height,name,src,type,width', 'fieldset|!disabled,name', 'font|color,face,size', 'form|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr|align,color,!noShade,size,width', 'head|', 'h1,h2,h3,h4,h5,h6|align', 'html|version', 'iframe|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerpolicy,%sandbox,scrolling,src,srcdoc,width', 'img|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerpolicy,sizes,src,srcset,useMap,#vspace,#width', 'input|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'keygen|!autofocus,challenge,!disabled,keytype,name', 'li|type,#value', 'label|htmlFor', 'legend|align', 'link|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type', 'map|name', 'marquee|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu|!compact', 'meta|content,httpEquiv,name,scheme', 'meter|#high,#low,#max,#min,#optimum,#value', 'ins,del|cite,dateTime', 'ol|!compact,!reversed,#start,type', 'object|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup|!disabled,label', 'option|!defaultSelected,!disabled,label,!selected,text,value', 'output|defaultValue,%htmlFor,name,value', 'p|align', 'param|name,type,value,valueType', 'picture|', 'pre|#width', 'progress|#max,#value', 'q,blockquote,cite|', 'script|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow|', 'source|media,sizes,src,srcset,type', 'span|', 'style|!disabled,media,type', 'caption|align', 'th,td|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup|align,ch,chOff,#span,vAlign,width', 'table|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody|align,ch,chOff,vAlign', 'template|', 'textarea|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title|text', 'track|!default,kind,label,src,srclang', 'ul|!compact,type', 'unknown|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:cursor^:svg:|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan']);
  var attrToPropMap = {
    'class': 'className',
    'formaction': 'formAction',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
  };
  var DomElementSchemaRegistry = (function(_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
      var _this = this;
      _super.call(this);
      this.schema = {};
      SCHEMA.forEach(function(encodedType) {
        var parts = encodedType.split('|');
        var properties = parts[1].split(',');
        var typeParts = (parts[0] + '^').split('^');
        var typeName = typeParts[0];
        var type = {};
        typeName.split(',').forEach(function(tag) {
          return _this.schema[tag] = type;
        });
        var superType = _this.schema[typeParts[1]];
        if (lang_1.isPresent(superType)) {
          collection_1.StringMapWrapper.forEach(superType, function(v, k) {
            return type[k] = v;
          });
        }
        properties.forEach(function(property) {
          if (property == '') {} else if (property.startsWith('*')) {} else if (property.startsWith('!')) {
            type[property.substring(1)] = BOOLEAN;
          } else if (property.startsWith('#')) {
            type[property.substring(1)] = NUMBER;
          } else if (property.startsWith('%')) {
            type[property.substring(1)] = OBJECT;
          } else {
            type[property] = STRING;
          }
        });
      });
    }
    DomElementSchemaRegistry.prototype.hasProperty = function(tagName, propName, schemaMetas) {
      if (tagName.indexOf('-') !== -1) {
        if (tagName === 'ng-container' || tagName === 'ng-content') {
          return false;
        }
        if (schemaMetas.some(function(schema) {
          return schema.name === core_1.CUSTOM_ELEMENTS_SCHEMA.name;
        })) {
          return true;
        }
      }
      var elementProperties = this.schema[tagName.toLowerCase()];
      if (!lang_1.isPresent(elementProperties)) {
        elementProperties = this.schema['unknown'];
      }
      return lang_1.isPresent(elementProperties[propName]);
    };
    DomElementSchemaRegistry.prototype.securityContext = function(tagName, propName) {
      tagName = tagName.toLowerCase();
      propName = propName.toLowerCase();
      var ctx = dom_security_schema_1.SECURITY_SCHEMA[tagName + '|' + propName];
      if (ctx !== undefined)
        return ctx;
      ctx = dom_security_schema_1.SECURITY_SCHEMA['*|' + propName];
      return ctx !== undefined ? ctx : core_1.SecurityContext.NONE;
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function(propName) {
      var mappedPropName = collection_1.StringMapWrapper.get(attrToPropMap, propName);
      return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;
    };
    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function() {
      return 'ng-component';
    };
    DomElementSchemaRegistry.decorators = [{type: core_1.Injectable}];
    DomElementSchemaRegistry.ctorParameters = [];
    return DomElementSchemaRegistry;
  }(element_schema_registry_1.ElementSchemaRegistry));
  exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/shadow_css.js", ["./facade/collection", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('./facade/collection');
  var lang_1 = $__require('./facade/lang');
  var ShadowCss = (function() {
    function ShadowCss() {
      this.strictStyling = true;
    }
    ShadowCss.prototype.shimCssText = function(cssText, selector, hostSelector) {
      if (hostSelector === void 0) {
        hostSelector = '';
      }
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);
      return this._scopeCssText(cssText, selector, hostSelector);
    };
    ShadowCss.prototype._insertDirectives = function(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    };
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function(cssText) {
      return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function(m) {
        return m[1] + '{';
      });
    };
    ShadowCss.prototype._insertPolyfillRulesInCssText = function(cssText) {
      return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function(m) {
        var rule = m[0];
        rule = lang_1.StringWrapper.replace(rule, m[1], '');
        rule = lang_1.StringWrapper.replace(rule, m[2], '');
        return m[3] + rule;
      });
    };
    ShadowCss.prototype._scopeCssText = function(cssText, scopeSelector, hostSelector) {
      var unscoped = this._extractUnscopedRulesFromCssText(cssText);
      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);
      if (lang_1.isPresent(scopeSelector)) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }
      cssText = cssText + '\n' + unscoped;
      return cssText.trim();
    };
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function(cssText) {
      var r = '',
          m;
      _cssContentUnscopedRuleRe.lastIndex = 0;
      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
        var rule = m[0];
        rule = lang_1.StringWrapper.replace(rule, m[2], '');
        rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);
        r += rule + '\n\n';
      }
      return r;
    };
    ShadowCss.prototype._convertColonHost = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    ShadowCss.prototype._convertColonHostContext = function(cssText) {
      return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    ShadowCss.prototype._convertColonRule = function(cssText, regExp, partReplacer) {
      return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function(m) {
        if (lang_1.isPresent(m[2])) {
          var parts = m[2].split(','),
              r = [];
          for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            if (lang_1.isBlank(p))
              break;
            p = p.trim();
            r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
          }
          return r.join(',');
        } else {
          return _polyfillHostNoCombinator + m[3];
        }
      });
    };
    ShadowCss.prototype._colonHostContextPartReplacer = function(host, part, suffix) {
      if (lang_1.StringWrapper.contains(part, _polyfillHost)) {
        return this._colonHostPartReplacer(host, part, suffix);
      } else {
        return host + part + suffix + ', ' + part + ' ' + host + suffix;
      }
    };
    ShadowCss.prototype._colonHostPartReplacer = function(host, part, suffix) {
      return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;
    };
    ShadowCss.prototype._convertShadowDOMSelectors = function(cssText) {
      for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
        cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
      }
      return cssText;
    };
    ShadowCss.prototype._scopeSelectors = function(cssText, scopeSelector, hostSelector) {
      var _this = this;
      return processRules(cssText, function(rule) {
        var selector = rule.selector;
        var content = rule.content;
        if (rule.selector[0] != '@' || rule.selector.startsWith('@page')) {
          selector = _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
        } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports')) {
          content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
        }
        return new CssRule(selector, content);
      });
    };
    ShadowCss.prototype._scopeSelector = function(selector, scopeSelector, hostSelector, strict) {
      var r = [],
          parts = selector.split(',');
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i].trim();
        var deepParts = lang_1.StringWrapper.split(p, _shadowDeepSelectors);
        var shallowPart = deepParts[0];
        if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
          deepParts[0] = strict && !lang_1.StringWrapper.contains(shallowPart, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(shallowPart, scopeSelector) : this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
        }
        r.push(deepParts.join(' '));
      }
      return r.join(', ');
    };
    ShadowCss.prototype._selectorNeedsScoping = function(selector, scopeSelector) {
      var re = this._makeScopeMatcher(scopeSelector);
      return !re.test(selector);
    };
    ShadowCss.prototype._makeScopeMatcher = function(scopeSelector) {
      var lre = /\[/g;
      var rre = /\]/g;
      scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\[');
      scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\]');
      return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    ShadowCss.prototype._applySelectorScope = function(selector, scopeSelector, hostSelector) {
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    ShadowCss.prototype._applySimpleSelectorScope = function(selector, scopeSelector, hostSelector) {
      if (_polyfillHostRe.test(selector)) {
        var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
        selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
        return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
      } else {
        return scopeSelector + ' ' + selector;
      }
    };
    ShadowCss.prototype._applyStrictSelectorScope = function(selector, scopeSelector) {
      var isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function(m) {
        return m[1];
      });
      var splits = [' ', '>', '+', '~'],
          scoped = selector,
          attrName = '[' + scopeSelector + ']';
      for (var i = 0; i < splits.length; i++) {
        var sep = splits[i];
        var parts = scoped.split(sep);
        scoped = parts.map(function(p) {
          var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
          if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) && !lang_1.StringWrapper.contains(t, attrName)) {
            var m = t.match(/([^:]*)(:*)(.*)/);
            if (m !== null) {
              p = m[1] + attrName + m[2] + m[3];
            }
          }
          return p;
        }).join(sep);
      }
      return scoped;
    };
    ShadowCss.prototype._insertPolyfillHostInCssText = function(selector) {
      selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
      selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
      return selector;
    };
    return ShadowCss;
  }());
  exports.ShadowCss = ShadowCss;
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
  var _polyfillHost = '-shadowcsshost';
  var _polyfillHostContext = '-shadowcsscontext';
  var _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\/shadow-deep\//g, /\/shadow\//g];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  var _polyfillHostRe = new RegExp(_polyfillHost, 'im');
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*[\s\S]*?\*\//g;
  function stripComments(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, _commentRe, function(_) {
      return '';
    });
  }
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _curlyRe = /([{}])/g;
  var OPEN_CURLY = '{';
  var CLOSE_CURLY = '}';
  var BLOCK_PLACEHOLDER = '%BLOCK%';
  var CssRule = (function() {
    function CssRule(selector, content) {
      this.selector = selector;
      this.content = content;
    }
    return CssRule;
  }());
  exports.CssRule = CssRule;
  function processRules(input, ruleCallback) {
    var inputWithEscapedBlocks = escapeBlocks(input);
    var nextBlockIndex = 0;
    return lang_1.StringWrapper.replaceAllMapped(inputWithEscapedBlocks.escapedString, _ruleRe, function(m) {
      var selector = m[2];
      var content = '';
      var suffix = m[4];
      var contentPrefix = '';
      if (lang_1.isPresent(m[4]) && m[4].startsWith('{' + BLOCK_PLACEHOLDER)) {
        content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
        suffix = m[4].substring(BLOCK_PLACEHOLDER.length + 1);
        contentPrefix = '{';
      }
      var rule = ruleCallback(new CssRule(selector, content));
      return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
    });
  }
  exports.processRules = processRules;
  var StringWithEscapedBlocks = (function() {
    function StringWithEscapedBlocks(escapedString, blocks) {
      this.escapedString = escapedString;
      this.blocks = blocks;
    }
    return StringWithEscapedBlocks;
  }());
  function escapeBlocks(input) {
    var inputParts = lang_1.StringWrapper.split(input, _curlyRe);
    var resultParts = [];
    var escapedBlocks = [];
    var bracketCount = 0;
    var currentBlockParts = [];
    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
      var part = inputParts[partIndex];
      if (part == CLOSE_CURLY) {
        bracketCount--;
      }
      if (bracketCount > 0) {
        currentBlockParts.push(part);
      } else {
        if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
          currentBlockParts = [];
        }
        resultParts.push(part);
      }
      if (part == OPEN_CURLY) {
        bracketCount++;
      }
    }
    if (currentBlockParts.length > 0) {
      escapedBlocks.push(currentBlockParts.join(''));
      resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/style_compiler.js", ["@angular/core", "./compile_metadata", "./output/output_ast", "./shadow_css", "./url_resolver"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var compile_metadata_1 = $__require('./compile_metadata');
  var o = $__require('./output/output_ast');
  var shadow_css_1 = $__require('./shadow_css');
  var url_resolver_1 = $__require('./url_resolver');
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  var StylesCompileDependency = (function() {
    function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
      this.moduleUrl = moduleUrl;
      this.isShimmed = isShimmed;
      this.valuePlaceholder = valuePlaceholder;
    }
    return StylesCompileDependency;
  }());
  exports.StylesCompileDependency = StylesCompileDependency;
  var StylesCompileResult = (function() {
    function StylesCompileResult(componentStylesheet, externalStylesheets) {
      this.componentStylesheet = componentStylesheet;
      this.externalStylesheets = externalStylesheets;
    }
    return StylesCompileResult;
  }());
  exports.StylesCompileResult = StylesCompileResult;
  var CompiledStylesheet = (function() {
    function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
      this.statements = statements;
      this.stylesVar = stylesVar;
      this.dependencies = dependencies;
      this.isShimmed = isShimmed;
      this.meta = meta;
    }
    return CompiledStylesheet;
  }());
  exports.CompiledStylesheet = CompiledStylesheet;
  var StyleCompiler = (function() {
    function StyleCompiler(_urlResolver) {
      this._urlResolver = _urlResolver;
      this._shadowCss = new shadow_css_1.ShadowCss();
    }
    StyleCompiler.prototype.compileComponent = function(comp) {
      var _this = this;
      var externalStylesheets = [];
      var componentStylesheet = this._compileStyles(comp, new compile_metadata_1.CompileStylesheetMetadata({
        styles: comp.template.styles,
        styleUrls: comp.template.styleUrls,
        moduleUrl: comp.type.moduleUrl
      }), true);
      comp.template.externalStylesheets.forEach(function(stylesheetMeta) {
        var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
        externalStylesheets.push(compiledStylesheet);
      });
      return new StylesCompileResult(componentStylesheet, externalStylesheets);
    };
    StyleCompiler.prototype._compileStyles = function(comp, stylesheet, isComponentStylesheet) {
      var _this = this;
      var shim = comp.template.encapsulation === core_1.ViewEncapsulation.Emulated;
      var styleExpressions = stylesheet.styles.map(function(plainStyle) {
        return o.literal(_this._shimIfNeeded(plainStyle, shim));
      });
      var dependencies = [];
      for (var i = 0; i < stylesheet.styleUrls.length; i++) {
        var identifier = new compile_metadata_1.CompileIdentifierMetadata({name: getStylesVarName(null)});
        dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));
        styleExpressions.push(new o.ExternalExpr(identifier));
      }
      var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
      var stmt = o.variable(stylesVar).set(o.literalArr(styleExpressions, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const]))).toDeclStmt(null, [o.StmtModifier.Final]);
      return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
    };
    StyleCompiler.prototype._shimIfNeeded = function(style, shim) {
      return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
    };
    StyleCompiler.decorators = [{type: core_1.Injectable}];
    StyleCompiler.ctorParameters = [{type: url_resolver_1.UrlResolver}];
    return StyleCompiler;
  }());
  exports.StyleCompiler = StyleCompiler;
  function getStylesVarName(component) {
    var result = "styles";
    if (component) {
      result += "_" + component.type.name;
    }
    return result;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/expression_parser/lexer.js", ["@angular/core", "../chars", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var chars = $__require('../chars');
  var lang_1 = $__require('../facade/lang');
  (function(TokenType) {
    TokenType[TokenType["Character"] = 0] = "Character";
    TokenType[TokenType["Identifier"] = 1] = "Identifier";
    TokenType[TokenType["Keyword"] = 2] = "Keyword";
    TokenType[TokenType["String"] = 3] = "String";
    TokenType[TokenType["Operator"] = 4] = "Operator";
    TokenType[TokenType["Number"] = 5] = "Number";
    TokenType[TokenType["Error"] = 6] = "Error";
  })(exports.TokenType || (exports.TokenType = {}));
  var TokenType = exports.TokenType;
  var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
  var Lexer = (function() {
    function Lexer() {}
    Lexer.prototype.tokenize = function(text) {
      var scanner = new _Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();
      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    };
    Lexer.decorators = [{type: core_1.Injectable}];
    return Lexer;
  }());
  exports.Lexer = Lexer;
  var Token = (function() {
    function Token(index, type, numValue, strValue) {
      this.index = index;
      this.type = type;
      this.numValue = numValue;
      this.strValue = strValue;
    }
    Token.prototype.isCharacter = function(code) {
      return this.type == TokenType.Character && this.numValue == code;
    };
    Token.prototype.isNumber = function() {
      return this.type == TokenType.Number;
    };
    Token.prototype.isString = function() {
      return this.type == TokenType.String;
    };
    Token.prototype.isOperator = function(operater) {
      return this.type == TokenType.Operator && this.strValue == operater;
    };
    Token.prototype.isIdentifier = function() {
      return this.type == TokenType.Identifier;
    };
    Token.prototype.isKeyword = function() {
      return this.type == TokenType.Keyword;
    };
    Token.prototype.isKeywordDeprecatedVar = function() {
      return this.type == TokenType.Keyword && this.strValue == 'var';
    };
    Token.prototype.isKeywordLet = function() {
      return this.type == TokenType.Keyword && this.strValue == 'let';
    };
    Token.prototype.isKeywordNull = function() {
      return this.type == TokenType.Keyword && this.strValue == 'null';
    };
    Token.prototype.isKeywordUndefined = function() {
      return this.type == TokenType.Keyword && this.strValue == 'undefined';
    };
    Token.prototype.isKeywordTrue = function() {
      return this.type == TokenType.Keyword && this.strValue == 'true';
    };
    Token.prototype.isKeywordFalse = function() {
      return this.type == TokenType.Keyword && this.strValue == 'false';
    };
    Token.prototype.isKeywordThis = function() {
      return this.type == TokenType.Keyword && this.strValue == 'this';
    };
    Token.prototype.isError = function() {
      return this.type == TokenType.Error;
    };
    Token.prototype.toNumber = function() {
      return this.type == TokenType.Number ? this.numValue : -1;
    };
    Token.prototype.toString = function() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.String:
        case TokenType.Error:
          return this.strValue;
        case TokenType.Number:
          return this.numValue.toString();
        default:
          return null;
      }
    };
    return Token;
  }());
  exports.Token = Token;
  function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, '');
  }
  function newErrorToken(index, message) {
    return new Token(index, TokenType.Error, 0, message);
  }
  exports.EOF = new Token(-1, TokenType.Character, 0, '');
  var _Scanner = (function() {
    function _Scanner(input) {
      this.input = input;
      this.peek = 0;
      this.index = -1;
      this.length = input.length;
      this.advance();
    }
    _Scanner.prototype.advance = function() {
      this.peek = ++this.index >= this.length ? chars.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
    };
    _Scanner.prototype.scanToken = function() {
      var input = this.input,
          length = this.length,
          peek = this.peek,
          index = this.index;
      while (peek <= chars.$SPACE) {
        if (++index >= length) {
          peek = chars.$EOF;
          break;
        } else {
          peek = lang_1.StringWrapper.charCodeAt(input, index);
        }
      }
      this.peek = peek;
      this.index = index;
      if (index >= length) {
        return null;
      }
      if (isIdentifierStart(peek))
        return this.scanIdentifier();
      if (chars.isDigit(peek))
        return this.scanNumber(index);
      var start = index;
      switch (peek) {
        case chars.$PERIOD:
          this.advance();
          return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, chars.$PERIOD);
        case chars.$LPAREN:
        case chars.$RPAREN:
        case chars.$LBRACE:
        case chars.$RBRACE:
        case chars.$LBRACKET:
        case chars.$RBRACKET:
        case chars.$COMMA:
        case chars.$COLON:
        case chars.$SEMICOLON:
          return this.scanCharacter(start, peek);
        case chars.$SQ:
        case chars.$DQ:
          return this.scanString();
        case chars.$HASH:
        case chars.$PLUS:
        case chars.$MINUS:
        case chars.$STAR:
        case chars.$SLASH:
        case chars.$PERCENT:
        case chars.$CARET:
          return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));
        case chars.$QUESTION:
          return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');
        case chars.$LT:
        case chars.$GT:
          return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), chars.$EQ, '=');
        case chars.$BANG:
        case chars.$EQ:
          return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');
        case chars.$AMPERSAND:
          return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');
        case chars.$BAR:
          return this.scanComplexOperator(start, '|', chars.$BAR, '|');
        case chars.$NBSP:
          while (chars.isWhitespace(this.peek))
            this.advance();
          return this.scanToken();
      }
      this.advance();
      return this.error("Unexpected character [" + lang_1.StringWrapper.fromCharCode(peek) + "]", 0);
    };
    _Scanner.prototype.scanCharacter = function(start, code) {
      this.advance();
      return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function(start, str) {
      this.advance();
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanComplexOperator = function(start, one, twoCode, two, threeCode, three) {
      this.advance();
      var str = one;
      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }
      if (lang_1.isPresent(threeCode) && this.peek == threeCode) {
        this.advance();
        str += three;
      }
      return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function() {
      var start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek))
        this.advance();
      var str = this.input.substring(start, this.index);
      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);
    };
    _Scanner.prototype.scanNumber = function(start) {
      var simple = (this.index === start);
      this.advance();
      while (true) {
        if (chars.isDigit(this.peek)) {} else if (this.peek == chars.$PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek))
            this.advance();
          if (!chars.isDigit(this.peek))
            return this.error('Invalid exponent', -1);
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      var str = this.input.substring(start, this.index);
      var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);
      return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function() {
      var start = this.index;
      var quote = this.peek;
      this.advance();
      var buffer;
      var marker = this.index;
      var input = this.input;
      while (this.peek != quote) {
        if (this.peek == chars.$BACKSLASH) {
          if (buffer == null)
            buffer = new lang_1.StringJoiner();
          buffer.add(input.substring(marker, this.index));
          this.advance();
          var unescapedCode;
          if (this.peek == chars.$u) {
            var hex = input.substring(this.index + 1, this.index + 5);
            try {
              unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);
            } catch (e) {
              return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
            }
            for (var i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }
          buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));
          marker = this.index;
        } else if (this.peek == chars.$EOF) {
          return this.error('Unterminated quote', 0);
        } else {
          this.advance();
        }
      }
      var last = input.substring(marker, this.index);
      this.advance();
      var unescaped = last;
      if (buffer != null) {
        buffer.add(last);
        unescaped = buffer.toString();
      }
      return newStringToken(start, unescaped);
    };
    _Scanner.prototype.error = function(message, offset) {
      var position = this.index + offset;
      return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
  }());
  function isIdentifierStart(code) {
    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) || (code == chars.$_) || (code == chars.$$);
  }
  function isIdentifier(input) {
    if (input.length == 0)
      return false;
    var scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
      return false;
    scanner.advance();
    while (scanner.peek !== chars.$EOF) {
      if (!isIdentifierPart(scanner.peek))
        return false;
      scanner.advance();
    }
    return true;
  }
  exports.isIdentifier = isIdentifier;
  function isIdentifierPart(code) {
    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) || (code == chars.$$);
  }
  function isExponentStart(code) {
    return code == chars.$e || code == chars.$E;
  }
  function isExponentSign(code) {
    return code == chars.$MINUS || code == chars.$PLUS;
  }
  function isQuote(code) {
    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;
  }
  exports.isQuote = isQuote;
  function unescape(code) {
    switch (code) {
      case chars.$n:
        return chars.$LF;
      case chars.$f:
        return chars.$FF;
      case chars.$r:
        return chars.$CR;
      case chars.$t:
        return chars.$TAB;
      case chars.$v:
        return chars.$VTAB;
      default:
        return code;
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/expression_parser/parser.js", ["@angular/core", "../chars", "../facade/lang", "../ml_parser/interpolation_config", "./ast", "./lexer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var chars = $__require('../chars');
  var lang_1 = $__require('../facade/lang');
  var interpolation_config_1 = $__require('../ml_parser/interpolation_config');
  var ast_1 = $__require('./ast');
  var lexer_1 = $__require('./lexer');
  var SplitInterpolation = (function() {
    function SplitInterpolation(strings, expressions) {
      this.strings = strings;
      this.expressions = expressions;
    }
    return SplitInterpolation;
  }());
  exports.SplitInterpolation = SplitInterpolation;
  var TemplateBindingParseResult = (function() {
    function TemplateBindingParseResult(templateBindings, warnings, errors) {
      this.templateBindings = templateBindings;
      this.warnings = warnings;
      this.errors = errors;
    }
    return TemplateBindingParseResult;
  }());
  exports.TemplateBindingParseResult = TemplateBindingParseResult;
  function _createInterpolateRegExp(config) {
    var pattern = lang_1.escapeRegExp(config.start) + '([\\s\\S]*?)' + lang_1.escapeRegExp(config.end);
    return new RegExp(pattern, 'g');
  }
  var Parser = (function() {
    function Parser(_lexer) {
      this._lexer = _lexer;
      this.errors = [];
    }
    Parser.prototype.parseAction = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      this._checkNoInterpolation(input, location, interpolationConfig);
      var tokens = this._lexer.tokenize(this._stripComments(input));
      var ast = new _ParseAST(input, location, tokens, true, this.errors).parseChain();
      return new ast_1.ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype.parseBinding = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      var ast = this._parseBindingAst(input, location, interpolationConfig);
      return new ast_1.ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype.parseSimpleBinding = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      var ast = this._parseBindingAst(input, location, interpolationConfig);
      if (!SimpleExpressionChecker.check(ast)) {
        this._reportError('Host binding expression can only contain field access and constants', input, location);
      }
      return new ast_1.ASTWithSource(ast, input, location, this.errors);
    };
    Parser.prototype._reportError = function(message, input, errLocation, ctxLocation) {
      this.errors.push(new ast_1.ParserError(message, input, errLocation, ctxLocation));
    };
    Parser.prototype._parseBindingAst = function(input, location, interpolationConfig) {
      var quote = this._parseQuote(input, location);
      if (lang_1.isPresent(quote)) {
        return quote;
      }
      this._checkNoInterpolation(input, location, interpolationConfig);
      var tokens = this._lexer.tokenize(this._stripComments(input));
      return new _ParseAST(input, location, tokens, false, this.errors).parseChain();
    };
    Parser.prototype._parseQuote = function(input, location) {
      if (lang_1.isBlank(input))
        return null;
      var prefixSeparatorIndex = input.indexOf(':');
      if (prefixSeparatorIndex == -1)
        return null;
      var prefix = input.substring(0, prefixSeparatorIndex).trim();
      if (!lexer_1.isIdentifier(prefix))
        return null;
      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
      return new ast_1.Quote(new ast_1.ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
    };
    Parser.prototype.parseTemplateBindings = function(input, location) {
      var tokens = this._lexer.tokenize(input);
      return new _ParseAST(input, location, tokens, false, this.errors).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      var split = this.splitInterpolation(input, location, interpolationConfig);
      if (split == null)
        return null;
      var expressions = [];
      for (var i = 0; i < split.expressions.length; ++i) {
        var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
        var ast = new _ParseAST(input, location, tokens, false, this.errors).parseChain();
        expressions.push(ast);
      }
      return new ast_1.ASTWithSource(new ast_1.Interpolation(new ast_1.ParseSpan(0, lang_1.isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);
    };
    Parser.prototype.splitInterpolation = function(input, location, interpolationConfig) {
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      var regexp = _createInterpolateRegExp(interpolationConfig);
      var parts = lang_1.StringWrapper.split(input, regexp);
      if (parts.length <= 1) {
        return null;
      }
      var strings = [];
      var expressions = [];
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (i % 2 === 0) {
          strings.push(part);
        } else if (part.trim().length > 0) {
          expressions.push(part);
        } else {
          this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
        }
      }
      return new SplitInterpolation(strings, expressions);
    };
    Parser.prototype.wrapLiteralPrimitive = function(input, location) {
      return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(new ast_1.ParseSpan(0, lang_1.isBlank(input) ? 0 : input.length), input), input, location, this.errors);
    };
    Parser.prototype._stripComments = function(input) {
      var i = this._commentStart(input);
      return lang_1.isPresent(i) ? input.substring(0, i).trim() : input;
    };
    Parser.prototype._commentStart = function(input) {
      var outerQuote = null;
      for (var i = 0; i < input.length - 1; i++) {
        var char = lang_1.StringWrapper.charCodeAt(input, i);
        var nextChar = lang_1.StringWrapper.charCodeAt(input, i + 1);
        if (char === chars.$SLASH && nextChar == chars.$SLASH && lang_1.isBlank(outerQuote))
          return i;
        if (outerQuote === char) {
          outerQuote = null;
        } else if (lang_1.isBlank(outerQuote) && lexer_1.isQuote(char)) {
          outerQuote = char;
        }
      }
      return null;
    };
    Parser.prototype._checkNoInterpolation = function(input, location, interpolationConfig) {
      var regexp = _createInterpolateRegExp(interpolationConfig);
      var parts = lang_1.StringWrapper.split(input, regexp);
      if (parts.length > 1) {
        this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
      }
    };
    Parser.prototype._findInterpolationErrorColumn = function(parts, partInErrIdx, interpolationConfig) {
      var errLocation = '';
      for (var j = 0; j < partInErrIdx; j++) {
        errLocation += j % 2 === 0 ? parts[j] : "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
      }
      return errLocation.length;
    };
    Parser.decorators = [{type: core_1.Injectable}];
    Parser.ctorParameters = [{type: lexer_1.Lexer}];
    return Parser;
  }());
  exports.Parser = Parser;
  var _ParseAST = (function() {
    function _ParseAST(input, location, tokens, parseAction, errors) {
      this.input = input;
      this.location = location;
      this.tokens = tokens;
      this.parseAction = parseAction;
      this.errors = errors;
      this.rparensExpected = 0;
      this.rbracketsExpected = 0;
      this.rbracesExpected = 0;
      this.index = 0;
    }
    _ParseAST.prototype.peek = function(offset) {
      var i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
      get: function() {
        return this.peek(0);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
      get: function() {
        return (this.index < this.tokens.length) ? this.next.index : this.input.length;
      },
      enumerable: true,
      configurable: true
    });
    _ParseAST.prototype.span = function(start) {
      return new ast_1.ParseSpan(start, this.inputIndex);
    };
    _ParseAST.prototype.advance = function() {
      this.index++;
    };
    _ParseAST.prototype.optionalCharacter = function(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.peekKeywordLet = function() {
      return this.next.isKeywordLet();
    };
    _ParseAST.prototype.peekDeprecatedKeywordVar = function() {
      return this.next.isKeywordDeprecatedVar();
    };
    _ParseAST.prototype.peekDeprecatedOperatorHash = function() {
      return this.next.isOperator('#');
    };
    _ParseAST.prototype.expectCharacter = function(code) {
      if (this.optionalCharacter(code))
        return;
      this.error("Missing expected " + lang_1.StringWrapper.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    };
    _ParseAST.prototype.expectOperator = function(operator) {
      if (this.optionalOperator(operator))
        return;
      this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword()) {
        this.error("Unexpected token " + n + ", expected identifier or keyword");
        return '';
      }
      this.advance();
      return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function() {
      var n = this.next;
      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
        return '';
      }
      this.advance();
      return n.toString();
    };
    _ParseAST.prototype.parseChain = function() {
      var exprs = [];
      var start = this.inputIndex;
      while (this.index < this.tokens.length) {
        var expr = this.parsePipe();
        exprs.push(expr);
        if (this.optionalCharacter(chars.$SEMICOLON)) {
          if (!this.parseAction) {
            this.error('Binding expression cannot contain chained expression');
          }
          while (this.optionalCharacter(chars.$SEMICOLON)) {}
        } else if (this.index < this.tokens.length) {
          this.error("Unexpected token '" + this.next + "'");
        }
      }
      if (exprs.length == 0)
        return new ast_1.EmptyExpr(this.span(start));
      if (exprs.length == 1)
        return exprs[0];
      return new ast_1.Chain(this.span(start), exprs);
    };
    _ParseAST.prototype.parsePipe = function() {
      var result = this.parseExpression();
      if (this.optionalOperator('|')) {
        if (this.parseAction) {
          this.error('Cannot have a pipe in an action expression');
        }
        do {
          var name = this.expectIdentifierOrKeyword();
          var args = [];
          while (this.optionalCharacter(chars.$COLON)) {
            args.push(this.parseExpression());
          }
          result = new ast_1.BindingPipe(this.span(result.span.start), result, name, args);
        } while (this.optionalOperator('|'));
      }
      return result;
    };
    _ParseAST.prototype.parseExpression = function() {
      return this.parseConditional();
    };
    _ParseAST.prototype.parseConditional = function() {
      var start = this.inputIndex;
      var result = this.parseLogicalOr();
      if (this.optionalOperator('?')) {
        var yes = this.parsePipe();
        var no = void 0;
        if (!this.optionalCharacter(chars.$COLON)) {
          var end = this.inputIndex;
          var expression = this.input.substring(start, end);
          this.error("Conditional expression " + expression + " requires all 3 expressions");
          no = new ast_1.EmptyExpr(this.span(start));
        } else {
          no = this.parsePipe();
        }
        return new ast_1.Conditional(this.span(start), result, yes, no);
      } else {
        return result;
      }
    };
    _ParseAST.prototype.parseLogicalOr = function() {
      var result = this.parseLogicalAnd();
      while (this.optionalOperator('||')) {
        var right = this.parseLogicalAnd();
        result = new ast_1.Binary(this.span(result.span.start), '||', result, right);
      }
      return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function() {
      var result = this.parseEquality();
      while (this.optionalOperator('&&')) {
        var right = this.parseEquality();
        result = new ast_1.Binary(this.span(result.span.start), '&&', result, right);
      }
      return result;
    };
    _ParseAST.prototype.parseEquality = function() {
      var result = this.parseRelational();
      while (this.next.type == lexer_1.TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '==':
          case '===':
          case '!=':
          case '!==':
            this.advance();
            var right = this.parseRelational();
            result = new ast_1.Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseRelational = function() {
      var result = this.parseAdditive();
      while (this.next.type == lexer_1.TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '<':
          case '>':
          case '<=':
          case '>=':
            this.advance();
            var right = this.parseAdditive();
            result = new ast_1.Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseAdditive = function() {
      var result = this.parseMultiplicative();
      while (this.next.type == lexer_1.TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '+':
          case '-':
            this.advance();
            var right = this.parseMultiplicative();
            result = new ast_1.Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parseMultiplicative = function() {
      var result = this.parsePrefix();
      while (this.next.type == lexer_1.TokenType.Operator) {
        var operator = this.next.strValue;
        switch (operator) {
          case '*':
          case '%':
          case '/':
            this.advance();
            var right = this.parsePrefix();
            result = new ast_1.Binary(this.span(result.span.start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    };
    _ParseAST.prototype.parsePrefix = function() {
      if (this.next.type == lexer_1.TokenType.Operator) {
        var start = this.inputIndex;
        var operator = this.next.strValue;
        var result = void 0;
        switch (operator) {
          case '+':
            this.advance();
            return this.parsePrefix();
          case '-':
            this.advance();
            result = this.parsePrefix();
            return new ast_1.Binary(this.span(start), operator, new ast_1.LiteralPrimitive(new ast_1.ParseSpan(start, start), 0), result);
          case '!':
            this.advance();
            result = this.parsePrefix();
            return new ast_1.PrefixNot(this.span(start), result);
        }
      }
      return this.parseCallChain();
    };
    _ParseAST.prototype.parseCallChain = function() {
      var result = this.parsePrimary();
      while (true) {
        if (this.optionalCharacter(chars.$PERIOD)) {
          result = this.parseAccessMemberOrMethodCall(result, false);
        } else if (this.optionalOperator('?.')) {
          result = this.parseAccessMemberOrMethodCall(result, true);
        } else if (this.optionalCharacter(chars.$LBRACKET)) {
          this.rbracketsExpected++;
          var key = this.parsePipe();
          this.rbracketsExpected--;
          this.expectCharacter(chars.$RBRACKET);
          if (this.optionalOperator('=')) {
            var value = this.parseConditional();
            result = new ast_1.KeyedWrite(this.span(result.span.start), result, key, value);
          } else {
            result = new ast_1.KeyedRead(this.span(result.span.start), result, key);
          }
        } else if (this.optionalCharacter(chars.$LPAREN)) {
          this.rparensExpected++;
          var args = this.parseCallArguments();
          this.rparensExpected--;
          this.expectCharacter(chars.$RPAREN);
          result = new ast_1.FunctionCall(this.span(result.span.start), result, args);
        } else {
          return result;
        }
      }
    };
    _ParseAST.prototype.parsePrimary = function() {
      var start = this.inputIndex;
      if (this.optionalCharacter(chars.$LPAREN)) {
        this.rparensExpected++;
        var result = this.parsePipe();
        this.rparensExpected--;
        this.expectCharacter(chars.$RPAREN);
        return result;
      } else if (this.next.isKeywordNull()) {
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), null);
      } else if (this.next.isKeywordUndefined()) {
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), void 0);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), false);
      } else if (this.next.isKeywordThis()) {
        this.advance();
        return new ast_1.ImplicitReceiver(this.span(start));
      } else if (this.optionalCharacter(chars.$LBRACKET)) {
        this.rbracketsExpected++;
        var elements = this.parseExpressionList(chars.$RBRACKET);
        this.rbracketsExpected--;
        this.expectCharacter(chars.$RBRACKET);
        return new ast_1.LiteralArray(this.span(start), elements);
      } else if (this.next.isCharacter(chars.$LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMemberOrMethodCall(new ast_1.ImplicitReceiver(this.span(start)), false);
      } else if (this.next.isNumber()) {
        var value = this.next.toNumber();
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), value);
      } else if (this.next.isString()) {
        var literalValue = this.next.toString();
        this.advance();
        return new ast_1.LiteralPrimitive(this.span(start), literalValue);
      } else if (this.index >= this.tokens.length) {
        this.error("Unexpected end of expression: " + this.input);
        return new ast_1.EmptyExpr(this.span(start));
      } else {
        this.error("Unexpected token " + this.next);
        return new ast_1.EmptyExpr(this.span(start));
      }
    };
    _ParseAST.prototype.parseExpressionList = function(terminator) {
      var result = [];
      if (!this.next.isCharacter(terminator)) {
        do {
          result.push(this.parsePipe());
        } while (this.optionalCharacter(chars.$COMMA));
      }
      return result;
    };
    _ParseAST.prototype.parseLiteralMap = function() {
      var keys = [];
      var values = [];
      var start = this.inputIndex;
      this.expectCharacter(chars.$LBRACE);
      if (!this.optionalCharacter(chars.$RBRACE)) {
        this.rbracesExpected++;
        do {
          var key = this.expectIdentifierOrKeywordOrString();
          keys.push(key);
          this.expectCharacter(chars.$COLON);
          values.push(this.parsePipe());
        } while (this.optionalCharacter(chars.$COMMA));
        this.rbracesExpected--;
        this.expectCharacter(chars.$RBRACE);
      }
      return new ast_1.LiteralMap(this.span(start), keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function(receiver, isSafe) {
      if (isSafe === void 0) {
        isSafe = false;
      }
      var start = receiver.span.start;
      var id = this.expectIdentifierOrKeyword();
      if (this.optionalCharacter(chars.$LPAREN)) {
        this.rparensExpected++;
        var args = this.parseCallArguments();
        this.expectCharacter(chars.$RPAREN);
        this.rparensExpected--;
        var span = this.span(start);
        return isSafe ? new ast_1.SafeMethodCall(span, receiver, id, args) : new ast_1.MethodCall(span, receiver, id, args);
      } else {
        if (isSafe) {
          if (this.optionalOperator('=')) {
            this.error('The \'?.\' operator cannot be used in the assignment');
            return new ast_1.EmptyExpr(this.span(start));
          } else {
            return new ast_1.SafePropertyRead(this.span(start), receiver, id);
          }
        } else {
          if (this.optionalOperator('=')) {
            if (!this.parseAction) {
              this.error('Bindings cannot contain assignments');
              return new ast_1.EmptyExpr(this.span(start));
            }
            var value = this.parseConditional();
            return new ast_1.PropertyWrite(this.span(start), receiver, id, value);
          } else {
            return new ast_1.PropertyRead(this.span(start), receiver, id);
          }
        }
      }
    };
    _ParseAST.prototype.parseCallArguments = function() {
      if (this.next.isCharacter(chars.$RPAREN))
        return [];
      var positionals = [];
      do {
        positionals.push(this.parsePipe());
      } while (this.optionalCharacter(chars.$COMMA));
      return positionals;
    };
    _ParseAST.prototype.expectTemplateBindingKey = function() {
      var result = '';
      var operatorFound = false;
      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.optionalOperator('-');
        if (operatorFound) {
          result += '-';
        }
      } while (operatorFound);
      return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function() {
      var bindings = [];
      var prefix = null;
      var warnings = [];
      while (this.index < this.tokens.length) {
        var keyIsVar = this.peekKeywordLet();
        if (!keyIsVar && this.peekDeprecatedKeywordVar()) {
          keyIsVar = true;
          warnings.push("\"var\" inside of expressions is deprecated. Use \"let\" instead!");
        }
        if (!keyIsVar && this.peekDeprecatedOperatorHash()) {
          keyIsVar = true;
          warnings.push("\"#\" inside of expressions is deprecated. Use \"let\" instead!");
        }
        if (keyIsVar) {
          this.advance();
        }
        var key = this.expectTemplateBindingKey();
        if (!keyIsVar) {
          if (prefix == null) {
            prefix = key;
          } else {
            key = prefix + key[0].toUpperCase() + key.substring(1);
          }
        }
        this.optionalCharacter(chars.$COLON);
        var name = null;
        var expression = null;
        if (keyIsVar) {
          if (this.optionalOperator('=')) {
            name = this.expectTemplateBindingKey();
          } else {
            name = '\$implicit';
          }
        } else if (this.next !== lexer_1.EOF && !this.peekKeywordLet() && !this.peekDeprecatedKeywordVar() && !this.peekDeprecatedOperatorHash()) {
          var start = this.inputIndex;
          var ast = this.parsePipe();
          var source = this.input.substring(start, this.inputIndex);
          expression = new ast_1.ASTWithSource(ast, source, this.location, this.errors);
        }
        bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
        if (!this.optionalCharacter(chars.$SEMICOLON)) {
          this.optionalCharacter(chars.$COMMA);
        }
      }
      return new TemplateBindingParseResult(bindings, warnings, this.errors);
    };
    _ParseAST.prototype.error = function(message, index) {
      if (index === void 0) {
        index = null;
      }
      this.errors.push(new ast_1.ParserError(message, this.input, this.locationText(index), this.location));
      this.skip();
    };
    _ParseAST.prototype.locationText = function(index) {
      if (index === void 0) {
        index = null;
      }
      if (lang_1.isBlank(index))
        index = this.index;
      return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" : "at the end of the expression";
    };
    _ParseAST.prototype.skip = function() {
      var n = this.next;
      while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {
        if (this.next.isError()) {
          this.errors.push(new ast_1.ParserError(this.next.toString(), this.input, this.locationText(), this.location));
        }
        this.advance();
        n = this.next;
      }
    };
    return _ParseAST;
  }());
  exports._ParseAST = _ParseAST;
  var SimpleExpressionChecker = (function() {
    function SimpleExpressionChecker() {
      this.simple = true;
    }
    SimpleExpressionChecker.check = function(ast) {
      var s = new SimpleExpressionChecker();
      ast.visit(s);
      return s.simple;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitInterpolation = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyRead = function(ast, context) {};
    SimpleExpressionChecker.prototype.visitPropertyWrite = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitMethodCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitFunctionCall = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitLiteralArray = function(ast, context) {
      this.visitAll(ast.expressions);
    };
    SimpleExpressionChecker.prototype.visitLiteralMap = function(ast, context) {
      this.visitAll(ast.values);
    };
    SimpleExpressionChecker.prototype.visitBinary = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitPrefixNot = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitConditional = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitPipe = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitKeyedRead = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitKeyedWrite = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitAll = function(asts) {
      var _this = this;
      return asts.map(function(node) {
        return node.visit(_this);
      });
    };
    SimpleExpressionChecker.prototype.visitChain = function(ast, context) {
      this.simple = false;
    };
    SimpleExpressionChecker.prototype.visitQuote = function(ast, context) {
      this.simple = false;
    };
    return SimpleExpressionChecker;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/html_tags.js", ["./tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var tags_1 = $__require('./tags');
  var HtmlTagDefinition = (function() {
    function HtmlTagDefinition(_a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a,
          closedByChildren = _b.closedByChildren,
          requiredParents = _b.requiredParents,
          implicitNamespacePrefix = _b.implicitNamespacePrefix,
          _c = _b.contentType,
          contentType = _c === void 0 ? tags_1.TagContentType.PARSABLE_DATA : _c,
          _d = _b.closedByParent,
          closedByParent = _d === void 0 ? false : _d,
          _e = _b.isVoid,
          isVoid = _e === void 0 ? false : _e,
          _f = _b.ignoreFirstLf,
          ignoreFirstLf = _f === void 0 ? false : _f;
      this.closedByChildren = {};
      this.closedByParent = false;
      this.canSelfClose = false;
      if (closedByChildren && closedByChildren.length > 0) {
        closedByChildren.forEach(function(tagName) {
          return _this.closedByChildren[tagName] = true;
        });
      }
      this.isVoid = isVoid;
      this.closedByParent = closedByParent || isVoid;
      if (requiredParents && requiredParents.length > 0) {
        this.requiredParents = {};
        this.parentToAdd = requiredParents[0];
        requiredParents.forEach(function(tagName) {
          return _this.requiredParents[tagName] = true;
        });
      }
      this.implicitNamespacePrefix = implicitNamespacePrefix;
      this.contentType = contentType;
      this.ignoreFirstLf = ignoreFirstLf;
    }
    HtmlTagDefinition.prototype.requireExtraParent = function(currentParent) {
      if (!this.requiredParents) {
        return false;
      }
      if (!currentParent) {
        return true;
      }
      var lcParent = currentParent.toLowerCase();
      return this.requiredParents[lcParent] != true && lcParent != 'template';
    };
    HtmlTagDefinition.prototype.isClosedByChild = function(name) {
      return this.isVoid || name.toLowerCase() in this.closedByChildren;
    };
    return HtmlTagDefinition;
  }());
  exports.HtmlTagDefinition = HtmlTagDefinition;
  var TAG_DEFINITIONS = {
    'base': new HtmlTagDefinition({isVoid: true}),
    'meta': new HtmlTagDefinition({isVoid: true}),
    'area': new HtmlTagDefinition({isVoid: true}),
    'embed': new HtmlTagDefinition({isVoid: true}),
    'link': new HtmlTagDefinition({isVoid: true}),
    'img': new HtmlTagDefinition({isVoid: true}),
    'input': new HtmlTagDefinition({isVoid: true}),
    'param': new HtmlTagDefinition({isVoid: true}),
    'hr': new HtmlTagDefinition({isVoid: true}),
    'br': new HtmlTagDefinition({isVoid: true}),
    'source': new HtmlTagDefinition({isVoid: true}),
    'track': new HtmlTagDefinition({isVoid: true}),
    'wbr': new HtmlTagDefinition({isVoid: true}),
    'p': new HtmlTagDefinition({
      closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
      closedByParent: true
    }),
    'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),
    'tbody': new HtmlTagDefinition({
      closedByChildren: ['tbody', 'tfoot'],
      closedByParent: true
    }),
    'tfoot': new HtmlTagDefinition({
      closedByChildren: ['tbody'],
      closedByParent: true
    }),
    'tr': new HtmlTagDefinition({
      closedByChildren: ['tr'],
      requiredParents: ['tbody', 'tfoot', 'thead'],
      closedByParent: true
    }),
    'td': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'th': new HtmlTagDefinition({
      closedByChildren: ['td', 'th'],
      closedByParent: true
    }),
    'col': new HtmlTagDefinition({
      requiredParents: ['colgroup'],
      isVoid: true
    }),
    'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),
    'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),
    'li': new HtmlTagDefinition({
      closedByChildren: ['li'],
      closedByParent: true
    }),
    'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),
    'dd': new HtmlTagDefinition({
      closedByChildren: ['dt', 'dd'],
      closedByParent: true
    }),
    'rb': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rt': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rtc': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rtc', 'rp'],
      closedByParent: true
    }),
    'rp': new HtmlTagDefinition({
      closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
      closedByParent: true
    }),
    'optgroup': new HtmlTagDefinition({
      closedByChildren: ['optgroup'],
      closedByParent: true
    }),
    'option': new HtmlTagDefinition({
      closedByChildren: ['option', 'optgroup'],
      closedByParent: true
    }),
    'pre': new HtmlTagDefinition({ignoreFirstLf: true}),
    'listing': new HtmlTagDefinition({ignoreFirstLf: true}),
    'style': new HtmlTagDefinition({contentType: tags_1.TagContentType.RAW_TEXT}),
    'script': new HtmlTagDefinition({contentType: tags_1.TagContentType.RAW_TEXT}),
    'title': new HtmlTagDefinition({contentType: tags_1.TagContentType.ESCAPABLE_RAW_TEXT}),
    'textarea': new HtmlTagDefinition({
      contentType: tags_1.TagContentType.ESCAPABLE_RAW_TEXT,
      ignoreFirstLf: true
    })
  };
  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
  function getHtmlTagDefinition(tagName) {
    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
  }
  exports.getHtmlTagDefinition = getHtmlTagDefinition;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/chars.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.$EOF = 0;
  exports.$TAB = 9;
  exports.$LF = 10;
  exports.$VTAB = 11;
  exports.$FF = 12;
  exports.$CR = 13;
  exports.$SPACE = 32;
  exports.$BANG = 33;
  exports.$DQ = 34;
  exports.$HASH = 35;
  exports.$$ = 36;
  exports.$PERCENT = 37;
  exports.$AMPERSAND = 38;
  exports.$SQ = 39;
  exports.$LPAREN = 40;
  exports.$RPAREN = 41;
  exports.$STAR = 42;
  exports.$PLUS = 43;
  exports.$COMMA = 44;
  exports.$MINUS = 45;
  exports.$PERIOD = 46;
  exports.$SLASH = 47;
  exports.$COLON = 58;
  exports.$SEMICOLON = 59;
  exports.$LT = 60;
  exports.$EQ = 61;
  exports.$GT = 62;
  exports.$QUESTION = 63;
  exports.$0 = 48;
  exports.$9 = 57;
  exports.$A = 65;
  exports.$E = 69;
  exports.$F = 70;
  exports.$X = 88;
  exports.$Z = 90;
  exports.$LBRACKET = 91;
  exports.$BACKSLASH = 92;
  exports.$RBRACKET = 93;
  exports.$CARET = 94;
  exports.$_ = 95;
  exports.$a = 97;
  exports.$e = 101;
  exports.$f = 102;
  exports.$n = 110;
  exports.$r = 114;
  exports.$t = 116;
  exports.$u = 117;
  exports.$v = 118;
  exports.$x = 120;
  exports.$z = 122;
  exports.$LBRACE = 123;
  exports.$BAR = 124;
  exports.$RBRACE = 125;
  exports.$NBSP = 160;
  exports.$PIPE = 124;
  exports.$TILDA = 126;
  exports.$AT = 64;
  exports.$BT = 96;
  function isWhitespace(code) {
    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == exports.$NBSP);
  }
  exports.isWhitespace = isWhitespace;
  function isDigit(code) {
    return exports.$0 <= code && code <= exports.$9;
  }
  exports.isDigit = isDigit;
  function isAsciiLetter(code) {
    return code >= exports.$a && code <= exports.$z || code >= exports.$A && code <= exports.$Z;
  }
  exports.isAsciiLetter = isAsciiLetter;
  function isAsciiHexDigit(code) {
    return code >= exports.$a && code <= exports.$f || code >= exports.$A && code <= exports.$F || isDigit(code);
  }
  exports.isAsciiHexDigit = isAsciiHexDigit;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/lexer.js", ["../chars", "../parse_util", "./interpolation_config", "./tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var chars = $__require('../chars');
  var parse_util_1 = $__require('../parse_util');
  var interpolation_config_1 = $__require('./interpolation_config');
  var tags_1 = $__require('./tags');
  (function(TokenType) {
    TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
    TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
    TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
    TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
    TokenType[TokenType["TEXT"] = 4] = "TEXT";
    TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
    TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
    TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
    TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
    TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
    TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
    TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
    TokenType[TokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
    TokenType[TokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
    TokenType[TokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
    TokenType[TokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
    TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
    TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
    TokenType[TokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
    TokenType[TokenType["EOF"] = 19] = "EOF";
  })(exports.TokenType || (exports.TokenType = {}));
  var TokenType = exports.TokenType;
  var Token = (function() {
    function Token(type, parts, sourceSpan) {
      this.type = type;
      this.parts = parts;
      this.sourceSpan = sourceSpan;
    }
    return Token;
  }());
  exports.Token = Token;
  var TokenError = (function(_super) {
    __extends(TokenError, _super);
    function TokenError(errorMsg, tokenType, span) {
      _super.call(this, span, errorMsg);
      this.tokenType = tokenType;
    }
    return TokenError;
  }(parse_util_1.ParseError));
  exports.TokenError = TokenError;
  var TokenizeResult = (function() {
    function TokenizeResult(tokens, errors) {
      this.tokens = tokens;
      this.errors = errors;
    }
    return TokenizeResult;
  }());
  exports.TokenizeResult = TokenizeResult;
  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
    if (tokenizeExpansionForms === void 0) {
      tokenizeExpansionForms = false;
    }
    if (interpolationConfig === void 0) {
      interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
    }
    return new _Tokenizer(new parse_util_1.ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig).tokenize();
  }
  exports.tokenize = tokenize;
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
    var char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);
    return "Unexpected character \"" + char + "\"";
  }
  function _unknownEntityErrorMsg(entitySrc) {
    return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
  }
  var _ControlFlowError = (function() {
    function _ControlFlowError(error) {
      this.error = error;
    }
    return _ControlFlowError;
  }());
  var _Tokenizer = (function() {
    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
      if (_interpolationConfig === void 0) {
        _interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      this._file = _file;
      this._getTagDefinition = _getTagDefinition;
      this._tokenizeIcu = _tokenizeIcu;
      this._interpolationConfig = _interpolationConfig;
      this._peek = -1;
      this._nextPeek = -1;
      this._index = -1;
      this._line = 0;
      this._column = -1;
      this._expansionCaseStack = [];
      this._inInterpolation = false;
      this.tokens = [];
      this.errors = [];
      this._input = _file.content;
      this._length = _file.content.length;
      this._advance();
    }
    _Tokenizer.prototype._processCarriageReturns = function(content) {
      return content.replace(_CR_OR_CRLF_REGEXP, '\n');
    };
    _Tokenizer.prototype.tokenize = function() {
      while (this._peek !== chars.$EOF) {
        var start = this._getLocation();
        try {
          if (this._attemptCharCode(chars.$LT)) {
            if (this._attemptCharCode(chars.$BANG)) {
              if (this._attemptCharCode(chars.$LBRACKET)) {
                this._consumeCdata(start);
              } else if (this._attemptCharCode(chars.$MINUS)) {
                this._consumeComment(start);
              } else {
                this._consumeDocType(start);
              }
            } else if (this._attemptCharCode(chars.$SLASH)) {
              this._consumeTagClose(start);
            } else {
              this._consumeTagOpen(start);
            }
          } else if (!this._tokenizeIcu || !this._tokenizeExpansionForm()) {
            this._consumeText();
          }
        } catch (e) {
          if (e instanceof _ControlFlowError) {
            this.errors.push(e.error);
          } else {
            throw e;
          }
        }
      }
      this._beginToken(TokenType.EOF);
      this._endToken([]);
      return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
    };
    _Tokenizer.prototype._tokenizeExpansionForm = function() {
      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
        this._consumeExpansionFormStart();
        return true;
      }
      if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
        this._consumeExpansionCaseStart();
        return true;
      }
      if (this._peek === chars.$RBRACE) {
        if (this._isInExpansionCase()) {
          this._consumeExpansionCaseEnd();
          return true;
        }
        if (this._isInExpansionForm()) {
          this._consumeExpansionFormEnd();
          return true;
        }
      }
      return false;
    };
    _Tokenizer.prototype._getLocation = function() {
      return new parse_util_1.ParseLocation(this._file, this._index, this._line, this._column);
    };
    _Tokenizer.prototype._getSpan = function(start, end) {
      if (start === void 0) {
        start = this._getLocation();
      }
      if (end === void 0) {
        end = this._getLocation();
      }
      return new parse_util_1.ParseSourceSpan(start, end);
    };
    _Tokenizer.prototype._beginToken = function(type, start) {
      if (start === void 0) {
        start = this._getLocation();
      }
      this._currentTokenStart = start;
      this._currentTokenType = type;
    };
    _Tokenizer.prototype._endToken = function(parts, end) {
      if (end === void 0) {
        end = this._getLocation();
      }
      var token = new Token(this._currentTokenType, parts, new parse_util_1.ParseSourceSpan(this._currentTokenStart, end));
      this.tokens.push(token);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return token;
    };
    _Tokenizer.prototype._createError = function(msg, span) {
      if (this._isInExpansionForm()) {
        msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
      }
      var error = new TokenError(msg, this._currentTokenType, span);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return new _ControlFlowError(error);
    };
    _Tokenizer.prototype._advance = function() {
      if (this._index >= this._length) {
        throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());
      }
      if (this._peek === chars.$LF) {
        this._line++;
        this._column = 0;
      } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {
        this._column++;
      }
      this._index++;
      this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);
      this._nextPeek = this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);
    };
    _Tokenizer.prototype._attemptCharCode = function(charCode) {
      if (this._peek === charCode) {
        this._advance();
        return true;
      }
      return false;
    };
    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function(charCode) {
      if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
        this._advance();
        return true;
      }
      return false;
    };
    _Tokenizer.prototype._requireCharCode = function(charCode) {
      var location = this._getLocation();
      if (!this._attemptCharCode(charCode)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
      }
    };
    _Tokenizer.prototype._attemptStr = function(chars) {
      var len = chars.length;
      if (this._index + len > this._length) {
        return false;
      }
      var initialPosition = this._savePosition();
      for (var i = 0; i < len; i++) {
        if (!this._attemptCharCode(chars.charCodeAt(i))) {
          this._restorePosition(initialPosition);
          return false;
        }
      }
      return true;
    };
    _Tokenizer.prototype._attemptStrCaseInsensitive = function(chars) {
      for (var i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    };
    _Tokenizer.prototype._requireStr = function(chars) {
      var location = this._getLocation();
      if (!this._attemptStr(chars)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
      }
    };
    _Tokenizer.prototype._attemptCharCodeUntilFn = function(predicate) {
      while (!predicate(this._peek)) {
        this._advance();
      }
    };
    _Tokenizer.prototype._requireCharCodeUntilFn = function(predicate, len) {
      var start = this._getLocation();
      this._attemptCharCodeUntilFn(predicate);
      if (this._index - start.offset < len) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
      }
    };
    _Tokenizer.prototype._attemptUntilChar = function(char) {
      while (this._peek !== char) {
        this._advance();
      }
    };
    _Tokenizer.prototype._readChar = function(decodeEntities) {
      if (decodeEntities && this._peek === chars.$AMPERSAND) {
        return this._decodeEntity();
      } else {
        var index = this._index;
        this._advance();
        return this._input[index];
      }
    };
    _Tokenizer.prototype._decodeEntity = function() {
      var start = this._getLocation();
      this._advance();
      if (this._attemptCharCode(chars.$HASH)) {
        var isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);
        var numberStart = this._getLocation().offset;
        this._attemptCharCodeUntilFn(isDigitEntityEnd);
        if (this._peek != chars.$SEMICOLON) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
        }
        this._advance();
        var strNum = this._input.substring(numberStart, this._index - 1);
        try {
          var charCode = parseInt(strNum, isHex ? 16 : 10);
          return String.fromCharCode(charCode);
        } catch (e) {
          var entity = this._input.substring(start.offset + 1, this._index - 1);
          throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
        }
      } else {
        var startPosition = this._savePosition();
        this._attemptCharCodeUntilFn(isNamedEntityEnd);
        if (this._peek != chars.$SEMICOLON) {
          this._restorePosition(startPosition);
          return '&';
        }
        this._advance();
        var name_1 = this._input.substring(start.offset + 1, this._index - 1);
        var char = tags_1.NAMED_ENTITIES[name_1];
        if (!char) {
          throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));
        }
        return char;
      }
    };
    _Tokenizer.prototype._consumeRawText = function(decodeEntities, firstCharOfEnd, attemptEndRest) {
      var tagCloseStart;
      var textStart = this._getLocation();
      this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);
      var parts = [];
      while (true) {
        tagCloseStart = this._getLocation();
        if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
          break;
        }
        if (this._index > tagCloseStart.offset) {
          parts.push(this._input.substring(tagCloseStart.offset, this._index));
        }
        while (this._peek !== firstCharOfEnd) {
          parts.push(this._readChar(decodeEntities));
        }
      }
      return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
    };
    _Tokenizer.prototype._consumeComment = function(start) {
      var _this = this;
      this._beginToken(TokenType.COMMENT_START, start);
      this._requireCharCode(chars.$MINUS);
      this._endToken([]);
      var textToken = this._consumeRawText(false, chars.$MINUS, function() {
        return _this._attemptStr('->');
      });
      this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeCdata = function(start) {
      var _this = this;
      this._beginToken(TokenType.CDATA_START, start);
      this._requireStr('CDATA[');
      this._endToken([]);
      var textToken = this._consumeRawText(false, chars.$RBRACKET, function() {
        return _this._attemptStr(']>');
      });
      this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeDocType = function(start) {
      this._beginToken(TokenType.DOC_TYPE, start);
      this._attemptUntilChar(chars.$GT);
      this._advance();
      this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
    };
    _Tokenizer.prototype._consumePrefixAndName = function() {
      var nameOrPrefixStart = this._index;
      var prefix = null;
      while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {
        this._advance();
      }
      var nameStart;
      if (this._peek === chars.$COLON) {
        this._advance();
        prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
        nameStart = this._index;
      } else {
        nameStart = nameOrPrefixStart;
      }
      this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
      var name = this._input.substring(nameStart, this._index);
      return [prefix, name];
    };
    _Tokenizer.prototype._consumeTagOpen = function(start) {
      var savedPos = this._savePosition();
      var tagName;
      var lowercaseTagName;
      try {
        if (!chars.isAsciiLetter(this._peek)) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
        }
        var nameStart = this._index;
        this._consumeTagOpenStart(start);
        tagName = this._input.substring(nameStart, this._index);
        lowercaseTagName = tagName.toLowerCase();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {
          this._consumeAttributeName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (this._attemptCharCode(chars.$EQ)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._consumeAttributeValue();
          }
          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof _ControlFlowError) {
          this._restorePosition(savedPos);
          this._beginToken(TokenType.TEXT, start);
          this._endToken(['<']);
          return;
        }
        throw e;
      }
      var contentTokenType = this._getTagDefinition(tagName).contentType;
      if (contentTokenType === tags_1.TagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, false);
      } else if (contentTokenType === tags_1.TagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(lowercaseTagName, true);
      }
    };
    _Tokenizer.prototype._consumeRawTextWithTagClose = function(lowercaseTagName, decodeEntities) {
      var _this = this;
      var textToken = this._consumeRawText(decodeEntities, chars.$LT, function() {
        if (!_this._attemptCharCode(chars.$SLASH))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
          return false;
        _this._attemptCharCodeUntilFn(isNotWhitespace);
        return _this._attemptCharCode(chars.$GT);
      });
      this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);
      this._endToken([null, lowercaseTagName]);
    };
    _Tokenizer.prototype._consumeTagOpenStart = function(start) {
      this._beginToken(TokenType.TAG_OPEN_START, start);
      var parts = this._consumePrefixAndName();
      this._endToken(parts);
    };
    _Tokenizer.prototype._consumeAttributeName = function() {
      this._beginToken(TokenType.ATTR_NAME);
      var prefixAndName = this._consumePrefixAndName();
      this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeAttributeValue = function() {
      this._beginToken(TokenType.ATTR_VALUE);
      var value;
      if (this._peek === chars.$SQ || this._peek === chars.$DQ) {
        var quoteChar = this._peek;
        this._advance();
        var parts = [];
        while (this._peek !== quoteChar) {
          parts.push(this._readChar(true));
        }
        value = parts.join('');
        this._advance();
      } else {
        var valueStart = this._index;
        this._requireCharCodeUntilFn(isNameEnd, 1);
        value = this._input.substring(valueStart, this._index);
      }
      this._endToken([this._processCarriageReturns(value)]);
    };
    _Tokenizer.prototype._consumeTagOpenEnd = function() {
      var tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;
      this._beginToken(tokenType);
      this._requireCharCode(chars.$GT);
      this._endToken([]);
    };
    _Tokenizer.prototype._consumeTagClose = function(start) {
      this._beginToken(TokenType.TAG_CLOSE, start);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      var prefixAndName = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._requireCharCode(chars.$GT);
      this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeExpansionFormStart = function() {
      this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());
      this._requireCharCode(chars.$LBRACE);
      this._endToken([]);
      this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);
      this._beginToken(TokenType.RAW_TEXT, this._getLocation());
      var condition = this._readUntil(chars.$COMMA);
      this._endToken([condition], this._getLocation());
      this._requireCharCode(chars.$COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(TokenType.RAW_TEXT, this._getLocation());
      var type = this._readUntil(chars.$COMMA);
      this._endToken([type], this._getLocation());
      this._requireCharCode(chars.$COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
    };
    _Tokenizer.prototype._consumeExpansionCaseStart = function() {
      this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());
      var value = this._readUntil(chars.$LBRACE).trim();
      this._endToken([value], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());
      this._requireCharCode(chars.$LBRACE);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);
    };
    _Tokenizer.prototype._consumeExpansionCaseEnd = function() {
      this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());
      this._requireCharCode(chars.$RBRACE);
      this._endToken([], this._getLocation());
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeExpansionFormEnd = function() {
      this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());
      this._requireCharCode(chars.$RBRACE);
      this._endToken([]);
      this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeText = function() {
      var start = this._getLocation();
      this._beginToken(TokenType.TEXT, start);
      var parts = [];
      do {
        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
          parts.push(this._interpolationConfig.start);
          this._inInterpolation = true;
        } else if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.end) && this._inInterpolation) {
          parts.push(this._interpolationConfig.end);
          this._inInterpolation = false;
        } else {
          parts.push(this._readChar(true));
        }
      } while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _Tokenizer.prototype._isTextEnd = function() {
      if (this._peek === chars.$LT || this._peek === chars.$EOF) {
        return true;
      }
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
          return true;
        }
        if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {
          return true;
        }
      }
      return false;
    };
    _Tokenizer.prototype._savePosition = function() {
      return [this._peek, this._index, this._column, this._line, this.tokens.length];
    };
    _Tokenizer.prototype._readUntil = function(char) {
      var start = this._index;
      this._attemptUntilChar(char);
      return this._input.substring(start, this._index);
    };
    _Tokenizer.prototype._restorePosition = function(position) {
      this._peek = position[0];
      this._index = position[1];
      this._column = position[2];
      this._line = position[3];
      var nbTokens = position[4];
      if (nbTokens < this.tokens.length) {
        this.tokens = this.tokens.slice(0, nbTokens);
      }
    };
    _Tokenizer.prototype._isInExpansionCase = function() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START;
    };
    _Tokenizer.prototype._isInExpansionForm = function() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START;
    };
    return _Tokenizer;
  }());
  function isNotWhitespace(code) {
    return !chars.isWhitespace(code) || code === chars.$EOF;
  }
  function isNameEnd(code) {
    return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;
  }
  function isPrefixEnd(code) {
    return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) && (code < chars.$0 || code > chars.$9);
  }
  function isDigitEntityEnd(code) {
    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);
  }
  function isExpansionFormStart(input, offset, interpolationConfig) {
    var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
    return input.charCodeAt(offset) == chars.$LBRACE && !isInterpolationStart;
  }
  function isExpansionCaseStart(peek) {
    return peek === chars.$EQ || chars.isAsciiLetter(peek);
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
    return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;
  }
  function mergeTextTokens(srcTokens) {
    var dstTokens = [];
    var lastDstToken;
    for (var i = 0; i < srcTokens.length; i++) {
      var token = srcTokens[i];
      if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {
        lastDstToken.parts[0] += token.parts[0];
        lastDstToken.sourceSpan.end = token.sourceSpan.end;
      } else {
        lastDstToken = token;
        dstTokens.push(lastDstToken);
      }
    }
    return dstTokens;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/parser.js", ["../facade/collection", "../facade/lang", "../parse_util", "./ast", "./interpolation_config", "./lexer", "./tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var parse_util_1 = $__require('../parse_util');
  var html = $__require('./ast');
  var interpolation_config_1 = $__require('./interpolation_config');
  var lex = $__require('./lexer');
  var tags_1 = $__require('./tags');
  var TreeError = (function(_super) {
    __extends(TreeError, _super);
    function TreeError(elementName, span, msg) {
      _super.call(this, span, msg);
      this.elementName = elementName;
    }
    TreeError.create = function(elementName, span, msg) {
      return new TreeError(elementName, span, msg);
    };
    return TreeError;
  }(parse_util_1.ParseError));
  exports.TreeError = TreeError;
  var ParseTreeResult = (function() {
    function ParseTreeResult(rootNodes, errors) {
      this.rootNodes = rootNodes;
      this.errors = errors;
    }
    return ParseTreeResult;
  }());
  exports.ParseTreeResult = ParseTreeResult;
  var Parser = (function() {
    function Parser(_getTagDefinition) {
      this._getTagDefinition = _getTagDefinition;
    }
    Parser.prototype.parse = function(source, url, parseExpansionForms, interpolationConfig) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      var tokensAndErrors = lex.tokenize(source, url, this._getTagDefinition, parseExpansionForms, interpolationConfig);
      var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this._getTagDefinition).build();
      return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
    };
    return Parser;
  }());
  exports.Parser = Parser;
  var _TreeBuilder = (function() {
    function _TreeBuilder(tokens, getTagDefinition) {
      this.tokens = tokens;
      this.getTagDefinition = getTagDefinition;
      this._index = -1;
      this._rootNodes = [];
      this._errors = [];
      this._elementStack = [];
      this._advance();
    }
    _TreeBuilder.prototype.build = function() {
      while (this._peek.type !== lex.TokenType.EOF) {
        if (this._peek.type === lex.TokenType.TAG_OPEN_START) {
          this._consumeStartTag(this._advance());
        } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {
          this._consumeEndTag(this._advance());
        } else if (this._peek.type === lex.TokenType.CDATA_START) {
          this._closeVoidElement();
          this._consumeCdata(this._advance());
        } else if (this._peek.type === lex.TokenType.COMMENT_START) {
          this._closeVoidElement();
          this._consumeComment(this._advance());
        } else if (this._peek.type === lex.TokenType.TEXT || this._peek.type === lex.TokenType.RAW_TEXT || this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT) {
          this._closeVoidElement();
          this._consumeText(this._advance());
        } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {
          this._consumeExpansion(this._advance());
        } else {
          this._advance();
        }
      }
      return new ParseTreeResult(this._rootNodes, this._errors);
    };
    _TreeBuilder.prototype._advance = function() {
      var prev = this._peek;
      if (this._index < this.tokens.length - 1) {
        this._index++;
      }
      this._peek = this.tokens[this._index];
      return prev;
    };
    _TreeBuilder.prototype._advanceIf = function(type) {
      if (this._peek.type === type) {
        return this._advance();
      }
      return null;
    };
    _TreeBuilder.prototype._consumeCdata = function(startToken) {
      this._consumeText(this._advance());
      this._advanceIf(lex.TokenType.CDATA_END);
    };
    _TreeBuilder.prototype._consumeComment = function(token) {
      var text = this._advanceIf(lex.TokenType.RAW_TEXT);
      this._advanceIf(lex.TokenType.COMMENT_END);
      var value = lang_1.isPresent(text) ? text.parts[0].trim() : null;
      this._addToParent(new html.Comment(value, token.sourceSpan));
    };
    _TreeBuilder.prototype._consumeExpansion = function(token) {
      var switchValue = this._advance();
      var type = this._advance();
      var cases = [];
      while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {
        var expCase = this._parseExpansionCase();
        if (lang_1.isBlank(expCase))
          return;
        cases.push(expCase);
      }
      if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {
        this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
      }
      var sourceSpan = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
      this._advance();
    };
    _TreeBuilder.prototype._parseExpansionCase = function() {
      var value = this._advance();
      if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {
        this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
        return null;
      }
      var start = this._advance();
      var exp = this._collectExpansionExpTokens(start);
      if (lang_1.isBlank(exp))
        return null;
      var end = this._advance();
      exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));
      var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
      if (parsedExp.errors.length > 0) {
        this._errors = this._errors.concat(parsedExp.errors);
        return null;
      }
      var sourceSpan = new parse_util_1.ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
      var expSourceSpan = new parse_util_1.ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
      return new html.ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    };
    _TreeBuilder.prototype._collectExpansionExpTokens = function(start) {
      var exp = [];
      var expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];
      while (true) {
        if (this._peek.type === lex.TokenType.EXPANSION_FORM_START || this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START) {
          expansionFormStack.push(this._peek.type);
        }
        if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {
          if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {
            expansionFormStack.pop();
            if (expansionFormStack.length == 0)
              return exp;
          } else {
            this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }
        if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {
          if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {
            expansionFormStack.pop();
          } else {
            this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }
        if (this._peek.type === lex.TokenType.EOF) {
          this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
          return null;
        }
        exp.push(this._advance());
      }
    };
    _TreeBuilder.prototype._consumeText = function(token) {
      var text = token.parts[0];
      if (text.length > 0 && text[0] == '\n') {
        var parent_1 = this._getParentElement();
        if (lang_1.isPresent(parent_1) && parent_1.children.length == 0 && this.getTagDefinition(parent_1.name).ignoreFirstLf) {
          text = text.substring(1);
        }
      }
      if (text.length > 0) {
        this._addToParent(new html.Text(text, token.sourceSpan));
      }
    };
    _TreeBuilder.prototype._closeVoidElement = function() {
      if (this._elementStack.length > 0) {
        var el = collection_1.ListWrapper.last(this._elementStack);
        if (this.getTagDefinition(el.name).isVoid) {
          this._elementStack.pop();
        }
      }
    };
    _TreeBuilder.prototype._consumeStartTag = function(startTagToken) {
      var prefix = startTagToken.parts[0];
      var name = startTagToken.parts[1];
      var attrs = [];
      while (this._peek.type === lex.TokenType.ATTR_NAME) {
        attrs.push(this._consumeAttr(this._advance()));
      }
      var fullName = this._getElementFullName(prefix, name, this._getParentElement());
      var selfClosing = false;
      if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {
        this._advance();
        selfClosing = true;
        var tagDef = this.getTagDefinition(fullName);
        if (!(tagDef.canSelfClose || tags_1.getNsPrefix(fullName) !== null || tagDef.isVoid)) {
          this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
        }
      } else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {
        this._advance();
        selfClosing = false;
      }
      var end = this._peek.sourceSpan.start;
      var span = new parse_util_1.ParseSourceSpan(startTagToken.sourceSpan.start, end);
      var el = new html.Element(fullName, attrs, [], span, span, null);
      this._pushElement(el);
      if (selfClosing) {
        this._popElement(fullName);
        el.endSourceSpan = span;
      }
    };
    _TreeBuilder.prototype._pushElement = function(el) {
      if (this._elementStack.length > 0) {
        var parentEl = collection_1.ListWrapper.last(this._elementStack);
        if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
          this._elementStack.pop();
        }
      }
      var tagDef = this.getTagDefinition(el.name);
      var _a = this._getParentElementSkippingContainers(),
          parent = _a.parent,
          container = _a.container;
      if (lang_1.isPresent(parent) && tagDef.requireExtraParent(parent.name)) {
        var newParent = new html.Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
        this._insertBeforeContainer(parent, container, newParent);
      }
      this._addToParent(el);
      this._elementStack.push(el);
    };
    _TreeBuilder.prototype._consumeEndTag = function(endTagToken) {
      var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
      if (this._getParentElement()) {
        this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
      }
      if (this.getTagDefinition(fullName).isVoid) {
        this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
      } else if (!this._popElement(fullName)) {
        this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
      }
    };
    _TreeBuilder.prototype._popElement = function(fullName) {
      for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        var el = this._elementStack[stackIndex];
        if (el.name == fullName) {
          collection_1.ListWrapper.splice(this._elementStack, stackIndex, this._elementStack.length - stackIndex);
          return true;
        }
        if (!this.getTagDefinition(el.name).closedByParent) {
          return false;
        }
      }
      return false;
    };
    _TreeBuilder.prototype._consumeAttr = function(attrName) {
      var fullName = tags_1.mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      var end = attrName.sourceSpan.end;
      var value = '';
      if (this._peek.type === lex.TokenType.ATTR_VALUE) {
        var valueToken = this._advance();
        value = valueToken.parts[0];
        end = valueToken.sourceSpan.end;
      }
      return new html.Attribute(fullName, value, new parse_util_1.ParseSourceSpan(attrName.sourceSpan.start, end));
    };
    _TreeBuilder.prototype._getParentElement = function() {
      return this._elementStack.length > 0 ? collection_1.ListWrapper.last(this._elementStack) : null;
    };
    _TreeBuilder.prototype._getParentElementSkippingContainers = function() {
      var container = null;
      for (var i = this._elementStack.length - 1; i >= 0; i--) {
        if (this._elementStack[i].name !== 'ng-container') {
          return {
            parent: this._elementStack[i],
            container: container
          };
        }
        container = this._elementStack[i];
      }
      return {
        parent: collection_1.ListWrapper.last(this._elementStack),
        container: container
      };
    };
    _TreeBuilder.prototype._addToParent = function(node) {
      var parent = this._getParentElement();
      if (lang_1.isPresent(parent)) {
        parent.children.push(node);
      } else {
        this._rootNodes.push(node);
      }
    };
    _TreeBuilder.prototype._insertBeforeContainer = function(parent, container, node) {
      if (!container) {
        this._addToParent(node);
        this._elementStack.push(node);
      } else {
        if (parent) {
          var index = parent.children.indexOf(container);
          parent.children[index] = node;
        } else {
          this._rootNodes.push(node);
        }
        node.children.push(container);
        this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
      }
    };
    _TreeBuilder.prototype._getElementFullName = function(prefix, localName, parentElement) {
      if (lang_1.isBlank(prefix)) {
        prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
        if (lang_1.isBlank(prefix) && lang_1.isPresent(parentElement)) {
          prefix = tags_1.getNsPrefix(parentElement.name);
        }
      }
      return tags_1.mergeNsAndName(prefix, localName);
    };
    return _TreeBuilder;
  }());
  function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/html_parser.js", ["@angular/core", "./html_tags", "./interpolation_config", "./parser"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var html_tags_1 = $__require('./html_tags');
  var interpolation_config_1 = $__require('./interpolation_config');
  var parser_1 = $__require('./parser');
  var parser_2 = $__require('./parser');
  exports.ParseTreeResult = parser_2.ParseTreeResult;
  exports.TreeError = parser_2.TreeError;
  var HtmlParser = (function(_super) {
    __extends(HtmlParser, _super);
    function HtmlParser() {
      _super.call(this, html_tags_1.getHtmlTagDefinition);
    }
    HtmlParser.prototype.parse = function(source, url, parseExpansionForms, interpolationConfig) {
      if (parseExpansionForms === void 0) {
        parseExpansionForms = false;
      }
      if (interpolationConfig === void 0) {
        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
      }
      return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
    };
    HtmlParser.decorators = [{type: core_1.Injectable}];
    HtmlParser.ctorParameters = [];
    return HtmlParser;
  }(parser_1.Parser));
  exports.HtmlParser = HtmlParser;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/ast.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Text = (function() {
    function Text(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Text.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return Text;
  }());
  exports.Text = Text;
  var Expansion = (function() {
    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
      this.switchValue = switchValue;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
      this.switchValueSourceSpan = switchValueSourceSpan;
    }
    Expansion.prototype.visit = function(visitor, context) {
      return visitor.visitExpansion(this, context);
    };
    return Expansion;
  }());
  exports.Expansion = Expansion;
  var ExpansionCase = (function() {
    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
      this.value = value;
      this.expression = expression;
      this.sourceSpan = sourceSpan;
      this.valueSourceSpan = valueSourceSpan;
      this.expSourceSpan = expSourceSpan;
    }
    ExpansionCase.prototype.visit = function(visitor, context) {
      return visitor.visitExpansionCase(this, context);
    };
    return ExpansionCase;
  }());
  exports.ExpansionCase = ExpansionCase;
  var Attribute = (function() {
    function Attribute(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Attribute.prototype.visit = function(visitor, context) {
      return visitor.visitAttribute(this, context);
    };
    return Attribute;
  }());
  exports.Attribute = Attribute;
  var Element = (function() {
    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.children = children;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    Element.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return Element;
  }());
  exports.Element = Element;
  var Comment = (function() {
    function Comment(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    Comment.prototype.visit = function(visitor, context) {
      return visitor.visitComment(this, context);
    };
    return Comment;
  }());
  exports.Comment = Comment;
  function visitAll(visitor, nodes, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    nodes.forEach(function(ast) {
      var astResult = ast.visit(visitor, context);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  exports.visitAll = visitAll;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/icu_ast_expander.js", ["../parse_util", "./ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var parse_util_1 = $__require('../parse_util');
  var html = $__require('./ast');
  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
  function expandNodes(nodes) {
    var expander = new _Expander();
    return new ExpansionResult(html.visitAll(expander, nodes), expander.isExpanded, expander.errors);
  }
  exports.expandNodes = expandNodes;
  var ExpansionResult = (function() {
    function ExpansionResult(nodes, expanded, errors) {
      this.nodes = nodes;
      this.expanded = expanded;
      this.errors = errors;
    }
    return ExpansionResult;
  }());
  exports.ExpansionResult = ExpansionResult;
  var ExpansionError = (function(_super) {
    __extends(ExpansionError, _super);
    function ExpansionError(span, errorMsg) {
      _super.call(this, span, errorMsg);
    }
    return ExpansionError;
  }(parse_util_1.ParseError));
  exports.ExpansionError = ExpansionError;
  var _Expander = (function() {
    function _Expander() {
      this.isExpanded = false;
      this.errors = [];
    }
    _Expander.prototype.visitElement = function(element, context) {
      return new html.Element(element.name, element.attrs, html.visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
    };
    _Expander.prototype.visitAttribute = function(attribute, context) {
      return attribute;
    };
    _Expander.prototype.visitText = function(text, context) {
      return text;
    };
    _Expander.prototype.visitComment = function(comment, context) {
      return comment;
    };
    _Expander.prototype.visitExpansion = function(icu, context) {
      this.isExpanded = true;
      return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) : _expandDefaultForm(icu, this.errors);
    };
    _Expander.prototype.visitExpansionCase = function(icuCase, context) {
      throw new Error('Should not be reached');
    };
    return _Expander;
  }());
  function _expandPluralForm(ast, errors) {
    var children = ast.cases.map(function(c) {
      if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
        errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
      }
      var expansionResult = expandNodes(c.expression);
      errors.push.apply(errors, expansionResult.errors);
      return new html.Element("template", [new html.Attribute('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
    });
    var switchAttr = new html.Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
    return new html.Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  function _expandDefaultForm(ast, errors) {
    var children = ast.cases.map(function(c) {
      var expansionResult = expandNodes(c.expression);
      errors.push.apply(errors, expansionResult.errors);
      return new html.Element("template", [new html.Attribute('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
    });
    var switchAttr = new html.Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
    return new html.Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/assertions.js", ["@angular/core", "../src/facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../src/facade/lang');
  function assertArrayOfStrings(identifier, value) {
    if (!core_1.isDevMode() || lang_1.isBlank(value)) {
      return;
    }
    if (!lang_1.isArray(value)) {
      throw new Error("Expected '" + identifier + "' to be an array of strings.");
    }
    for (var i = 0; i < value.length; i += 1) {
      if (!lang_1.isString(value[i])) {
        throw new Error("Expected '" + identifier + "' to be an array of strings.");
      }
    }
  }
  exports.assertArrayOfStrings = assertArrayOfStrings;
  var INTERPOLATION_BLACKLIST_REGEXPS = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  function assertInterpolationSymbols(identifier, value) {
    if (lang_1.isPresent(value) && !(lang_1.isArray(value) && value.length == 2)) {
      throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
    } else if (core_1.isDevMode() && !lang_1.isBlank(value)) {
      var start_1 = value[0];
      var end_1 = value[1];
      INTERPOLATION_BLACKLIST_REGEXPS.forEach(function(regexp) {
        if (regexp.test(start_1) || regexp.test(end_1)) {
          throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
        }
      });
    }
  }
  exports.assertInterpolationSymbols = assertInterpolationSymbols;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/interpolation_config.js", ["../assertions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var assertions_1 = $__require('../assertions');
  var InterpolationConfig = (function() {
    function InterpolationConfig(start, end) {
      this.start = start;
      this.end = end;
    }
    InterpolationConfig.fromArray = function(markers) {
      if (!markers) {
        return exports.DEFAULT_INTERPOLATION_CONFIG;
      }
      assertions_1.assertInterpolationSymbols('interpolation', markers);
      return new InterpolationConfig(markers[0], markers[1]);
    };
    ;
    return InterpolationConfig;
  }());
  exports.InterpolationConfig = InterpolationConfig;
  exports.DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/provider_analyzer.js", ["./compile_metadata", "./facade/collection", "./facade/exceptions", "./facade/lang", "./identifiers", "./parse_util", "./template_parser/template_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var compile_metadata_1 = $__require('./compile_metadata');
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var identifiers_1 = $__require('./identifiers');
  var parse_util_1 = $__require('./parse_util');
  var template_ast_1 = $__require('./template_parser/template_ast');
  var ProviderError = (function(_super) {
    __extends(ProviderError, _super);
    function ProviderError(message, span) {
      _super.call(this, span, message);
    }
    return ProviderError;
  }(parse_util_1.ParseError));
  exports.ProviderError = ProviderError;
  var ProviderViewContext = (function() {
    function ProviderViewContext(component, sourceSpan) {
      var _this = this;
      this.component = component;
      this.sourceSpan = sourceSpan;
      this.errors = [];
      this.viewQueries = _getViewQueries(component);
      this.viewProviders = new compile_metadata_1.CompileIdentifierMap();
      _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function(provider) {
        if (lang_1.isBlank(_this.viewProviders.get(provider.token))) {
          _this.viewProviders.add(provider.token, true);
        }
      });
    }
    return ProviderViewContext;
  }());
  exports.ProviderViewContext = ProviderViewContext;
  var ProviderElementContext = (function() {
    function ProviderElementContext(_viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
      var _this = this;
      this._viewContext = _viewContext;
      this._parent = _parent;
      this._isViewRoot = _isViewRoot;
      this._directiveAsts = _directiveAsts;
      this._sourceSpan = _sourceSpan;
      this._transformedProviders = new compile_metadata_1.CompileIdentifierMap();
      this._seenProviders = new compile_metadata_1.CompileIdentifierMap();
      this._hasViewContainer = false;
      this._attrs = {};
      attrs.forEach(function(attrAst) {
        return _this._attrs[attrAst.name] = attrAst.value;
      });
      var directivesMeta = _directiveAsts.map(function(directiveAst) {
        return directiveAst.directive;
      });
      this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, _viewContext.errors);
      this._contentQueries = _getContentQueries(directivesMeta);
      var queriedTokens = new compile_metadata_1.CompileIdentifierMap();
      this._allProviders.values().forEach(function(provider) {
        _this._addQueryReadsTo(provider.token, queriedTokens);
      });
      refs.forEach(function(refAst) {
        _this._addQueryReadsTo(new compile_metadata_1.CompileTokenMetadata({value: refAst.name}), queriedTokens);
      });
      if (lang_1.isPresent(queriedTokens.get(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef)))) {
        this._hasViewContainer = true;
      }
      this._allProviders.values().forEach(function(provider) {
        var eager = provider.eager || lang_1.isPresent(queriedTokens.get(provider.token));
        if (eager) {
          _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
        }
      });
    }
    ProviderElementContext.prototype.afterElement = function() {
      var _this = this;
      this._allProviders.values().forEach(function(provider) {
        _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
      });
    };
    Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
      get: function() {
        return this._transformedProviders.values();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
      get: function() {
        var sortedProviderTypes = this._transformedProviders.values().map(function(provider) {
          return provider.token.identifier;
        });
        var sortedDirectives = collection_1.ListWrapper.clone(this._directiveAsts);
        collection_1.ListWrapper.sort(sortedDirectives, function(dir1, dir2) {
          return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);
        });
        return sortedDirectives;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
      get: function() {
        return this._hasViewContainer;
      },
      enumerable: true,
      configurable: true
    });
    ProviderElementContext.prototype._addQueryReadsTo = function(token, queryReadTokens) {
      this._getQueriesFor(token).forEach(function(query) {
        var queryReadToken = lang_1.isPresent(query.read) ? query.read : token;
        if (lang_1.isBlank(queryReadTokens.get(queryReadToken))) {
          queryReadTokens.add(queryReadToken, true);
        }
      });
    };
    ProviderElementContext.prototype._getQueriesFor = function(token) {
      var result = [];
      var currentEl = this;
      var distance = 0;
      var queries;
      while (currentEl !== null) {
        queries = currentEl._contentQueries.get(token);
        if (lang_1.isPresent(queries)) {
          collection_1.ListWrapper.addAll(result, queries.filter(function(query) {
            return query.descendants || distance <= 1;
          }));
        }
        if (currentEl._directiveAsts.length > 0) {
          distance++;
        }
        currentEl = currentEl._parent;
      }
      queries = this._viewContext.viewQueries.get(token);
      if (lang_1.isPresent(queries)) {
        collection_1.ListWrapper.addAll(result, queries);
      }
      return result;
    };
    ProviderElementContext.prototype._getOrCreateLocalProvider = function(requestingProviderType, token, eager) {
      var _this = this;
      var resolvedProvider = this._allProviders.get(token);
      if (lang_1.isBlank(resolvedProvider) || ((requestingProviderType === template_ast_1.ProviderAstType.Directive || requestingProviderType === template_ast_1.ProviderAstType.PublicService) && resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService) || ((requestingProviderType === template_ast_1.ProviderAstType.PrivateService || requestingProviderType === template_ast_1.ProviderAstType.PublicService) && resolvedProvider.providerType === template_ast_1.ProviderAstType.Builtin)) {
        return null;
      }
      var transformedProviderAst = this._transformedProviders.get(token);
      if (lang_1.isPresent(transformedProviderAst)) {
        return transformedProviderAst;
      }
      if (lang_1.isPresent(this._seenProviders.get(token))) {
        this._viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
        return null;
      }
      this._seenProviders.add(token, true);
      var transformedProviders = resolvedProvider.providers.map(function(provider) {
        var transformedUseValue = provider.useValue;
        var transformedUseExisting = provider.useExisting;
        var transformedDeps;
        if (lang_1.isPresent(provider.useExisting)) {
          var existingDiDep = _this._getDependency(resolvedProvider.providerType, new compile_metadata_1.CompileDiDependencyMetadata({token: provider.useExisting}), eager);
          if (lang_1.isPresent(existingDiDep.token)) {
            transformedUseExisting = existingDiDep.token;
          } else {
            transformedUseExisting = null;
            transformedUseValue = existingDiDep.value;
          }
        } else if (lang_1.isPresent(provider.useFactory)) {
          var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(resolvedProvider.providerType, dep, eager);
          });
        } else if (lang_1.isPresent(provider.useClass)) {
          var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(resolvedProvider.providerType, dep, eager);
          });
        }
        return _transformProvider(provider, {
          useExisting: transformedUseExisting,
          useValue: transformedUseValue,
          deps: transformedDeps
        });
      });
      transformedProviderAst = _transformProviderAst(resolvedProvider, {
        eager: eager,
        providers: transformedProviders
      });
      this._transformedProviders.add(token, transformedProviderAst);
      return transformedProviderAst;
    };
    ProviderElementContext.prototype._getLocalDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = null;
      }
      if (dep.isAttribute) {
        var attrValue = this._attrs[dep.token.value];
        return new compile_metadata_1.CompileDiDependencyMetadata({
          isValue: true,
          value: lang_1.normalizeBlank(attrValue)
        });
      }
      if (lang_1.isPresent(dep.query) || lang_1.isPresent(dep.viewQuery)) {
        return dep;
      }
      if (lang_1.isPresent(dep.token)) {
        if ((requestingProviderType === template_ast_1.ProviderAstType.Directive || requestingProviderType === template_ast_1.ProviderAstType.Component)) {
          if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Renderer)) || dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ElementRef)) || dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef)) || dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef))) {
            return dep;
          }
          if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef))) {
            this._hasViewContainer = true;
          }
        }
        if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector))) {
          return dep;
        }
        if (lang_1.isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
          return dep;
        }
      }
      return null;
    };
    ProviderElementContext.prototype._getDependency = function(requestingProviderType, dep, eager) {
      if (eager === void 0) {
        eager = null;
      }
      var currElement = this;
      var currEager = eager;
      var result = null;
      if (!dep.isSkipSelf) {
        result = this._getLocalDependency(requestingProviderType, dep, eager);
      }
      if (dep.isSelf) {
        if (lang_1.isBlank(result) && dep.isOptional) {
          result = new compile_metadata_1.CompileDiDependencyMetadata({
            isValue: true,
            value: null
          });
        }
      } else {
        while (lang_1.isBlank(result) && lang_1.isPresent(currElement._parent)) {
          var prevElement = currElement;
          currElement = currElement._parent;
          if (prevElement._isViewRoot) {
            currEager = false;
          }
          result = currElement._getLocalDependency(template_ast_1.ProviderAstType.PublicService, dep, currEager);
        }
        if (lang_1.isBlank(result)) {
          if (!dep.isHost || this._viewContext.component.type.isHost || identifiers_1.identifierToken(this._viewContext.component.type).equalsTo(dep.token) || lang_1.isPresent(this._viewContext.viewProviders.get(dep.token))) {
            result = dep;
          } else {
            result = dep.isOptional ? result = new compile_metadata_1.CompileDiDependencyMetadata({
              isValue: true,
              value: null
            }) : null;
          }
        }
      }
      if (lang_1.isBlank(result)) {
        this._viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
      }
      return result;
    };
    return ProviderElementContext;
  }());
  exports.ProviderElementContext = ProviderElementContext;
  var NgModuleProviderAnalyzer = (function() {
    function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {
      var _this = this;
      this._transformedProviders = new compile_metadata_1.CompileIdentifierMap();
      this._seenProviders = new compile_metadata_1.CompileIdentifierMap();
      this._unparsedProviders = [];
      this._errors = [];
      this._allProviders = new compile_metadata_1.CompileIdentifierMap();
      var ngModuleTypes = ngModule.transitiveModule.modules.map(function(moduleMeta) {
        return moduleMeta.type;
      });
      ngModuleTypes.forEach(function(ngModuleType) {
        var ngModuleProvider = new compile_metadata_1.CompileProviderMetadata({
          token: new compile_metadata_1.CompileTokenMetadata({identifier: ngModuleType}),
          useClass: ngModuleType
        });
        _resolveProviders([ngModuleProvider], template_ast_1.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
      });
      _resolveProviders(_normalizeProviders(ngModule.transitiveModule.providers.concat(extraProviders), sourceSpan, this._errors), template_ast_1.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
    }
    NgModuleProviderAnalyzer.prototype.parse = function() {
      var _this = this;
      this._allProviders.values().forEach(function(provider) {
        _this._getOrCreateLocalProvider(provider.token, provider.eager);
      });
      if (this._errors.length > 0) {
        var errorString = this._errors.join('\n');
        throw new exceptions_1.BaseException("Provider parse errors:\n" + errorString);
      }
      return this._transformedProviders.values();
    };
    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function(token, eager) {
      var _this = this;
      var resolvedProvider = this._allProviders.get(token);
      if (lang_1.isBlank(resolvedProvider)) {
        return null;
      }
      var transformedProviderAst = this._transformedProviders.get(token);
      if (lang_1.isPresent(transformedProviderAst)) {
        return transformedProviderAst;
      }
      if (lang_1.isPresent(this._seenProviders.get(token))) {
        this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, resolvedProvider.sourceSpan));
        return null;
      }
      this._seenProviders.add(token, true);
      var transformedProviders = resolvedProvider.providers.map(function(provider) {
        var transformedUseValue = provider.useValue;
        var transformedUseExisting = provider.useExisting;
        var transformedDeps;
        if (lang_1.isPresent(provider.useExisting)) {
          var existingDiDep = _this._getDependency(new compile_metadata_1.CompileDiDependencyMetadata({token: provider.useExisting}), eager, resolvedProvider.sourceSpan);
          if (lang_1.isPresent(existingDiDep.token)) {
            transformedUseExisting = existingDiDep.token;
          } else {
            transformedUseExisting = null;
            transformedUseValue = existingDiDep.value;
          }
        } else if (lang_1.isPresent(provider.useFactory)) {
          var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);
          });
        } else if (lang_1.isPresent(provider.useClass)) {
          var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
          transformedDeps = deps.map(function(dep) {
            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);
          });
        }
        return _transformProvider(provider, {
          useExisting: transformedUseExisting,
          useValue: transformedUseValue,
          deps: transformedDeps
        });
      });
      transformedProviderAst = _transformProviderAst(resolvedProvider, {
        eager: eager,
        providers: transformedProviders
      });
      this._transformedProviders.add(token, transformedProviderAst);
      return transformedProviderAst;
    };
    NgModuleProviderAnalyzer.prototype._getDependency = function(dep, eager, requestorSourceSpan) {
      if (eager === void 0) {
        eager = null;
      }
      var foundLocal = false;
      if (!dep.isSkipSelf && lang_1.isPresent(dep.token)) {
        if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector)) || dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ComponentFactoryResolver))) {
          foundLocal = true;
        } else if (lang_1.isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {
          foundLocal = true;
        }
      }
      var result = dep;
      if (dep.isSelf && !foundLocal) {
        if (dep.isOptional) {
          result = new compile_metadata_1.CompileDiDependencyMetadata({
            isValue: true,
            value: null
          });
        } else {
          this._errors.push(new ProviderError("No provider for " + dep.token.name, requestorSourceSpan));
        }
      }
      return result;
    };
    return NgModuleProviderAnalyzer;
  }());
  exports.NgModuleProviderAnalyzer = NgModuleProviderAnalyzer;
  function _transformProvider(provider, _a) {
    var useExisting = _a.useExisting,
        useValue = _a.useValue,
        deps = _a.deps;
    return new compile_metadata_1.CompileProviderMetadata({
      token: provider.token,
      useClass: provider.useClass,
      useExisting: useExisting,
      useFactory: provider.useFactory,
      useValue: useValue,
      deps: deps,
      multi: provider.multi
    });
  }
  function _transformProviderAst(provider, _a) {
    var eager = _a.eager,
        providers = _a.providers;
    return new template_ast_1.ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
  }
  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
    if (targetProviders === void 0) {
      targetProviders = null;
    }
    if (lang_1.isBlank(targetProviders)) {
      targetProviders = [];
    }
    if (lang_1.isPresent(providers)) {
      providers.forEach(function(provider) {
        if (lang_1.isArray(provider)) {
          _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
        } else {
          var normalizeProvider = void 0;
          if (provider instanceof compile_metadata_1.CompileProviderMetadata) {
            normalizeProvider = provider;
          } else if (provider instanceof compile_metadata_1.CompileTypeMetadata) {
            normalizeProvider = new compile_metadata_1.CompileProviderMetadata({
              token: new compile_metadata_1.CompileTokenMetadata({identifier: provider}),
              useClass: provider
            });
          } else {
            targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
          }
          if (lang_1.isPresent(normalizeProvider)) {
            targetProviders.push(normalizeProvider);
          }
        }
      });
    }
    return targetProviders;
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
    var providersByToken = new compile_metadata_1.CompileIdentifierMap();
    directives.forEach(function(directive) {
      var dirProvider = new compile_metadata_1.CompileProviderMetadata({
        token: new compile_metadata_1.CompileTokenMetadata({identifier: directive.type}),
        useClass: directive.type
      });
      _resolveProviders([dirProvider], directive.isComponent ? template_ast_1.ProviderAstType.Component : template_ast_1.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
    });
    var directivesWithComponentFirst = directives.filter(function(dir) {
      return dir.isComponent;
    }).concat(directives.filter(function(dir) {
      return !dir.isComponent;
    }));
    directivesWithComponentFirst.forEach(function(directive) {
      _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), template_ast_1.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
      _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), template_ast_1.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
    });
    return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
    providers.forEach(function(provider) {
      var resolvedProvider = targetProvidersByToken.get(provider.token);
      if (lang_1.isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
        targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
      }
      if (lang_1.isBlank(resolvedProvider)) {
        var lifecycleHooks = provider.token.identifier && provider.token.identifier instanceof compile_metadata_1.CompileTypeMetadata ? provider.token.identifier.lifecycleHooks : [];
        resolvedProvider = new template_ast_1.ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);
        targetProvidersByToken.add(provider.token, resolvedProvider);
      } else {
        if (!provider.multi) {
          collection_1.ListWrapper.clear(resolvedProvider.providers);
        }
        resolvedProvider.providers.push(provider);
      }
    });
  }
  function _getViewQueries(component) {
    var viewQueries = new compile_metadata_1.CompileIdentifierMap();
    if (lang_1.isPresent(component.viewQueries)) {
      component.viewQueries.forEach(function(query) {
        return _addQueryToTokenMap(viewQueries, query);
      });
    }
    component.type.diDeps.forEach(function(dep) {
      if (lang_1.isPresent(dep.viewQuery)) {
        _addQueryToTokenMap(viewQueries, dep.viewQuery);
      }
    });
    return viewQueries;
  }
  function _getContentQueries(directives) {
    var contentQueries = new compile_metadata_1.CompileIdentifierMap();
    directives.forEach(function(directive) {
      if (lang_1.isPresent(directive.queries)) {
        directive.queries.forEach(function(query) {
          return _addQueryToTokenMap(contentQueries, query);
        });
      }
      directive.type.diDeps.forEach(function(dep) {
        if (lang_1.isPresent(dep.query)) {
          _addQueryToTokenMap(contentQueries, dep.query);
        }
      });
    });
    return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
    query.selectors.forEach(function(token) {
      var entry = map.get(token);
      if (lang_1.isBlank(entry)) {
        entry = [];
        map.add(token, entry);
      }
      entry.push(query);
    });
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/schema/element_schema_registry.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ElementSchemaRegistry = (function() {
    function ElementSchemaRegistry() {}
    return ElementSchemaRegistry;
  }());
  exports.ElementSchemaRegistry = ElementSchemaRegistry;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/style_url_resolver.js", ["./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./facade/lang');
  var StyleWithImports = (function() {
    function StyleWithImports(style, styleUrls) {
      this.style = style;
      this.styleUrls = styleUrls;
    }
    return StyleWithImports;
  }());
  exports.StyleWithImports = StyleWithImports;
  function isStyleUrlResolvable(url) {
    if (lang_1.isBlank(url) || url.length === 0 || url[0] == '/')
      return false;
    var schemeMatch = url.match(_urlWithSchemaRe);
    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  exports.isStyleUrlResolvable = isStyleUrlResolvable;
  function extractStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    var modifiedCssText = lang_1.StringWrapper.replaceAllMapped(cssText, _cssImportRe, function(m) {
      var url = lang_1.isPresent(m[1]) ? m[1] : m[2];
      if (!isStyleUrlResolvable(url)) {
        return m[0];
      }
      foundUrls.push(resolver.resolve(baseUrl, url));
      return '';
    });
    return new StyleWithImports(modifiedCssText, foundUrls);
  }
  exports.extractStyleUrls = extractStyleUrls;
  var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  var _urlWithSchemaRe = /^([^:/?#]+):/;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/ml_parser/tags.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(TagContentType) {
    TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
    TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
    TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(exports.TagContentType || (exports.TagContentType = {}));
  var TagContentType = exports.TagContentType;
  function splitNsName(elementName) {
    if (elementName[0] != ':') {
      return [null, elementName];
    }
    var colonIndex = elementName.indexOf(':', 1);
    if (colonIndex == -1) {
      throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
    }
    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  exports.splitNsName = splitNsName;
  function getNsPrefix(fullName) {
    return fullName === null ? null : splitNsName(fullName)[0];
  }
  exports.getNsPrefix = getNsPrefix;
  function mergeNsAndName(prefix, localName) {
    return prefix ? ":" + prefix + ":" + localName : localName;
  }
  exports.mergeNsAndName = mergeNsAndName;
  exports.NAMED_ENTITIES = {
    'Aacute': '\u00C1',
    'aacute': '\u00E1',
    'Acirc': '\u00C2',
    'acirc': '\u00E2',
    'acute': '\u00B4',
    'AElig': '\u00C6',
    'aelig': '\u00E6',
    'Agrave': '\u00C0',
    'agrave': '\u00E0',
    'alefsym': '\u2135',
    'Alpha': '\u0391',
    'alpha': '\u03B1',
    'amp': '&',
    'and': '\u2227',
    'ang': '\u2220',
    'apos': '\u0027',
    'Aring': '\u00C5',
    'aring': '\u00E5',
    'asymp': '\u2248',
    'Atilde': '\u00C3',
    'atilde': '\u00E3',
    'Auml': '\u00C4',
    'auml': '\u00E4',
    'bdquo': '\u201E',
    'Beta': '\u0392',
    'beta': '\u03B2',
    'brvbar': '\u00A6',
    'bull': '\u2022',
    'cap': '\u2229',
    'Ccedil': '\u00C7',
    'ccedil': '\u00E7',
    'cedil': '\u00B8',
    'cent': '\u00A2',
    'Chi': '\u03A7',
    'chi': '\u03C7',
    'circ': '\u02C6',
    'clubs': '\u2663',
    'cong': '\u2245',
    'copy': '\u00A9',
    'crarr': '\u21B5',
    'cup': '\u222A',
    'curren': '\u00A4',
    'dagger': '\u2020',
    'Dagger': '\u2021',
    'darr': '\u2193',
    'dArr': '\u21D3',
    'deg': '\u00B0',
    'Delta': '\u0394',
    'delta': '\u03B4',
    'diams': '\u2666',
    'divide': '\u00F7',
    'Eacute': '\u00C9',
    'eacute': '\u00E9',
    'Ecirc': '\u00CA',
    'ecirc': '\u00EA',
    'Egrave': '\u00C8',
    'egrave': '\u00E8',
    'empty': '\u2205',
    'emsp': '\u2003',
    'ensp': '\u2002',
    'Epsilon': '\u0395',
    'epsilon': '\u03B5',
    'equiv': '\u2261',
    'Eta': '\u0397',
    'eta': '\u03B7',
    'ETH': '\u00D0',
    'eth': '\u00F0',
    'Euml': '\u00CB',
    'euml': '\u00EB',
    'euro': '\u20AC',
    'exist': '\u2203',
    'fnof': '\u0192',
    'forall': '\u2200',
    'frac12': '\u00BD',
    'frac14': '\u00BC',
    'frac34': '\u00BE',
    'frasl': '\u2044',
    'Gamma': '\u0393',
    'gamma': '\u03B3',
    'ge': '\u2265',
    'gt': '>',
    'harr': '\u2194',
    'hArr': '\u21D4',
    'hearts': '\u2665',
    'hellip': '\u2026',
    'Iacute': '\u00CD',
    'iacute': '\u00ED',
    'Icirc': '\u00CE',
    'icirc': '\u00EE',
    'iexcl': '\u00A1',
    'Igrave': '\u00CC',
    'igrave': '\u00EC',
    'image': '\u2111',
    'infin': '\u221E',
    'int': '\u222B',
    'Iota': '\u0399',
    'iota': '\u03B9',
    'iquest': '\u00BF',
    'isin': '\u2208',
    'Iuml': '\u00CF',
    'iuml': '\u00EF',
    'Kappa': '\u039A',
    'kappa': '\u03BA',
    'Lambda': '\u039B',
    'lambda': '\u03BB',
    'lang': '\u27E8',
    'laquo': '\u00AB',
    'larr': '\u2190',
    'lArr': '\u21D0',
    'lceil': '\u2308',
    'ldquo': '\u201C',
    'le': '\u2264',
    'lfloor': '\u230A',
    'lowast': '\u2217',
    'loz': '\u25CA',
    'lrm': '\u200E',
    'lsaquo': '\u2039',
    'lsquo': '\u2018',
    'lt': '<',
    'macr': '\u00AF',
    'mdash': '\u2014',
    'micro': '\u00B5',
    'middot': '\u00B7',
    'minus': '\u2212',
    'Mu': '\u039C',
    'mu': '\u03BC',
    'nabla': '\u2207',
    'nbsp': '\u00A0',
    'ndash': '\u2013',
    'ne': '\u2260',
    'ni': '\u220B',
    'not': '\u00AC',
    'notin': '\u2209',
    'nsub': '\u2284',
    'Ntilde': '\u00D1',
    'ntilde': '\u00F1',
    'Nu': '\u039D',
    'nu': '\u03BD',
    'Oacute': '\u00D3',
    'oacute': '\u00F3',
    'Ocirc': '\u00D4',
    'ocirc': '\u00F4',
    'OElig': '\u0152',
    'oelig': '\u0153',
    'Ograve': '\u00D2',
    'ograve': '\u00F2',
    'oline': '\u203E',
    'Omega': '\u03A9',
    'omega': '\u03C9',
    'Omicron': '\u039F',
    'omicron': '\u03BF',
    'oplus': '\u2295',
    'or': '\u2228',
    'ordf': '\u00AA',
    'ordm': '\u00BA',
    'Oslash': '\u00D8',
    'oslash': '\u00F8',
    'Otilde': '\u00D5',
    'otilde': '\u00F5',
    'otimes': '\u2297',
    'Ouml': '\u00D6',
    'ouml': '\u00F6',
    'para': '\u00B6',
    'permil': '\u2030',
    'perp': '\u22A5',
    'Phi': '\u03A6',
    'phi': '\u03C6',
    'Pi': '\u03A0',
    'pi': '\u03C0',
    'piv': '\u03D6',
    'plusmn': '\u00B1',
    'pound': '\u00A3',
    'prime': '\u2032',
    'Prime': '\u2033',
    'prod': '\u220F',
    'prop': '\u221D',
    'Psi': '\u03A8',
    'psi': '\u03C8',
    'quot': '\u0022',
    'radic': '\u221A',
    'rang': '\u27E9',
    'raquo': '\u00BB',
    'rarr': '\u2192',
    'rArr': '\u21D2',
    'rceil': '\u2309',
    'rdquo': '\u201D',
    'real': '\u211C',
    'reg': '\u00AE',
    'rfloor': '\u230B',
    'Rho': '\u03A1',
    'rho': '\u03C1',
    'rlm': '\u200F',
    'rsaquo': '\u203A',
    'rsquo': '\u2019',
    'sbquo': '\u201A',
    'Scaron': '\u0160',
    'scaron': '\u0161',
    'sdot': '\u22C5',
    'sect': '\u00A7',
    'shy': '\u00AD',
    'Sigma': '\u03A3',
    'sigma': '\u03C3',
    'sigmaf': '\u03C2',
    'sim': '\u223C',
    'spades': '\u2660',
    'sub': '\u2282',
    'sube': '\u2286',
    'sum': '\u2211',
    'sup': '\u2283',
    'sup1': '\u00B9',
    'sup2': '\u00B2',
    'sup3': '\u00B3',
    'supe': '\u2287',
    'szlig': '\u00DF',
    'Tau': '\u03A4',
    'tau': '\u03C4',
    'there4': '\u2234',
    'Theta': '\u0398',
    'theta': '\u03B8',
    'thetasym': '\u03D1',
    'thinsp': '\u2009',
    'THORN': '\u00DE',
    'thorn': '\u00FE',
    'tilde': '\u02DC',
    'times': '\u00D7',
    'trade': '\u2122',
    'Uacute': '\u00DA',
    'uacute': '\u00FA',
    'uarr': '\u2191',
    'uArr': '\u21D1',
    'Ucirc': '\u00DB',
    'ucirc': '\u00FB',
    'Ugrave': '\u00D9',
    'ugrave': '\u00F9',
    'uml': '\u00A8',
    'upsih': '\u03D2',
    'Upsilon': '\u03A5',
    'upsilon': '\u03C5',
    'Uuml': '\u00DC',
    'uuml': '\u00FC',
    'weierp': '\u2118',
    'Xi': '\u039E',
    'xi': '\u03BE',
    'Yacute': '\u00DD',
    'yacute': '\u00FD',
    'yen': '\u00A5',
    'yuml': '\u00FF',
    'Yuml': '\u0178',
    'Zeta': '\u0396',
    'zeta': '\u03B6',
    'zwj': '\u200D',
    'zwnj': '\u200C'
  };
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/template_parser/template_preparser.js", ["../ml_parser/tags"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var tags_1 = $__require('../ml_parser/tags');
  var NG_CONTENT_SELECT_ATTR = 'select';
  var NG_CONTENT_ELEMENT = 'ng-content';
  var LINK_ELEMENT = 'link';
  var LINK_STYLE_REL_ATTR = 'rel';
  var LINK_STYLE_HREF_ATTR = 'href';
  var LINK_STYLE_REL_VALUE = 'stylesheet';
  var STYLE_ELEMENT = 'style';
  var SCRIPT_ELEMENT = 'script';
  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  var NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
    var selectAttr = null;
    var hrefAttr = null;
    var relAttr = null;
    var nonBindable = false;
    var projectAs = null;
    ast.attrs.forEach(function(attr) {
      var lcAttrName = attr.name.toLowerCase();
      if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
        selectAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
        hrefAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
        relAttr = attr.value;
      } else if (attr.name == NG_NON_BINDABLE_ATTR) {
        nonBindable = true;
      } else if (attr.name == NG_PROJECT_AS) {
        if (attr.value.length > 0) {
          projectAs = attr.value;
        }
      }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name.toLowerCase();
    var type = PreparsedElementType.OTHER;
    if (tags_1.splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
      type = PreparsedElementType.NG_CONTENT;
    } else if (nodeName == STYLE_ELEMENT) {
      type = PreparsedElementType.STYLE;
    } else if (nodeName == SCRIPT_ELEMENT) {
      type = PreparsedElementType.SCRIPT;
    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
      type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  exports.preparseElement = preparseElement;
  (function(PreparsedElementType) {
    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
  })(exports.PreparsedElementType || (exports.PreparsedElementType = {}));
  var PreparsedElementType = exports.PreparsedElementType;
  var PreparsedElement = (function() {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    }
    return PreparsedElement;
  }());
  exports.PreparsedElement = PreparsedElement;
  function normalizeNgContentSelect(selectAttr) {
    if (selectAttr === null || selectAttr.length === 0) {
      return '*';
    }
    return selectAttr;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/template_parser/template_parser.js", ["@angular/core", "../../core_private", "../compile_metadata", "../expression_parser/ast", "../expression_parser/parser", "../facade/collection", "../facade/exceptions", "../facade/lang", "../identifiers", "../ml_parser/ast", "../ml_parser/html_parser", "../ml_parser/icu_ast_expander", "../ml_parser/interpolation_config", "../ml_parser/tags", "../parse_util", "../provider_analyzer", "../schema/element_schema_registry", "../selector", "../style_url_resolver", "../util", "./template_ast", "./template_preparser"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../core_private');
  var compile_metadata_1 = $__require('../compile_metadata');
  var ast_1 = $__require('../expression_parser/ast');
  var parser_1 = $__require('../expression_parser/parser');
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var html = $__require('../ml_parser/ast');
  var html_parser_1 = $__require('../ml_parser/html_parser');
  var icu_ast_expander_1 = $__require('../ml_parser/icu_ast_expander');
  var interpolation_config_1 = $__require('../ml_parser/interpolation_config');
  var tags_1 = $__require('../ml_parser/tags');
  var parse_util_1 = $__require('../parse_util');
  var provider_analyzer_1 = $__require('../provider_analyzer');
  var element_schema_registry_1 = $__require('../schema/element_schema_registry');
  var selector_1 = $__require('../selector');
  var style_url_resolver_1 = $__require('../style_url_resolver');
  var util_1 = $__require('../util');
  var template_ast_1 = $__require('./template_ast');
  var template_preparser_1 = $__require('./template_preparser');
  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-)|(let-)|(ref-|#)|(on-)|(bindon-)|(animate-|@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  var TEMPLATE_ELEMENT = 'template';
  var TEMPLATE_ATTR = 'template';
  var TEMPLATE_ATTR_PREFIX = '*';
  var CLASS_ATTR = 'class';
  var PROPERTY_PARTS_SEPARATOR = '.';
  var ATTRIBUTE_PREFIX = 'attr';
  var CLASS_PREFIX = 'class';
  var STYLE_PREFIX = 'style';
  var TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];
  exports.TEMPLATE_TRANSFORMS = new core_1.OpaqueToken('TemplateTransforms');
  var TemplateParseError = (function(_super) {
    __extends(TemplateParseError, _super);
    function TemplateParseError(message, span, level) {
      _super.call(this, span, message, level);
    }
    return TemplateParseError;
  }(parse_util_1.ParseError));
  exports.TemplateParseError = TemplateParseError;
  var TemplateParseResult = (function() {
    function TemplateParseResult(templateAst, errors) {
      this.templateAst = templateAst;
      this.errors = errors;
    }
    return TemplateParseResult;
  }());
  exports.TemplateParseResult = TemplateParseResult;
  var TemplateParser = (function() {
    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
      this._exprParser = _exprParser;
      this._schemaRegistry = _schemaRegistry;
      this._htmlParser = _htmlParser;
      this._console = _console;
      this.transforms = transforms;
    }
    TemplateParser.prototype.parse = function(component, template, directives, pipes, schemas, templateUrl) {
      var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
      var warnings = result.errors.filter(function(error) {
        return error.level === parse_util_1.ParseErrorLevel.WARNING;
      });
      var errors = result.errors.filter(function(error) {
        return error.level === parse_util_1.ParseErrorLevel.FATAL;
      });
      if (warnings.length > 0) {
        this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
      }
      if (errors.length > 0) {
        var errorString = errors.join('\n');
        throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
      }
      return result.templateAst;
    };
    TemplateParser.prototype.tryParse = function(component, template, directives, pipes, schemas, templateUrl) {
      var interpolationConfig;
      if (component.template) {
        interpolationConfig = interpolation_config_1.InterpolationConfig.fromArray(component.template.interpolation);
      }
      var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl, true, interpolationConfig);
      var errors = htmlAstWithErrors.errors;
      var result;
      if (errors.length == 0) {
        var expandedHtmlAst = icu_ast_expander_1.expandNodes(htmlAstWithErrors.rootNodes);
        errors.push.apply(errors, expandedHtmlAst.errors);
        htmlAstWithErrors = new html_parser_1.ParseTreeResult(expandedHtmlAst.nodes, errors);
      }
      if (htmlAstWithErrors.rootNodes.length > 0) {
        var uniqDirectives = compile_metadata_1.removeIdentifierDuplicates(directives);
        var uniqPipes = compile_metadata_1.removeIdentifierDuplicates(pipes);
        var providerViewContext = new provider_analyzer_1.ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
        var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, schemas, this._exprParser, this._schemaRegistry);
        result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
        errors.push.apply(errors, parseVisitor.errors.concat(providerViewContext.errors));
      } else {
        result = [];
      }
      this._assertNoReferenceDuplicationOnTemplate(result, errors);
      if (errors.length > 0) {
        return new TemplateParseResult(result, errors);
      }
      if (lang_1.isPresent(this.transforms)) {
        this.transforms.forEach(function(transform) {
          result = template_ast_1.templateVisitAll(transform, result);
        });
      }
      return new TemplateParseResult(result, errors);
    };
    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function(result, errors) {
      var existingReferences = [];
      result.filter(function(element) {
        return !!element.references;
      }).forEach(function(element) {
        return element.references.forEach(function(reference) {
          var name = reference.name;
          if (existingReferences.indexOf(name) < 0) {
            existingReferences.push(name);
          } else {
            var error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, parse_util_1.ParseErrorLevel.FATAL);
            errors.push(error);
          }
        });
      });
    };
    TemplateParser.decorators = [{type: core_1.Injectable}];
    TemplateParser.ctorParameters = [{type: parser_1.Parser}, {type: element_schema_registry_1.ElementSchemaRegistry}, {type: html_parser_1.HtmlParser}, {type: core_private_1.Console}, {
      type: Array,
      decorators: [{type: core_1.Optional}, {
        type: core_1.Inject,
        args: [exports.TEMPLATE_TRANSFORMS]
      }]
    }];
    return TemplateParser;
  }());
  exports.TemplateParser = TemplateParser;
  var TemplateParseVisitor = (function() {
    function TemplateParseVisitor(providerViewContext, directives, pipes, _schemas, _exprParser, _schemaRegistry) {
      var _this = this;
      this.providerViewContext = providerViewContext;
      this._schemas = _schemas;
      this._exprParser = _exprParser;
      this._schemaRegistry = _schemaRegistry;
      this.errors = [];
      this.directivesIndex = new Map();
      this.ngContentCount = 0;
      this.selectorMatcher = new selector_1.SelectorMatcher();
      var tempMeta = providerViewContext.component.template;
      if (lang_1.isPresent(tempMeta) && lang_1.isPresent(tempMeta.interpolation)) {
        this._interpolationConfig = {
          start: tempMeta.interpolation[0],
          end: tempMeta.interpolation[1]
        };
      }
      collection_1.ListWrapper.forEachWithIndex(directives, function(directive, index) {
        var selector = selector_1.CssSelector.parse(directive.selector);
        _this.selectorMatcher.addSelectables(selector, directive);
        _this.directivesIndex.set(directive, index);
      });
      this.pipesByName = new Map();
      pipes.forEach(function(pipe) {
        return _this.pipesByName.set(pipe.name, pipe);
      });
    }
    TemplateParseVisitor.prototype._reportError = function(message, sourceSpan, level) {
      if (level === void 0) {
        level = parse_util_1.ParseErrorLevel.FATAL;
      }
      this.errors.push(new TemplateParseError(message, sourceSpan, level));
    };
    TemplateParseVisitor.prototype._reportParserErors = function(errors, sourceSpan) {
      for (var _i = 0,
          errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        this._reportError(error.message, sourceSpan);
      }
    };
    TemplateParseVisitor.prototype._parseInterpolation = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
        if (ast)
          this._reportParserErors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        if (lang_1.isPresent(ast) && ast.ast.expressions.length > core_private_1.MAX_INTERPOLATION_VALUES) {
          throw new exceptions_1.BaseException("Only support at most " + core_private_1.MAX_INTERPOLATION_VALUES + " interpolation values!");
        }
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseAction = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
        if (ast) {
          this._reportParserErors(ast.errors, sourceSpan);
        }
        if (!ast || ast.ast instanceof ast_1.EmptyExpr) {
          this._reportError("Empty expressions are not allowed", sourceSpan);
          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseBinding = function(value, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      try {
        var ast = this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
        if (ast)
          this._reportParserErors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
      }
    };
    TemplateParseVisitor.prototype._parseTemplateBindings = function(value, sourceSpan) {
      var _this = this;
      var sourceInfo = sourceSpan.start.toString();
      try {
        var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
        this._reportParserErors(bindingsResult.errors, sourceSpan);
        bindingsResult.templateBindings.forEach(function(binding) {
          if (lang_1.isPresent(binding.expression)) {
            _this._checkPipes(binding.expression, sourceSpan);
          }
        });
        bindingsResult.warnings.forEach(function(warning) {
          _this._reportError(warning, sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError("" + e, sourceSpan);
        return [];
      }
    };
    TemplateParseVisitor.prototype._checkPipes = function(ast, sourceSpan) {
      var _this = this;
      if (lang_1.isPresent(ast)) {
        var collector = new PipeCollector();
        ast.visit(collector);
        collector.pipes.forEach(function(pipeName) {
          if (!_this.pipesByName.has(pipeName)) {
            _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
          }
        });
      }
    };
    TemplateParseVisitor.prototype.visitExpansion = function(expansion, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitExpansionCase = function(expansionCase, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitText = function(text, parent) {
      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
      var expr = this._parseInterpolation(text.value, text.sourceSpan);
      if (lang_1.isPresent(expr)) {
        return new template_ast_1.BoundTextAst(expr, ngContentIndex, text.sourceSpan);
      } else {
        return new template_ast_1.TextAst(text.value, ngContentIndex, text.sourceSpan);
      }
    };
    TemplateParseVisitor.prototype.visitAttribute = function(attribute, contex) {
      return new template_ast_1.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
    };
    TemplateParseVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    TemplateParseVisitor.prototype.visitElement = function(element, parent) {
      var _this = this;
      var nodeName = element.name;
      var preparsedElement = template_preparser_1.preparseElement(element);
      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {
        return null;
      }
      if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET && style_url_resolver_1.isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        return null;
      }
      var matchableAttrs = [];
      var elementOrDirectiveProps = [];
      var elementOrDirectiveRefs = [];
      var elementVars = [];
      var animationProps = [];
      var events = [];
      var templateElementOrDirectiveProps = [];
      var templateMatchableAttrs = [];
      var templateElementVars = [];
      var hasInlineTemplates = false;
      var attrs = [];
      var lcElName = tags_1.splitNsName(nodeName.toLowerCase())[1];
      var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
      element.attrs.forEach(function(attr) {
        var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, animationProps, events, elementOrDirectiveRefs, elementVars);
        var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
        if (hasTemplateBinding && hasInlineTemplates) {
          _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
        }
        if (!hasBinding && !hasTemplateBinding) {
          attrs.push(_this.visitAttribute(attr, null));
          matchableAttrs.push([attr.name, attr.value]);
        }
        if (hasTemplateBinding) {
          hasInlineTemplates = true;
        }
      });
      var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
      var directiveMetas = this._parseDirectives(this.selectorMatcher, elementCssSelector);
      var references = [];
      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts).concat(animationProps);
      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
      var providerContext = new provider_analyzer_1.ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
      var children = html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
      providerContext.afterElement();
      var projectionSelector = lang_1.isPresent(preparsedElement.projectAs) ? selector_1.CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;
      var ngContentIndex = parent.findNgContentIndex(projectionSelector);
      var parsedElement;
      if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {
        if (lang_1.isPresent(element.children) && element.children.length > 0) {
          this._reportError("<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>", element.sourceSpan);
        }
        parsedElement = new template_ast_1.NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
      } else if (isTemplateElement) {
        this._assertAllEventsPublishedByDirectives(directiveAsts, events);
        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
        parsedElement = new template_ast_1.EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
      } else {
        this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
        var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
        parsedElement = new template_ast_1.ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan);
      }
      if (hasInlineTemplates) {
        var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
        var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector);
        var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
        var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
        var templateProviderContext = new provider_analyzer_1.ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
        templateProviderContext.afterElement();
        parsedElement = new template_ast_1.EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
      }
      return parsedElement;
    };
    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function(attr, targetMatchableAttrs, targetProps, targetVars) {
      var templateBindingsSource = null;
      if (this._normalizeAttributeName(attr.name) == TEMPLATE_ATTR) {
        templateBindingsSource = attr.value;
      } else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
        var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length);
        templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
      }
      if (lang_1.isPresent(templateBindingsSource)) {
        var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
        for (var i = 0; i < bindings.length; i++) {
          var binding = bindings[i];
          if (binding.keyIsVar) {
            targetVars.push(new template_ast_1.VariableAst(binding.key, binding.name, attr.sourceSpan));
          } else if (lang_1.isPresent(binding.expression)) {
            this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
          } else {
            targetMatchableAttrs.push([binding.key, '']);
            this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
          }
        }
        return true;
      }
      return false;
    };
    TemplateParseVisitor.prototype._parseAttr = function(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetAnimationProps, targetEvents, targetRefs, targetVars) {
      var attrName = this._normalizeAttributeName(attr.name);
      var attrValue = attr.value;
      var bindParts = attrName.match(BIND_NAME_REGEXP);
      var hasBinding = false;
      if (bindParts !== null) {
        hasBinding = true;
        if (lang_1.isPresent(bindParts[1])) {
          this._parsePropertyOrAnimation(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
        } else if (lang_1.isPresent(bindParts[2])) {
          var identifier = bindParts[8];
          if (isTemplateElement) {
            this._reportError("\"var-\" on <template> elements is deprecated. Use \"let-\" instead!", attr.sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
            this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
          } else {
            this._reportError("\"var-\" on non <template> elements is deprecated. Use \"ref-\" instead!", attr.sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
            this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
          }
        } else if (lang_1.isPresent(bindParts[3])) {
          if (isTemplateElement) {
            var identifier = bindParts[8];
            this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
          } else {
            this._reportError("\"let-\" is only supported on template elements.", attr.sourceSpan);
          }
        } else if (lang_1.isPresent(bindParts[4])) {
          var identifier = bindParts[8];
          this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
        } else if (lang_1.isPresent(bindParts[5])) {
          this._parseEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (lang_1.isPresent(bindParts[6])) {
          this._parsePropertyOrAnimation(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
          this._parseAssignmentEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (lang_1.isPresent(bindParts[7])) {
          if (attrName[0] == '@' && lang_1.isPresent(attrValue) && attrValue.length > 0) {
            this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is deprecated. Use property bindings (e.g. [@prop]=\"exp\") instead!", attr.sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
          }
          this._parseAnimation(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetAnimationProps);
        } else if (lang_1.isPresent(bindParts[9])) {
          this._parsePropertyOrAnimation(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
          this._parseAssignmentEvent(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        } else if (lang_1.isPresent(bindParts[10])) {
          this._parsePropertyOrAnimation(bindParts[10], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
        } else if (lang_1.isPresent(bindParts[11])) {
          this._parseEvent(bindParts[11], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
        }
      } else {
        hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
      }
      if (!hasBinding) {
        this._parseLiteralAttr(attrName, attrValue, attr.sourceSpan, targetProps);
      }
      return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function(attrName) {
      return attrName.toLowerCase().startsWith('data-') ? attrName.substring(5) : attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function(identifier, value, sourceSpan, targetVars) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in variable names", sourceSpan);
      }
      targetVars.push(new template_ast_1.VariableAst(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseReference = function(identifier, value, sourceSpan, targetRefs) {
      if (identifier.indexOf('-') > -1) {
        this._reportError("\"-\" is not allowed in reference names", sourceSpan);
      }
      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parsePropertyOrAnimation = function(name, expression, sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps) {
      if (name[0] == '@') {
        this._parseAnimation(name.substr(1), expression, sourceSpan, targetMatchableAttrs, targetAnimationProps);
      } else {
        this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
      }
    };
    TemplateParseVisitor.prototype._parseAnimation = function(name, expression, sourceSpan, targetMatchableAttrs, targetAnimationProps) {
      if (!lang_1.isPresent(expression) || expression.length == 0) {
        expression = 'null';
      }
      var ast = this._parseBinding(expression, sourceSpan);
      targetMatchableAttrs.push([name, ast.source]);
      targetAnimationProps.push(new template_ast_1.BoundElementPropertyAst(name, template_ast_1.PropertyBindingType.Animation, core_1.SecurityContext.NONE, ast, null, sourceSpan));
    };
    TemplateParseVisitor.prototype._parsePropertyInterpolation = function(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
      var expr = this._parseInterpolation(value, sourceSpan);
      if (lang_1.isPresent(expr)) {
        this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
        return true;
      }
      return false;
    };
    TemplateParseVisitor.prototype._parsePropertyAst = function(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      this._parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseEvent = function(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
      var parts = util_1.splitAtColon(name, [null, name]);
      var target = parts[0];
      var eventName = parts[1];
      var ast = this._parseAction(expression, sourceSpan);
      targetMatchableAttrs.push([name, ast.source]);
      targetEvents.push(new template_ast_1.BoundEventAst(eventName, target, ast, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseLiteralAttr = function(name, value, sourceSpan, targetProps) {
      targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseDirectives = function(selectorMatcher, elementCssSelector) {
      var _this = this;
      var directives = collection_1.ListWrapper.createFixedSize(this.directivesIndex.size);
      selectorMatcher.match(elementCssSelector, function(selector, directive) {
        directives[_this.directivesIndex.get(directive)] = directive;
      });
      return directives.filter(function(dir) {
        return lang_1.isPresent(dir);
      });
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {
      var _this = this;
      var matchedReferences = new Set();
      var component = null;
      var directiveAsts = directives.map(function(directive) {
        var sourceSpan = new parse_util_1.ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + directive.type.name);
        if (directive.isComponent) {
          component = directive;
        }
        var hostProperties = [];
        var hostEvents = [];
        var directiveProperties = [];
        _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
        _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
        _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
        elementOrDirectiveRefs.forEach(function(elOrDirRef) {
          if ((elOrDirRef.value.length === 0 && directive.isComponent) || (directive.exportAs == elOrDirRef.value)) {
            targetReferences.push(new template_ast_1.ReferenceAst(elOrDirRef.name, identifiers_1.identifierToken(directive.type), elOrDirRef.sourceSpan));
            matchedReferences.add(elOrDirRef.name);
          }
        });
        return new template_ast_1.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
      });
      elementOrDirectiveRefs.forEach(function(elOrDirRef) {
        if (elOrDirRef.value.length > 0) {
          if (!collection_1.SetWrapper.has(matchedReferences, elOrDirRef.name)) {
            _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
          }
        } else if (lang_1.isBlank(component)) {
          var refToken = null;
          if (isTemplateElement) {
            refToken = identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef);
          }
          targetReferences.push(new template_ast_1.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
        }
      });
      return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function(elementName, hostProps, sourceSpan, targetPropertyAsts) {
      var _this = this;
      if (lang_1.isPresent(hostProps)) {
        collection_1.StringMapWrapper.forEach(hostProps, function(expression, propName) {
          var exprAst = _this._parseBinding(expression, sourceSpan);
          targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
        });
      }
    };
    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function(hostListeners, sourceSpan, targetEventAsts) {
      var _this = this;
      if (lang_1.isPresent(hostListeners)) {
        collection_1.StringMapWrapper.forEach(hostListeners, function(expression, propName) {
          _this._parseEvent(propName, expression, sourceSpan, [], targetEventAsts);
        });
      }
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function(directiveProperties, boundProps, targetBoundDirectiveProps) {
      if (lang_1.isPresent(directiveProperties)) {
        var boundPropsByName_1 = new Map();
        boundProps.forEach(function(boundProp) {
          var prevValue = boundPropsByName_1.get(boundProp.name);
          if (lang_1.isBlank(prevValue) || prevValue.isLiteral) {
            boundPropsByName_1.set(boundProp.name, boundProp);
          }
        });
        collection_1.StringMapWrapper.forEach(directiveProperties, function(elProp, dirProp) {
          var boundProp = boundPropsByName_1.get(elProp);
          if (lang_1.isPresent(boundProp)) {
            targetBoundDirectiveProps.push(new template_ast_1.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
          }
        });
      }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function(elementName, props, directives) {
      var _this = this;
      var boundElementProps = [];
      var boundDirectivePropsIndex = new Map();
      directives.forEach(function(directive) {
        directive.inputs.forEach(function(prop) {
          boundDirectivePropsIndex.set(prop.templateName, prop);
        });
      });
      props.forEach(function(prop) {
        if (!prop.isLiteral && lang_1.isBlank(boundDirectivePropsIndex.get(prop.name))) {
          boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
        }
      });
      return boundElementProps;
    };
    TemplateParseVisitor.prototype._createElementPropertyAst = function(elementName, name, ast, sourceSpan) {
      var unit = null;
      var bindingType;
      var boundPropertyName;
      var parts = name.split(PROPERTY_PARTS_SEPARATOR);
      var securityContext;
      if (parts.length === 1) {
        var partValue = parts[0];
        if (partValue[0] == '@') {
          boundPropertyName = partValue.substr(1);
          bindingType = template_ast_1.PropertyBindingType.Animation;
          securityContext = core_1.SecurityContext.NONE;
          if (boundPropertyName[0] == '@') {
            this._reportError("Assigning animation triggers within host data as attributes such as \"@prop\": \"exp\" is deprecated. Use host bindings (e.g. \"[@prop]\": \"exp\") instead!", sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
            boundPropertyName = boundPropertyName.substr(1);
          }
        } else {
          boundPropertyName = this._schemaRegistry.getMappedPropName(partValue);
          securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
          bindingType = template_ast_1.PropertyBindingType.Property;
          if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName, this._schemas)) {
            var errorMsg = "Can't bind to '" + boundPropertyName + "' since it isn't a known property of '" + elementName + "'.";
            if (elementName.indexOf('-') !== -1) {
              errorMsg += ("\n1. If '" + elementName + "' is an Angular component and it has '" + boundPropertyName + "' input, then verify that it is part of this module.") + ("\n2. If '" + elementName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schema' of this component to suppress this message.\n");
            }
            this._reportError(errorMsg, sourceSpan);
          }
        }
      } else {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts[1];
          if (boundPropertyName.toLowerCase().startsWith('on')) {
            this._reportError(("Binding to event attribute '" + boundPropertyName + "' is disallowed ") + ("for security reasons, please use (" + boundPropertyName.slice(2) + ")=..."), sourceSpan);
          }
          securityContext = this._schemaRegistry.securityContext(elementName, this._schemaRegistry.getMappedPropName(boundPropertyName));
          var nsSeparatorIdx = boundPropertyName.indexOf(':');
          if (nsSeparatorIdx > -1) {
            var ns = boundPropertyName.substring(0, nsSeparatorIdx);
            var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = tags_1.mergeNsAndName(ns, name_1);
          }
          bindingType = template_ast_1.PropertyBindingType.Attribute;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = template_ast_1.PropertyBindingType.Class;
          securityContext = core_1.SecurityContext.NONE;
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = template_ast_1.PropertyBindingType.Style;
          securityContext = core_1.SecurityContext.STYLE;
        } else {
          this._reportError("Invalid property name '" + name + "'", sourceSpan);
          bindingType = null;
          securityContext = null;
        }
      }
      return new template_ast_1.BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function(directives) {
      var componentTypeNames = [];
      directives.forEach(function(directive) {
        var typeName = directive.directive.type.name;
        if (directive.directive.isComponent) {
          componentTypeNames.push(typeName);
        }
      });
      return componentTypeNames;
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function(directives, sourceSpan) {
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 1) {
        this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
      }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function(directives, elementProps, sourceSpan) {
      var _this = this;
      var componentTypeNames = this._findComponentDirectiveNames(directives);
      if (componentTypeNames.length > 0) {
        this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
      }
      elementProps.forEach(function(prop) {
        _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"directives\" section.", sourceSpan);
      });
    };
    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function(directives, events) {
      var _this = this;
      var allDirectiveEvents = new Set();
      directives.forEach(function(directive) {
        collection_1.StringMapWrapper.forEach(directive.directive.outputs, function(eventName) {
          allDirectiveEvents.add(eventName);
        });
      });
      events.forEach(function(event) {
        if (lang_1.isPresent(event.target) || !collection_1.SetWrapper.has(allDirectiveEvents, event.name)) {
          _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"directives\" section.", event.sourceSpan);
        }
      });
    };
    return TemplateParseVisitor;
  }());
  var NonBindableVisitor = (function() {
    function NonBindableVisitor() {}
    NonBindableVisitor.prototype.visitElement = function(ast, parent) {
      var preparsedElement = template_preparser_1.preparseElement(ast);
      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
        return null;
      }
      var attrNameAndValues = ast.attrs.map(function(attrAst) {
        return [attrAst.name, attrAst.value];
      });
      var selector = createElementCssSelector(ast.name, attrNameAndValues);
      var ngContentIndex = parent.findNgContentIndex(selector);
      var children = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
      return new template_ast_1.ElementAst(ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitComment = function(comment, context) {
      return null;
    };
    NonBindableVisitor.prototype.visitAttribute = function(attribute, context) {
      return new template_ast_1.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
    };
    NonBindableVisitor.prototype.visitText = function(text, parent) {
      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
      return new template_ast_1.TextAst(text.value, ngContentIndex, text.sourceSpan);
    };
    NonBindableVisitor.prototype.visitExpansion = function(expansion, context) {
      return expansion;
    };
    NonBindableVisitor.prototype.visitExpansionCase = function(expansionCase, context) {
      return expansionCase;
    };
    return NonBindableVisitor;
  }());
  var BoundElementOrDirectiveProperty = (function() {
    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
      this.name = name;
      this.expression = expression;
      this.isLiteral = isLiteral;
      this.sourceSpan = sourceSpan;
    }
    return BoundElementOrDirectiveProperty;
  }());
  var ElementOrDirectiveRef = (function() {
    function ElementOrDirectiveRef(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    return ElementOrDirectiveRef;
  }());
  function splitClasses(classAttrValue) {
    return classAttrValue.trim().split(/\s+/g);
  }
  exports.splitClasses = splitClasses;
  var ElementContext = (function() {
    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
      this.isTemplateElement = isTemplateElement;
      this._ngContentIndexMatcher = _ngContentIndexMatcher;
      this._wildcardNgContentIndex = _wildcardNgContentIndex;
      this.providerContext = providerContext;
    }
    ElementContext.create = function(isTemplateElement, directives, providerContext) {
      var matcher = new selector_1.SelectorMatcher();
      var wildcardNgContentIndex = null;
      var component = directives.find(function(directive) {
        return directive.directive.isComponent;
      });
      if (lang_1.isPresent(component)) {
        var ngContentSelectors = component.directive.template.ngContentSelectors;
        for (var i = 0; i < ngContentSelectors.length; i++) {
          var selector = ngContentSelectors[i];
          if (selector === '*') {
            wildcardNgContentIndex = i;
          } else {
            matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);
          }
        }
      }
      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
    };
    ElementContext.prototype.findNgContentIndex = function(selector) {
      var ngContentIndices = [];
      this._ngContentIndexMatcher.match(selector, function(selector, ngContentIndex) {
        ngContentIndices.push(ngContentIndex);
      });
      collection_1.ListWrapper.sort(ngContentIndices);
      if (lang_1.isPresent(this._wildcardNgContentIndex)) {
        ngContentIndices.push(this._wildcardNgContentIndex);
      }
      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return ElementContext;
  }());
  function createElementCssSelector(elementName, matchableAttrs) {
    var cssSelector = new selector_1.CssSelector();
    var elNameNoNs = tags_1.splitNsName(elementName)[1];
    cssSelector.setElement(elNameNoNs);
    for (var i = 0; i < matchableAttrs.length; i++) {
      var attrName = matchableAttrs[i][0];
      var attrNameNoNs = tags_1.splitNsName(attrName)[1];
      var attrValue = matchableAttrs[i][1];
      cssSelector.addAttribute(attrNameNoNs, attrValue);
      if (attrName.toLowerCase() == CLASS_ATTR) {
        var classes = splitClasses(attrValue);
        classes.forEach(function(className) {
          return cssSelector.addClassName(className);
        });
      }
    }
    return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new selector_1.SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  var PipeCollector = (function(_super) {
    __extends(PipeCollector, _super);
    function PipeCollector() {
      _super.apply(this, arguments);
      this.pipes = new Set();
    }
    PipeCollector.prototype.visitPipe = function(ast, context) {
      this.pipes.add(ast.name);
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    return PipeCollector;
  }(ast_1.RecursiveAstVisitor));
  exports.PipeCollector = PipeCollector;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/config.js", ["@angular/core", "../src/facade/exceptions", "./identifiers"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var exceptions_1 = $__require('../src/facade/exceptions');
  var identifiers_1 = $__require('./identifiers');
  var CompilerConfig = (function() {
    function CompilerConfig(_a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.renderTypes,
          renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c,
          _d = _b.defaultEncapsulation,
          defaultEncapsulation = _d === void 0 ? core_1.ViewEncapsulation.Emulated : _d,
          genDebugInfo = _b.genDebugInfo,
          logBindingUpdate = _b.logBindingUpdate,
          _e = _b.useJit,
          useJit = _e === void 0 ? true : _e,
          _f = _b.deprecatedPlatformDirectives,
          deprecatedPlatformDirectives = _f === void 0 ? [] : _f,
          _g = _b.deprecatedPlatformPipes,
          deprecatedPlatformPipes = _g === void 0 ? [] : _g;
      this.renderTypes = renderTypes;
      this.defaultEncapsulation = defaultEncapsulation;
      this._genDebugInfo = genDebugInfo;
      this._logBindingUpdate = logBindingUpdate;
      this.useJit = useJit;
      this.platformDirectives = deprecatedPlatformDirectives;
      this.platformPipes = deprecatedPlatformPipes;
    }
    Object.defineProperty(CompilerConfig.prototype, "genDebugInfo", {
      get: function() {
        return this._genDebugInfo === void 0 ? core_1.isDevMode() : this._genDebugInfo;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompilerConfig.prototype, "logBindingUpdate", {
      get: function() {
        return this._logBindingUpdate === void 0 ? core_1.isDevMode() : this._logBindingUpdate;
      },
      enumerable: true,
      configurable: true
    });
    return CompilerConfig;
  }());
  exports.CompilerConfig = CompilerConfig;
  var RenderTypes = (function() {
    function RenderTypes() {}
    Object.defineProperty(RenderTypes.prototype, "renderer", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderText", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderElement", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderComment", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderNode", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderEvent", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return RenderTypes;
  }());
  exports.RenderTypes = RenderTypes;
  var DefaultRenderTypes = (function() {
    function DefaultRenderTypes() {
      this.renderer = identifiers_1.Identifiers.Renderer;
      this.renderText = null;
      this.renderElement = null;
      this.renderComment = null;
      this.renderNode = null;
      this.renderEvent = null;
    }
    return DefaultRenderTypes;
  }());
  exports.DefaultRenderTypes = DefaultRenderTypes;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/event_binder.js", ["../facade/collection", "../facade/lang", "../identifiers", "../output/output_ast", "./compile_binding", "./compile_method", "./constants", "./expression_converter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var compile_binding_1 = $__require('./compile_binding');
  var compile_method_1 = $__require('./compile_method');
  var constants_1 = $__require('./constants');
  var expression_converter_1 = $__require('./expression_converter');
  var CompileEventListener = (function() {
    function CompileEventListener(compileElement, eventTarget, eventName, listenerIndex) {
      this.compileElement = compileElement;
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this._hasComponentHostListener = false;
      this._actionResultExprs = [];
      this._method = new compile_method_1.CompileMethod(compileElement.view);
      this._methodName = "_handle_" + santitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
      this._eventParam = new o.FnParam(constants_1.EventHandlerVars.event.name, o.importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
    }
    CompileEventListener.getOrCreate = function(compileElement, eventTarget, eventName, targetEventListeners) {
      var listener = targetEventListeners.find(function(listener) {
        return listener.eventTarget == eventTarget && listener.eventName == eventName;
      });
      if (lang_1.isBlank(listener)) {
        listener = new CompileEventListener(compileElement, eventTarget, eventName, targetEventListeners.length);
        targetEventListeners.push(listener);
      }
      return listener;
    };
    CompileEventListener.prototype.addAction = function(hostEvent, directive, directiveInstance) {
      if (lang_1.isPresent(directive) && directive.isComponent) {
        this._hasComponentHostListener = true;
      }
      this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
      var context = lang_1.isPresent(directiveInstance) ? directiveInstance : this.compileElement.view.componentContext;
      var actionStmts = expression_converter_1.convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler);
      var lastIndex = actionStmts.length - 1;
      if (lastIndex >= 0) {
        var lastStatement = actionStmts[lastIndex];
        var returnExpr = convertStmtIntoExpression(lastStatement);
        var preventDefaultVar = o.variable("pd_" + this._actionResultExprs.length);
        this._actionResultExprs.push(preventDefaultVar);
        if (lang_1.isPresent(returnExpr)) {
          actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false))).toDeclStmt(null, [o.StmtModifier.Final]);
        }
      }
      this._method.addStmts(actionStmts);
    };
    CompileEventListener.prototype.finishMethod = function() {
      var markPathToRootStart = this._hasComponentHostListener ? this.compileElement.appElement.prop('componentView') : o.THIS_EXPR;
      var resultExpr = o.literal(true);
      this._actionResultExprs.forEach(function(expr) {
        resultExpr = resultExpr.and(expr);
      });
      var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()].concat(this._method.finish()).concat([new o.ReturnStatement(resultExpr)]);
      this.compileElement.view.eventHandlerMethods.push(new o.ClassMethod(this._methodName, [this._eventParam], stmts, o.BOOL_TYPE, [o.StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToRenderer = function() {
      var listenExpr;
      var eventListener = o.THIS_EXPR.callMethod('eventHandler', [o.THIS_EXPR.prop(this._methodName).callMethod(o.BuiltinMethod.bind, [o.THIS_EXPR])]);
      if (lang_1.isPresent(this.eventTarget)) {
        listenExpr = constants_1.ViewProperties.renderer.callMethod('listenGlobal', [o.literal(this.eventTarget), o.literal(this.eventName), eventListener]);
      } else {
        listenExpr = constants_1.ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, o.literal(this.eventName), eventListener]);
      }
      var disposable = o.variable("disposable_" + this.compileElement.view.disposables.length);
      this.compileElement.view.disposables.push(disposable);
      this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(o.FUNCTION_TYPE, [o.StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToDirective = function(directiveInstance, observablePropName) {
      var subscription = o.variable("subscription_" + this.compileElement.view.subscriptions.length);
      this.compileElement.view.subscriptions.push(subscription);
      var eventListener = o.THIS_EXPR.callMethod('eventHandler', [o.THIS_EXPR.prop(this._methodName).callMethod(o.BuiltinMethod.bind, [o.THIS_EXPR])]);
      this.compileElement.view.createMethod.addStmt(subscription.set(directiveInstance.prop(observablePropName).callMethod(o.BuiltinMethod.SubscribeObservable, [eventListener])).toDeclStmt(null, [o.StmtModifier.Final]));
    };
    return CompileEventListener;
  }());
  exports.CompileEventListener = CompileEventListener;
  function collectEventListeners(hostEvents, dirs, compileElement) {
    var eventListeners = [];
    hostEvents.forEach(function(hostEvent) {
      compileElement.view.bindings.push(new compile_binding_1.CompileBinding(compileElement, hostEvent));
      var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
      listener.addAction(hostEvent, null, null);
    });
    dirs.forEach(function(directiveAst) {
      var directiveInstance = compileElement.instances.get(identifiers_1.identifierToken(directiveAst.directive.type));
      directiveAst.hostEvents.forEach(function(hostEvent) {
        compileElement.view.bindings.push(new compile_binding_1.CompileBinding(compileElement, hostEvent));
        var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
        listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
      });
    });
    eventListeners.forEach(function(listener) {
      return listener.finishMethod();
    });
    return eventListeners;
  }
  exports.collectEventListeners = collectEventListeners;
  function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
    collection_1.StringMapWrapper.forEach(directiveAst.directive.outputs, function(eventName, observablePropName) {
      eventListeners.filter(function(listener) {
        return listener.eventName == eventName;
      }).forEach(function(listener) {
        listener.listenToDirective(directiveInstance, observablePropName);
      });
    });
  }
  exports.bindDirectiveOutputs = bindDirectiveOutputs;
  function bindRenderOutputs(eventListeners) {
    eventListeners.forEach(function(listener) {
      return listener.listenToRenderer();
    });
  }
  exports.bindRenderOutputs = bindRenderOutputs;
  function convertStmtIntoExpression(stmt) {
    if (stmt instanceof o.ExpressionStatement) {
      return stmt.expr;
    } else if (stmt instanceof o.ReturnStatement) {
      return stmt.value;
    }
    return null;
  }
  function santitizeEventName(name) {
    return lang_1.StringWrapper.replaceAll(name, /[^a-zA-Z_]/g, '_');
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/lifecycle_binder.js", ["../../core_private", "../output/output_ast", "./constants"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_private_1 = $__require('../../core_private');
  var o = $__require('../output/output_ast');
  var constants_1 = $__require('./constants');
  var STATE_IS_NEVER_CHECKED = o.THIS_EXPR.prop('numberOfChecks').identical(new o.LiteralExpr(0));
  var NOT_THROW_ON_CHANGES = o.not(constants_1.DetectChangesVars.throwOnChange);
  function bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement) {
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    var lifecycleHooks = directiveAst.directive.type.lifecycleHooks;
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnChanges) !== -1 && directiveAst.inputs.length > 0) {
      detectChangesInInputsMethod.addStmt(new o.IfStmt(constants_1.DetectChangesVars.changes.notIdentical(o.NULL_EXPR), [directiveInstance.callMethod('ngOnChanges', [constants_1.DetectChangesVars.changes]).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnInit) !== -1) {
      detectChangesInInputsMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED.and(NOT_THROW_ON_CHANGES), [directiveInstance.callMethod('ngOnInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.DoCheck) !== -1) {
      detectChangesInInputsMethod.addStmt(new o.IfStmt(NOT_THROW_ON_CHANGES, [directiveInstance.callMethod('ngDoCheck', []).toStmt()]));
    }
  }
  exports.bindDirectiveDetectChangesLifecycleCallbacks = bindDirectiveDetectChangesLifecycleCallbacks;
  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.type.lifecycleHooks;
    var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
    afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterContentInit) !== -1) {
      afterContentLifecycleCallbacksMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterContentChecked) !== -1) {
      afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
    }
  }
  exports.bindDirectiveAfterContentLifecycleCallbacks = bindDirectiveAfterContentLifecycleCallbacks;
  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.type.lifecycleHooks;
    var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
    afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterViewInit) !== -1) {
      afterViewLifecycleCallbacksMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterViewChecked) !== -1) {
      afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
    }
  }
  exports.bindDirectiveAfterViewLifecycleCallbacks = bindDirectiveAfterViewLifecycleCallbacks;
  function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {
    var onDestroyMethod = compileElement.view.destroyMethod;
    onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (provider.lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnDestroy) !== -1) {
      onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());
    }
  }
  exports.bindInjectableDestroyLifecycleCallbacks = bindInjectableDestroyLifecycleCallbacks;
  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
    var onDestroyMethod = view.destroyMethod;
    if (pipeMeta.type.lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnDestroy) !== -1) {
      onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
    }
  }
  exports.bindPipeDestroyLifecycleCallbacks = bindPipeDestroyLifecycleCallbacks;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_binding.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var CompileBinding = (function() {
    function CompileBinding(node, sourceAst) {
      this.node = node;
      this.sourceAst = sourceAst;
    }
    return CompileBinding;
  }());
  exports.CompileBinding = CompileBinding;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/expression_parser/ast.js", ["../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var ParserError = (function() {
    function ParserError(message, input, errLocation, ctxLocation) {
      this.input = input;
      this.errLocation = errLocation;
      this.ctxLocation = ctxLocation;
      this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
    }
    return ParserError;
  }());
  exports.ParserError = ParserError;
  var ParseSpan = (function() {
    function ParseSpan(start, end) {
      this.start = start;
      this.end = end;
    }
    return ParseSpan;
  }());
  exports.ParseSpan = ParseSpan;
  var AST = (function() {
    function AST(span) {
      this.span = span;
    }
    AST.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return null;
    };
    AST.prototype.toString = function() {
      return 'AST';
    };
    return AST;
  }());
  exports.AST = AST;
  var Quote = (function(_super) {
    __extends(Quote, _super);
    function Quote(span, prefix, uninterpretedExpression, location) {
      _super.call(this, span);
      this.prefix = prefix;
      this.uninterpretedExpression = uninterpretedExpression;
      this.location = location;
    }
    Quote.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitQuote(this, context);
    };
    Quote.prototype.toString = function() {
      return 'Quote';
    };
    return Quote;
  }(AST));
  exports.Quote = Quote;
  var EmptyExpr = (function(_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
      _super.apply(this, arguments);
    }
    EmptyExpr.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
    };
    return EmptyExpr;
  }(AST));
  exports.EmptyExpr = EmptyExpr;
  var ImplicitReceiver = (function(_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
      _super.apply(this, arguments);
    }
    ImplicitReceiver.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitImplicitReceiver(this, context);
    };
    return ImplicitReceiver;
  }(AST));
  exports.ImplicitReceiver = ImplicitReceiver;
  var Chain = (function(_super) {
    __extends(Chain, _super);
    function Chain(span, expressions) {
      _super.call(this, span);
      this.expressions = expressions;
    }
    Chain.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitChain(this, context);
    };
    return Chain;
  }(AST));
  exports.Chain = Chain;
  var Conditional = (function(_super) {
    __extends(Conditional, _super);
    function Conditional(span, condition, trueExp, falseExp) {
      _super.call(this, span);
      this.condition = condition;
      this.trueExp = trueExp;
      this.falseExp = falseExp;
    }
    Conditional.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitConditional(this, context);
    };
    return Conditional;
  }(AST));
  exports.Conditional = Conditional;
  var PropertyRead = (function(_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(span, receiver, name) {
      _super.call(this, span);
      this.receiver = receiver;
      this.name = name;
    }
    PropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyRead(this, context);
    };
    return PropertyRead;
  }(AST));
  exports.PropertyRead = PropertyRead;
  var PropertyWrite = (function(_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(span, receiver, name, value) {
      _super.call(this, span);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    PropertyWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPropertyWrite(this, context);
    };
    return PropertyWrite;
  }(AST));
  exports.PropertyWrite = PropertyWrite;
  var SafePropertyRead = (function(_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(span, receiver, name) {
      _super.call(this, span);
      this.receiver = receiver;
      this.name = name;
    }
    SafePropertyRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafePropertyRead(this, context);
    };
    return SafePropertyRead;
  }(AST));
  exports.SafePropertyRead = SafePropertyRead;
  var KeyedRead = (function(_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(span, obj, key) {
      _super.call(this, span);
      this.obj = obj;
      this.key = key;
    }
    KeyedRead.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedRead(this, context);
    };
    return KeyedRead;
  }(AST));
  exports.KeyedRead = KeyedRead;
  var KeyedWrite = (function(_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(span, obj, key, value) {
      _super.call(this, span);
      this.obj = obj;
      this.key = key;
      this.value = value;
    }
    KeyedWrite.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitKeyedWrite(this, context);
    };
    return KeyedWrite;
  }(AST));
  exports.KeyedWrite = KeyedWrite;
  var BindingPipe = (function(_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(span, exp, name, args) {
      _super.call(this, span);
      this.exp = exp;
      this.name = name;
      this.args = args;
    }
    BindingPipe.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPipe(this, context);
    };
    return BindingPipe;
  }(AST));
  exports.BindingPipe = BindingPipe;
  var LiteralPrimitive = (function(_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(span, value) {
      _super.call(this, span);
      this.value = value;
    }
    LiteralPrimitive.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralPrimitive(this, context);
    };
    return LiteralPrimitive;
  }(AST));
  exports.LiteralPrimitive = LiteralPrimitive;
  var LiteralArray = (function(_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(span, expressions) {
      _super.call(this, span);
      this.expressions = expressions;
    }
    LiteralArray.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralArray(this, context);
    };
    return LiteralArray;
  }(AST));
  exports.LiteralArray = LiteralArray;
  var LiteralMap = (function(_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(span, keys, values) {
      _super.call(this, span);
      this.keys = keys;
      this.values = values;
    }
    LiteralMap.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitLiteralMap(this, context);
    };
    return LiteralMap;
  }(AST));
  exports.LiteralMap = LiteralMap;
  var Interpolation = (function(_super) {
    __extends(Interpolation, _super);
    function Interpolation(span, strings, expressions) {
      _super.call(this, span);
      this.strings = strings;
      this.expressions = expressions;
    }
    Interpolation.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitInterpolation(this, context);
    };
    return Interpolation;
  }(AST));
  exports.Interpolation = Interpolation;
  var Binary = (function(_super) {
    __extends(Binary, _super);
    function Binary(span, operation, left, right) {
      _super.call(this, span);
      this.operation = operation;
      this.left = left;
      this.right = right;
    }
    Binary.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitBinary(this, context);
    };
    return Binary;
  }(AST));
  exports.Binary = Binary;
  var PrefixNot = (function(_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(span, expression) {
      _super.call(this, span);
      this.expression = expression;
    }
    PrefixNot.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitPrefixNot(this, context);
    };
    return PrefixNot;
  }(AST));
  exports.PrefixNot = PrefixNot;
  var MethodCall = (function(_super) {
    __extends(MethodCall, _super);
    function MethodCall(span, receiver, name, args) {
      _super.call(this, span);
      this.receiver = receiver;
      this.name = name;
      this.args = args;
    }
    MethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitMethodCall(this, context);
    };
    return MethodCall;
  }(AST));
  exports.MethodCall = MethodCall;
  var SafeMethodCall = (function(_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(span, receiver, name, args) {
      _super.call(this, span);
      this.receiver = receiver;
      this.name = name;
      this.args = args;
    }
    SafeMethodCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitSafeMethodCall(this, context);
    };
    return SafeMethodCall;
  }(AST));
  exports.SafeMethodCall = SafeMethodCall;
  var FunctionCall = (function(_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(span, target, args) {
      _super.call(this, span);
      this.target = target;
      this.args = args;
    }
    FunctionCall.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return visitor.visitFunctionCall(this, context);
    };
    return FunctionCall;
  }(AST));
  exports.FunctionCall = FunctionCall;
  var ASTWithSource = (function(_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location, errors) {
      _super.call(this, new ParseSpan(0, lang_1.isBlank(source) ? 0 : source.length));
      this.ast = ast;
      this.source = source;
      this.location = location;
      this.errors = errors;
    }
    ASTWithSource.prototype.visit = function(visitor, context) {
      if (context === void 0) {
        context = null;
      }
      return this.ast.visit(visitor, context);
    };
    ASTWithSource.prototype.toString = function() {
      return this.source + " in " + this.location;
    };
    return ASTWithSource;
  }(AST));
  exports.ASTWithSource = ASTWithSource;
  var TemplateBinding = (function() {
    function TemplateBinding(key, keyIsVar, name, expression) {
      this.key = key;
      this.keyIsVar = keyIsVar;
      this.name = name;
      this.expression = expression;
    }
    return TemplateBinding;
  }());
  exports.TemplateBinding = TemplateBinding;
  var RecursiveAstVisitor = (function() {
    function RecursiveAstVisitor() {}
    RecursiveAstVisitor.prototype.visitBinary = function(ast, context) {
      ast.left.visit(this);
      ast.right.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitConditional = function(ast, context) {
      ast.condition.visit(this);
      ast.trueExp.visit(this);
      ast.falseExp.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function(ast, context) {
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function(ast, context) {
      ast.target.visit(this);
      this.visitAll(ast.args, context);
      return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitInterpolation = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitKeyedRead = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function(ast, context) {
      ast.obj.visit(this);
      ast.key.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function(ast, context) {
      return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralMap = function(ast, context) {
      return this.visitAll(ast.values, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function(ast, context) {
      return null;
    };
    RecursiveAstVisitor.prototype.visitMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function(ast, context) {
      ast.expression.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function(ast, context) {
      ast.receiver.visit(this);
      ast.value.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function(ast, context) {
      ast.receiver.visit(this);
      return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function(ast, context) {
      ast.receiver.visit(this);
      return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitAll = function(asts, context) {
      var _this = this;
      asts.forEach(function(ast) {
        return ast.visit(_this, context);
      });
      return null;
    };
    RecursiveAstVisitor.prototype.visitQuote = function(ast, context) {
      return null;
    };
    return RecursiveAstVisitor;
  }());
  exports.RecursiveAstVisitor = RecursiveAstVisitor;
  var AstTransformer = (function() {
    function AstTransformer() {}
    AstTransformer.prototype.visitImplicitReceiver = function(ast, context) {
      return ast;
    };
    AstTransformer.prototype.visitInterpolation = function(ast, context) {
      return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralPrimitive = function(ast, context) {
      return new LiteralPrimitive(ast.span, ast.value);
    };
    AstTransformer.prototype.visitPropertyRead = function(ast, context) {
      return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitPropertyWrite = function(ast, context) {
      return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value);
    };
    AstTransformer.prototype.visitSafePropertyRead = function(ast, context) {
      return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitMethodCall = function(ast, context) {
      return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitSafeMethodCall = function(ast, context) {
      return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitFunctionCall = function(ast, context) {
      return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitLiteralArray = function(ast, context) {
      return new LiteralArray(ast.span, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralMap = function(ast, context) {
      return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));
    };
    AstTransformer.prototype.visitBinary = function(ast, context) {
      return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));
    };
    AstTransformer.prototype.visitPrefixNot = function(ast, context) {
      return new PrefixNot(ast.span, ast.expression.visit(this));
    };
    AstTransformer.prototype.visitConditional = function(ast, context) {
      return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    };
    AstTransformer.prototype.visitPipe = function(ast, context) {
      return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitKeyedRead = function(ast, context) {
      return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));
    };
    AstTransformer.prototype.visitKeyedWrite = function(ast, context) {
      return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
    };
    AstTransformer.prototype.visitAll = function(asts) {
      var res = collection_1.ListWrapper.createFixedSize(asts.length);
      for (var i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }
      return res;
    };
    AstTransformer.prototype.visitChain = function(ast, context) {
      return new Chain(ast.span, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitQuote = function(ast, context) {
      return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);
    };
    return AstTransformer;
  }());
  exports.AstTransformer = AstTransformer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/expression_converter.js", ["../expression_parser/ast", "../facade/exceptions", "../facade/lang", "../identifiers", "../output/output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var cdAst = $__require('../expression_parser/ast');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var ExpressionWithWrappedValueInfo = (function() {
    function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper) {
      this.expression = expression;
      this.needsValueUnwrapper = needsValueUnwrapper;
    }
    return ExpressionWithWrappedValueInfo;
  }());
  exports.ExpressionWithWrappedValueInfo = ExpressionWithWrappedValueInfo;
  function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper);
    var irAst = expression.visit(visitor, _Mode.Expression);
    return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper);
  }
  exports.convertCdExpressionToIr = convertCdExpressionToIr;
  function convertCdStatementToIr(nameResolver, implicitReceiver, stmt) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null);
    var statements = [];
    flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
    return statements;
  }
  exports.convertCdStatementToIr = convertCdStatementToIr;
  var _Mode;
  (function(_Mode) {
    _Mode[_Mode["Statement"] = 0] = "Statement";
    _Mode[_Mode["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
      throw new exceptions_1.BaseException("Expected a statement, but saw " + ast);
    }
  }
  function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
      throw new exceptions_1.BaseException("Expected an expression, but saw " + ast);
    }
  }
  function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
      return expr.toStmt();
    } else {
      return expr;
    }
  }
  var _AstToIrVisitor = (function() {
    function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper) {
      this._nameResolver = _nameResolver;
      this._implicitReceiver = _implicitReceiver;
      this._valueUnwrapper = _valueUnwrapper;
      this._map = new Map();
      this.needsValueUnwrapper = false;
    }
    _AstToIrVisitor.prototype.visitBinary = function(ast, mode) {
      var op;
      switch (ast.operation) {
        case '+':
          op = o.BinaryOperator.Plus;
          break;
        case '-':
          op = o.BinaryOperator.Minus;
          break;
        case '*':
          op = o.BinaryOperator.Multiply;
          break;
        case '/':
          op = o.BinaryOperator.Divide;
          break;
        case '%':
          op = o.BinaryOperator.Modulo;
          break;
        case '&&':
          op = o.BinaryOperator.And;
          break;
        case '||':
          op = o.BinaryOperator.Or;
          break;
        case '==':
          op = o.BinaryOperator.Equals;
          break;
        case '!=':
          op = o.BinaryOperator.NotEquals;
          break;
        case '===':
          op = o.BinaryOperator.Identical;
          break;
        case '!==':
          op = o.BinaryOperator.NotIdentical;
          break;
        case '<':
          op = o.BinaryOperator.Lower;
          break;
        case '>':
          op = o.BinaryOperator.Bigger;
          break;
        case '<=':
          op = o.BinaryOperator.LowerEquals;
          break;
        case '>=':
          op = o.BinaryOperator.BiggerEquals;
          break;
        default:
          throw new exceptions_1.BaseException("Unsupported operation " + ast.operation);
      }
      return convertToStatementIfNeeded(mode, new o.BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitChain = function(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    };
    _AstToIrVisitor.prototype.visitConditional = function(ast, mode) {
      var value = this.visit(ast.condition, _Mode.Expression);
      return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPipe = function(ast, mode) {
      var input = this.visit(ast.exp, _Mode.Expression);
      var args = this.visitAll(ast.args, _Mode.Expression);
      var value = this._nameResolver.callPipe(ast.name, input, args);
      this.needsValueUnwrapper = true;
      return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
    };
    _AstToIrVisitor.prototype.visitFunctionCall = function(ast, mode) {
      return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitImplicitReceiver = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      return this._implicitReceiver;
    };
    _AstToIrVisitor.prototype.visitInterpolation = function(ast, mode) {
      ensureExpressionMode(mode, ast);
      var args = [o.literal(ast.expressions.length)];
      for (var i = 0; i < ast.strings.length - 1; i++) {
        args.push(o.literal(ast.strings[i]));
        args.push(this.visit(ast.expressions[i], _Mode.Expression));
      }
      args.push(o.literal(ast.strings[ast.strings.length - 1]));
      return o.importExpr(identifiers_1.Identifiers.interpolate).callFn(args);
    };
    _AstToIrVisitor.prototype.visitKeyedRead = function(ast, mode) {
      return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitKeyedWrite = function(ast, mode) {
      var obj = this.visit(ast.obj, _Mode.Expression);
      var key = this.visit(ast.key, _Mode.Expression);
      var value = this.visit(ast.value, _Mode.Expression);
      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    };
    _AstToIrVisitor.prototype.visitLiteralArray = function(ast, mode) {
      return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
    };
    _AstToIrVisitor.prototype.visitLiteralMap = function(ast, mode) {
      var parts = [];
      for (var i = 0; i < ast.keys.length; i++) {
        parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);
      }
      return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
    };
    _AstToIrVisitor.prototype.visitLiteralPrimitive = function(ast, mode) {
      return convertToStatementIfNeeded(mode, o.literal(ast.value));
    };
    _AstToIrVisitor.prototype.visitMethodCall = function(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        var args = this.visitAll(ast.args, _Mode.Expression);
        var result = null;
        var receiver = this.visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          var varExpr = this._nameResolver.getLocal(ast.name);
          if (lang_1.isPresent(varExpr)) {
            result = varExpr.callFn(args);
          }
        }
        if (lang_1.isBlank(result)) {
          result = receiver.callMethod(ast.name, args);
        }
        return convertToStatementIfNeeded(mode, result);
      }
    };
    _AstToIrVisitor.prototype.visitPrefixNot = function(ast, mode) {
      return convertToStatementIfNeeded(mode, o.not(this.visit(ast.expression, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPropertyRead = function(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        var result = null;
        var receiver = this.visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          result = this._nameResolver.getLocal(ast.name);
        }
        if (lang_1.isBlank(result)) {
          result = receiver.prop(ast.name);
        }
        return convertToStatementIfNeeded(mode, result);
      }
    };
    _AstToIrVisitor.prototype.visitPropertyWrite = function(ast, mode) {
      var receiver = this.visit(ast.receiver, _Mode.Expression);
      if (receiver === this._implicitReceiver) {
        var varExpr = this._nameResolver.getLocal(ast.name);
        if (lang_1.isPresent(varExpr)) {
          throw new exceptions_1.BaseException('Cannot assign to a reference or variable!');
        }
      }
      return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitSafePropertyRead = function(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    };
    _AstToIrVisitor.prototype.visitSafeMethodCall = function(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    };
    _AstToIrVisitor.prototype.visitAll = function(asts, mode) {
      var _this = this;
      return asts.map(function(ast) {
        return _this.visit(ast, mode);
      });
    };
    _AstToIrVisitor.prototype.visitQuote = function(ast, mode) {
      throw new exceptions_1.BaseException('Quotes are not supported for evaluation!');
    };
    _AstToIrVisitor.prototype.visit = function(ast, mode) {
      return (this._map.get(ast) || ast).visit(this, mode);
    };
    _AstToIrVisitor.prototype.convertSafeAccess = function(ast, leftMostSafe, mode) {
      var condition = this.visit(leftMostSafe.receiver, mode).isBlank();
      if (leftMostSafe instanceof cdAst.SafeMethodCall) {
        this._map.set(leftMostSafe, new cdAst.MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
      } else {
        this._map.set(leftMostSafe, new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
      }
      var access = this.visit(ast, mode);
      this._map.delete(leftMostSafe);
      return condition.conditional(o.literal(null), access);
    };
    _AstToIrVisitor.prototype.leftMostSafeNode = function(ast) {
      var _this = this;
      var visit = function(visitor, ast) {
        return (_this._map.get(ast) || ast).visit(visitor);
      };
      return ast.visit({
        visitBinary: function(ast) {
          return null;
        },
        visitChain: function(ast) {
          return null;
        },
        visitConditional: function(ast) {
          return null;
        },
        visitFunctionCall: function(ast) {
          return null;
        },
        visitImplicitReceiver: function(ast) {
          return null;
        },
        visitInterpolation: function(ast) {
          return null;
        },
        visitKeyedRead: function(ast) {
          return visit(this, ast.obj);
        },
        visitKeyedWrite: function(ast) {
          return null;
        },
        visitLiteralArray: function(ast) {
          return null;
        },
        visitLiteralMap: function(ast) {
          return null;
        },
        visitLiteralPrimitive: function(ast) {
          return null;
        },
        visitMethodCall: function(ast) {
          return visit(this, ast.receiver);
        },
        visitPipe: function(ast) {
          return null;
        },
        visitPrefixNot: function(ast) {
          return null;
        },
        visitPropertyRead: function(ast) {
          return visit(this, ast.receiver);
        },
        visitPropertyWrite: function(ast) {
          return null;
        },
        visitQuote: function(ast) {
          return null;
        },
        visitSafeMethodCall: function(ast) {
          return visit(this, ast.receiver) || ast;
        },
        visitSafePropertyRead: function(ast) {
          return visit(this, ast.receiver) || ast;
        }
      });
    };
    return _AstToIrVisitor;
  }());
  function flattenStatements(arg, output) {
    if (lang_1.isArray(arg)) {
      arg.forEach(function(entry) {
        return flattenStatements(entry, output);
      });
    } else {
      output.push(arg);
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/property_binder.js", ["@angular/core", "../../core_private", "../facade/lang", "../identifiers", "../output/output_ast", "../template_parser/template_ast", "../util", "./compile_binding", "./constants", "./expression_converter"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../core_private');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var template_ast_1 = $__require('../template_parser/template_ast');
  var util_1 = $__require('../util');
  var compile_binding_1 = $__require('./compile_binding');
  var constants_1 = $__require('./constants');
  var expression_converter_1 = $__require('./expression_converter');
  function createBindFieldExpr(exprIndex) {
    return o.THIS_EXPR.prop("_expr_" + exprIndex);
  }
  function createCurrValueExpr(exprIndex) {
    return o.variable("currVal_" + exprIndex);
  }
  var _animationViewCheckedFlagMap = new Map();
  function bind(view, currValExpr, fieldExpr, parsedExpression, context, actions, method) {
    var checkExpression = expression_converter_1.convertCdExpressionToIr(view, context, parsedExpression, constants_1.DetectChangesVars.valUnwrapper);
    if (lang_1.isBlank(checkExpression.expression)) {
      return;
    }
    view.fields.push(new o.ClassField(fieldExpr.name, null, [o.StmtModifier.Private]));
    view.createMethod.addStmt(o.THIS_EXPR.prop(fieldExpr.name).set(o.importExpr(identifiers_1.Identifiers.UNINITIALIZED)).toStmt());
    if (checkExpression.needsValueUnwrapper) {
      var initValueUnwrapperStmt = constants_1.DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
      method.addStmt(initValueUnwrapperStmt);
    }
    method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [o.StmtModifier.Final]));
    var condition = o.importExpr(identifiers_1.Identifiers.checkBinding).callFn([constants_1.DetectChangesVars.throwOnChange, fieldExpr, currValExpr]);
    if (checkExpression.needsValueUnwrapper) {
      condition = constants_1.DetectChangesVars.valUnwrapper.prop('hasWrappedValue').or(condition);
    }
    method.addStmt(new o.IfStmt(condition, actions.concat([o.THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
  }
  function bindRenderText(boundText, compileNode, view) {
    var bindingIndex = view.bindings.length;
    view.bindings.push(new compile_binding_1.CompileBinding(compileNode, boundText));
    var currValExpr = createCurrValueExpr(bindingIndex);
    var valueField = createBindFieldExpr(bindingIndex);
    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
    bind(view, currValExpr, valueField, boundText.value, view.componentContext, [o.THIS_EXPR.prop('renderer').callMethod('setText', [compileNode.renderNode, currValExpr]).toStmt()], view.detectChangesRenderPropertiesMethod);
  }
  exports.bindRenderText = bindRenderText;
  function bindAndWriteToRenderer(boundProps, context, compileElement, isHostProp) {
    var view = compileElement.view;
    var renderNode = compileElement.renderNode;
    boundProps.forEach(function(boundProp) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new compile_binding_1.CompileBinding(compileElement, boundProp));
      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
      var fieldExpr = createBindFieldExpr(bindingIndex);
      var currValExpr = createCurrValueExpr(bindingIndex);
      var renderMethod;
      var oldRenderValue = sanitizedValue(boundProp, fieldExpr);
      var renderValue = sanitizedValue(boundProp, currValExpr);
      var updateStmts = [];
      switch (boundProp.type) {
        case template_ast_1.PropertyBindingType.Property:
          if (view.genConfig.logBindingUpdate) {
            updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, renderValue));
          }
          updateStmts.push(o.THIS_EXPR.prop('renderer').callMethod('setElementProperty', [renderNode, o.literal(boundProp.name), renderValue]).toStmt());
          break;
        case template_ast_1.PropertyBindingType.Attribute:
          renderValue = renderValue.isBlank().conditional(o.NULL_EXPR, renderValue.callMethod('toString', []));
          updateStmts.push(o.THIS_EXPR.prop('renderer').callMethod('setElementAttribute', [renderNode, o.literal(boundProp.name), renderValue]).toStmt());
          break;
        case template_ast_1.PropertyBindingType.Class:
          updateStmts.push(o.THIS_EXPR.prop('renderer').callMethod('setElementClass', [renderNode, o.literal(boundProp.name), renderValue]).toStmt());
          break;
        case template_ast_1.PropertyBindingType.Style:
          var strValue = renderValue.callMethod('toString', []);
          if (lang_1.isPresent(boundProp.unit)) {
            strValue = strValue.plus(o.literal(boundProp.unit));
          }
          renderValue = renderValue.isBlank().conditional(o.NULL_EXPR, strValue);
          updateStmts.push(o.THIS_EXPR.prop('renderer').callMethod('setElementStyle', [renderNode, o.literal(boundProp.name), renderValue]).toStmt());
          break;
        case template_ast_1.PropertyBindingType.Animation:
          var animationName = boundProp.name;
          var targetViewExpr = o.THIS_EXPR;
          if (isHostProp) {
            targetViewExpr = compileElement.appElement.prop('componentView');
          }
          var animationFnExpr = targetViewExpr.prop('componentType').prop('animations').key(o.literal(animationName));
          var emptyStateValue = o.literal(core_private_1.EMPTY_STATE);
          var oldRenderVar = o.variable('oldRenderVar');
          updateStmts.push(oldRenderVar.set(oldRenderValue).toDeclStmt());
          updateStmts.push(new o.IfStmt(oldRenderVar.equals(o.importExpr(identifiers_1.Identifiers.UNINITIALIZED)), [oldRenderVar.set(emptyStateValue).toStmt()]));
          var newRenderVar = o.variable('newRenderVar');
          updateStmts.push(newRenderVar.set(renderValue).toDeclStmt());
          updateStmts.push(new o.IfStmt(newRenderVar.equals(o.importExpr(identifiers_1.Identifiers.UNINITIALIZED)), [newRenderVar.set(emptyStateValue).toStmt()]));
          updateStmts.push(animationFnExpr.callFn([o.THIS_EXPR, renderNode, oldRenderVar, newRenderVar]).toStmt());
          view.detachMethod.addStmt(animationFnExpr.callFn([o.THIS_EXPR, renderNode, oldRenderValue, emptyStateValue]).toStmt());
          if (!_animationViewCheckedFlagMap.get(view)) {
            _animationViewCheckedFlagMap.set(view, true);
            var triggerStmt = o.THIS_EXPR.callMethod('triggerQueuedAnimations', []).toStmt();
            view.afterViewLifecycleCallbacksMethod.addStmt(triggerStmt);
            view.detachMethod.addStmt(triggerStmt);
          }
          break;
      }
      bind(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, view.detectChangesRenderPropertiesMethod);
    });
  }
  function sanitizedValue(boundProp, renderValue) {
    var enumValue;
    switch (boundProp.securityContext) {
      case core_1.SecurityContext.NONE:
        return renderValue;
      case core_1.SecurityContext.HTML:
        enumValue = 'HTML';
        break;
      case core_1.SecurityContext.STYLE:
        enumValue = 'STYLE';
        break;
      case core_1.SecurityContext.SCRIPT:
        enumValue = 'SCRIPT';
        break;
      case core_1.SecurityContext.URL:
        enumValue = 'URL';
        break;
      case core_1.SecurityContext.RESOURCE_URL:
        enumValue = 'RESOURCE_URL';
        break;
      default:
        throw new Error("internal error, unexpected SecurityContext " + boundProp.securityContext + ".");
    }
    var ctx = constants_1.ViewProperties.viewUtils.prop('sanitizer');
    var args = [o.importExpr(identifiers_1.Identifiers.SecurityContext).prop(enumValue), renderValue];
    return ctx.callMethod('sanitize', args);
  }
  function bindRenderInputs(boundProps, compileElement) {
    bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement, false);
  }
  exports.bindRenderInputs = bindRenderInputs;
  function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement) {
    bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement, true);
  }
  exports.bindDirectiveHostProps = bindDirectiveHostProps;
  function bindDirectiveInputs(directiveAst, directiveInstance, compileElement) {
    if (directiveAst.inputs.length === 0) {
      return;
    }
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    var lifecycleHooks = directiveAst.directive.type.lifecycleHooks;
    var calcChangesMap = lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnChanges) !== -1;
    var isOnPushComp = directiveAst.directive.isComponent && !core_private_1.isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
    if (calcChangesMap) {
      detectChangesInInputsMethod.addStmt(constants_1.DetectChangesVars.changes.set(o.NULL_EXPR).toStmt());
    }
    if (isOnPushComp) {
      detectChangesInInputsMethod.addStmt(constants_1.DetectChangesVars.changed.set(o.literal(false)).toStmt());
    }
    directiveAst.inputs.forEach(function(input) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new compile_binding_1.CompileBinding(compileElement, input));
      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
      var fieldExpr = createBindFieldExpr(bindingIndex);
      var currValExpr = createCurrValueExpr(bindingIndex);
      var statements = [directiveInstance.prop(input.directiveName).set(currValExpr).toStmt()];
      if (calcChangesMap) {
        statements.push(new o.IfStmt(constants_1.DetectChangesVars.changes.identical(o.NULL_EXPR), [constants_1.DetectChangesVars.changes.set(o.literalMap([], new o.MapType(o.importType(identifiers_1.Identifiers.SimpleChange)))).toStmt()]));
        statements.push(constants_1.DetectChangesVars.changes.key(o.literal(input.directiveName)).set(o.importExpr(identifiers_1.Identifiers.SimpleChange).instantiate([fieldExpr, currValExpr])).toStmt());
      }
      if (isOnPushComp) {
        statements.push(constants_1.DetectChangesVars.changed.set(o.literal(true)).toStmt());
      }
      if (view.genConfig.logBindingUpdate) {
        statements.push(logBindingUpdateStmt(compileElement.renderNode, input.directiveName, currValExpr));
      }
      bind(view, currValExpr, fieldExpr, input.value, view.componentContext, statements, detectChangesInInputsMethod);
    });
    if (isOnPushComp) {
      detectChangesInInputsMethod.addStmt(new o.IfStmt(constants_1.DetectChangesVars.changed, [compileElement.appElement.prop('componentView').callMethod('markAsCheckOnce', []).toStmt()]));
    }
  }
  exports.bindDirectiveInputs = bindDirectiveInputs;
  function logBindingUpdateStmt(renderNode, propName, value) {
    var tryStmt = o.THIS_EXPR.prop('renderer').callMethod('setBindingDebugInfo', [renderNode, o.literal("ng-reflect-" + util_1.camelCaseToDashCase(propName)), value.isBlank().conditional(o.NULL_EXPR, value.callMethod('toString', []))]).toStmt();
    var catchStmt = o.THIS_EXPR.prop('renderer').callMethod('setBindingDebugInfo', [renderNode, o.literal("ng-reflect-" + util_1.camelCaseToDashCase(propName)), o.literal('[ERROR] Exception while trying to serialize the value')]).toStmt();
    return new o.TryCatchStmt([tryStmt], [catchStmt]);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/view_binder.js", ["../identifiers", "../template_parser/template_ast", "./event_binder", "./lifecycle_binder", "./property_binder"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var identifiers_1 = $__require('../identifiers');
  var template_ast_1 = $__require('../template_parser/template_ast');
  var event_binder_1 = $__require('./event_binder');
  var lifecycle_binder_1 = $__require('./lifecycle_binder');
  var property_binder_1 = $__require('./property_binder');
  function bindView(view, parsedTemplate) {
    var visitor = new ViewBinderVisitor(view);
    template_ast_1.templateVisitAll(visitor, parsedTemplate);
    view.pipes.forEach(function(pipe) {
      lifecycle_binder_1.bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view);
    });
  }
  exports.bindView = bindView;
  var ViewBinderVisitor = (function() {
    function ViewBinderVisitor(view) {
      this.view = view;
      this._nodeIndex = 0;
    }
    ViewBinderVisitor.prototype.visitBoundText = function(ast, parent) {
      var node = this.view.nodes[this._nodeIndex++];
      property_binder_1.bindRenderText(ast, node, this.view);
      return null;
    };
    ViewBinderVisitor.prototype.visitText = function(ast, parent) {
      this._nodeIndex++;
      return null;
    };
    ViewBinderVisitor.prototype.visitNgContent = function(ast, parent) {
      return null;
    };
    ViewBinderVisitor.prototype.visitElement = function(ast, parent) {
      var compileElement = this.view.nodes[this._nodeIndex++];
      var eventListeners = event_binder_1.collectEventListeners(ast.outputs, ast.directives, compileElement);
      property_binder_1.bindRenderInputs(ast.inputs, compileElement);
      event_binder_1.bindRenderOutputs(eventListeners);
      ast.directives.forEach(function(directiveAst) {
        var directiveInstance = compileElement.instances.get(identifiers_1.identifierToken(directiveAst.directive.type));
        property_binder_1.bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
        lifecycle_binder_1.bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
        property_binder_1.bindDirectiveHostProps(directiveAst, directiveInstance, compileElement);
        event_binder_1.bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
      });
      template_ast_1.templateVisitAll(this, ast.children, compileElement);
      ast.directives.forEach(function(directiveAst) {
        var directiveInstance = compileElement.instances.get(identifiers_1.identifierToken(directiveAst.directive.type));
        lifecycle_binder_1.bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        lifecycle_binder_1.bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
      });
      ast.providers.forEach(function(providerAst) {
        var providerInstance = compileElement.instances.get(providerAst.token);
        lifecycle_binder_1.bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
      });
      return null;
    };
    ViewBinderVisitor.prototype.visitEmbeddedTemplate = function(ast, parent) {
      var compileElement = this.view.nodes[this._nodeIndex++];
      var eventListeners = event_binder_1.collectEventListeners(ast.outputs, ast.directives, compileElement);
      ast.directives.forEach(function(directiveAst) {
        var directiveInstance = compileElement.instances.get(identifiers_1.identifierToken(directiveAst.directive.type));
        property_binder_1.bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
        lifecycle_binder_1.bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
        event_binder_1.bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
        lifecycle_binder_1.bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        lifecycle_binder_1.bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
      });
      ast.providers.forEach(function(providerAst) {
        var providerInstance = compileElement.instances.get(providerAst.token);
        lifecycle_binder_1.bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
      });
      bindView(compileElement.embeddedView, ast.children);
      return null;
    };
    ViewBinderVisitor.prototype.visitAttr = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitDirective = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitEvent = function(ast, eventTargetAndNames) {
      return null;
    };
    ViewBinderVisitor.prototype.visitReference = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitVariable = function(ast, ctx) {
      return null;
    };
    ViewBinderVisitor.prototype.visitDirectiveProperty = function(ast, context) {
      return null;
    };
    ViewBinderVisitor.prototype.visitElementProperty = function(ast, context) {
      return null;
    };
    return ViewBinderVisitor;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/math.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Math = lang_1.global.Math;
  exports.NaN = typeof exports.NaN;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/parse_util.js", ["./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./facade/lang');
  var ParseLocation = (function() {
    function ParseLocation(file, offset, line, col) {
      this.file = file;
      this.offset = offset;
      this.line = line;
      this.col = col;
    }
    ParseLocation.prototype.toString = function() {
      return lang_1.isPresent(this.offset) ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
    };
    return ParseLocation;
  }());
  exports.ParseLocation = ParseLocation;
  var ParseSourceFile = (function() {
    function ParseSourceFile(content, url) {
      this.content = content;
      this.url = url;
    }
    return ParseSourceFile;
  }());
  exports.ParseSourceFile = ParseSourceFile;
  var ParseSourceSpan = (function() {
    function ParseSourceSpan(start, end, details) {
      if (details === void 0) {
        details = null;
      }
      this.start = start;
      this.end = end;
      this.details = details;
    }
    ParseSourceSpan.prototype.toString = function() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    };
    return ParseSourceSpan;
  }());
  exports.ParseSourceSpan = ParseSourceSpan;
  (function(ParseErrorLevel) {
    ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
    ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
  })(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));
  var ParseErrorLevel = exports.ParseErrorLevel;
  var ParseError = (function() {
    function ParseError(span, msg, level) {
      if (level === void 0) {
        level = ParseErrorLevel.FATAL;
      }
      this.span = span;
      this.msg = msg;
      this.level = level;
    }
    ParseError.prototype.toString = function() {
      var source = this.span.start.file.content;
      var ctxStart = this.span.start.offset;
      var contextStr = '';
      var details = '';
      if (lang_1.isPresent(ctxStart)) {
        if (ctxStart > source.length - 1) {
          ctxStart = source.length - 1;
        }
        var ctxEnd = ctxStart;
        var ctxLen = 0;
        var ctxLines = 0;
        while (ctxLen < 100 && ctxStart > 0) {
          ctxStart--;
          ctxLen++;
          if (source[ctxStart] == '\n') {
            if (++ctxLines == 3) {
              break;
            }
          }
        }
        ctxLen = 0;
        ctxLines = 0;
        while (ctxLen < 100 && ctxEnd < source.length - 1) {
          ctxEnd++;
          ctxLen++;
          if (source[ctxEnd] == '\n') {
            if (++ctxLines == 3) {
              break;
            }
          }
        }
        var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' + source.substring(this.span.start.offset, ctxEnd + 1);
        contextStr = " (\"" + context + "\")";
      }
      if (this.span.details) {
        details = ", " + this.span.details;
      }
      return "" + this.msg + contextStr + ": " + this.span.start + details;
    };
    return ParseError;
  }());
  exports.ParseError = ParseError;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/animation/animation_ast.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var AnimationAst = (function() {
    function AnimationAst() {
      this.startTime = 0;
      this.playTime = 0;
    }
    return AnimationAst;
  }());
  exports.AnimationAst = AnimationAst;
  var AnimationStateAst = (function(_super) {
    __extends(AnimationStateAst, _super);
    function AnimationStateAst() {
      _super.apply(this, arguments);
    }
    return AnimationStateAst;
  }(AnimationAst));
  exports.AnimationStateAst = AnimationStateAst;
  var AnimationEntryAst = (function(_super) {
    __extends(AnimationEntryAst, _super);
    function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
      _super.call(this);
      this.name = name;
      this.stateDeclarations = stateDeclarations;
      this.stateTransitions = stateTransitions;
    }
    AnimationEntryAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationEntry(this, context);
    };
    return AnimationEntryAst;
  }(AnimationAst));
  exports.AnimationEntryAst = AnimationEntryAst;
  var AnimationStateDeclarationAst = (function(_super) {
    __extends(AnimationStateDeclarationAst, _super);
    function AnimationStateDeclarationAst(stateName, styles) {
      _super.call(this);
      this.stateName = stateName;
      this.styles = styles;
    }
    AnimationStateDeclarationAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationStateDeclaration(this, context);
    };
    return AnimationStateDeclarationAst;
  }(AnimationStateAst));
  exports.AnimationStateDeclarationAst = AnimationStateDeclarationAst;
  var AnimationStateTransitionExpression = (function() {
    function AnimationStateTransitionExpression(fromState, toState) {
      this.fromState = fromState;
      this.toState = toState;
    }
    return AnimationStateTransitionExpression;
  }());
  exports.AnimationStateTransitionExpression = AnimationStateTransitionExpression;
  var AnimationStateTransitionAst = (function(_super) {
    __extends(AnimationStateTransitionAst, _super);
    function AnimationStateTransitionAst(stateChanges, animation) {
      _super.call(this);
      this.stateChanges = stateChanges;
      this.animation = animation;
    }
    AnimationStateTransitionAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationStateTransition(this, context);
    };
    return AnimationStateTransitionAst;
  }(AnimationStateAst));
  exports.AnimationStateTransitionAst = AnimationStateTransitionAst;
  var AnimationStepAst = (function(_super) {
    __extends(AnimationStepAst, _super);
    function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
      _super.call(this);
      this.startingStyles = startingStyles;
      this.keyframes = keyframes;
      this.duration = duration;
      this.delay = delay;
      this.easing = easing;
    }
    AnimationStepAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationStep(this, context);
    };
    return AnimationStepAst;
  }(AnimationAst));
  exports.AnimationStepAst = AnimationStepAst;
  var AnimationStylesAst = (function(_super) {
    __extends(AnimationStylesAst, _super);
    function AnimationStylesAst(styles) {
      _super.call(this);
      this.styles = styles;
    }
    AnimationStylesAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationStyles(this, context);
    };
    return AnimationStylesAst;
  }(AnimationAst));
  exports.AnimationStylesAst = AnimationStylesAst;
  var AnimationKeyframeAst = (function(_super) {
    __extends(AnimationKeyframeAst, _super);
    function AnimationKeyframeAst(offset, styles) {
      _super.call(this);
      this.offset = offset;
      this.styles = styles;
    }
    AnimationKeyframeAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationKeyframe(this, context);
    };
    return AnimationKeyframeAst;
  }(AnimationAst));
  exports.AnimationKeyframeAst = AnimationKeyframeAst;
  var AnimationWithStepsAst = (function(_super) {
    __extends(AnimationWithStepsAst, _super);
    function AnimationWithStepsAst(steps) {
      _super.call(this);
      this.steps = steps;
    }
    return AnimationWithStepsAst;
  }(AnimationAst));
  exports.AnimationWithStepsAst = AnimationWithStepsAst;
  var AnimationGroupAst = (function(_super) {
    __extends(AnimationGroupAst, _super);
    function AnimationGroupAst(steps) {
      _super.call(this, steps);
    }
    AnimationGroupAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationGroup(this, context);
    };
    return AnimationGroupAst;
  }(AnimationWithStepsAst));
  exports.AnimationGroupAst = AnimationGroupAst;
  var AnimationSequenceAst = (function(_super) {
    __extends(AnimationSequenceAst, _super);
    function AnimationSequenceAst(steps) {
      _super.call(this, steps);
    }
    AnimationSequenceAst.prototype.visit = function(visitor, context) {
      return visitor.visitAnimationSequence(this, context);
    };
    return AnimationSequenceAst;
  }(AnimationWithStepsAst));
  exports.AnimationSequenceAst = AnimationSequenceAst;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/animation/styles_collection.js", ["../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var StylesCollectionEntry = (function() {
    function StylesCollectionEntry(time, value) {
      this.time = time;
      this.value = value;
    }
    StylesCollectionEntry.prototype.matches = function(time, value) {
      return time == this.time && value == this.value;
    };
    return StylesCollectionEntry;
  }());
  exports.StylesCollectionEntry = StylesCollectionEntry;
  var StylesCollection = (function() {
    function StylesCollection() {
      this.styles = {};
    }
    StylesCollection.prototype.insertAtTime = function(property, time, value) {
      var tuple = new StylesCollectionEntry(time, value);
      var entries = this.styles[property];
      if (!lang_1.isPresent(entries)) {
        entries = this.styles[property] = [];
      }
      var insertionIndex = 0;
      for (var i = entries.length - 1; i >= 0; i--) {
        if (entries[i].time <= time) {
          insertionIndex = i + 1;
          break;
        }
      }
      collection_1.ListWrapper.insert(entries, insertionIndex, tuple);
    };
    StylesCollection.prototype.getByIndex = function(property, index) {
      var items = this.styles[property];
      if (lang_1.isPresent(items)) {
        return index >= items.length ? null : items[index];
      }
      return null;
    };
    StylesCollection.prototype.indexOfAtOrBeforeTime = function(property, time) {
      var entries = this.styles[property];
      if (lang_1.isPresent(entries)) {
        for (var i = entries.length - 1; i >= 0; i--) {
          if (entries[i].time <= time)
            return i;
        }
      }
      return null;
    };
    return StylesCollection;
  }());
  exports.StylesCollection = StylesCollection;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/animation/animation_parser.js", ["../../core_private", "../compile_metadata", "../facade/collection", "../facade/lang", "../facade/math", "../parse_util", "./animation_ast", "./styles_collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_private_1 = $__require('../../core_private');
  var compile_metadata_1 = $__require('../compile_metadata');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var math_1 = $__require('../facade/math');
  var parse_util_1 = $__require('../parse_util');
  var animation_ast_1 = $__require('./animation_ast');
  var styles_collection_1 = $__require('./styles_collection');
  var _INITIAL_KEYFRAME = 0;
  var _TERMINAL_KEYFRAME = 1;
  var _ONE_SECOND = 1000;
  var AnimationParseError = (function(_super) {
    __extends(AnimationParseError, _super);
    function AnimationParseError(message) {
      _super.call(this, null, message);
    }
    AnimationParseError.prototype.toString = function() {
      return "" + this.msg;
    };
    return AnimationParseError;
  }(parse_util_1.ParseError));
  exports.AnimationParseError = AnimationParseError;
  var ParsedAnimationResult = (function() {
    function ParsedAnimationResult(ast, errors) {
      this.ast = ast;
      this.errors = errors;
    }
    return ParsedAnimationResult;
  }());
  exports.ParsedAnimationResult = ParsedAnimationResult;
  function parseAnimationEntry(entry) {
    var errors = [];
    var stateStyles = {};
    var transitions = [];
    var stateDeclarationAsts = [];
    entry.definitions.forEach(function(def) {
      if (def instanceof compile_metadata_1.CompileAnimationStateDeclarationMetadata) {
        _parseAnimationDeclarationStates(def, errors).forEach(function(ast) {
          stateDeclarationAsts.push(ast);
          stateStyles[ast.stateName] = ast.styles;
        });
      } else {
        transitions.push(def);
      }
    });
    var stateTransitionAsts = transitions.map(function(transDef) {
      return _parseAnimationStateTransition(transDef, stateStyles, errors);
    });
    var ast = new animation_ast_1.AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
    return new ParsedAnimationResult(ast, errors);
  }
  exports.parseAnimationEntry = parseAnimationEntry;
  function _parseAnimationDeclarationStates(stateMetadata, errors) {
    var styleValues = [];
    stateMetadata.styles.styles.forEach(function(stylesEntry) {
      if (lang_1.isStringMap(stylesEntry)) {
        styleValues.push(stylesEntry);
      } else {
        errors.push(new AnimationParseError("State based animations cannot contain references to other states"));
      }
    });
    var defStyles = new animation_ast_1.AnimationStylesAst(styleValues);
    var states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
    return states.map(function(state) {
      return new animation_ast_1.AnimationStateDeclarationAst(state, defStyles);
    });
  }
  function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, errors) {
    var styles = new styles_collection_1.StylesCollection();
    var transitionExprs = [];
    var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
    transitionStates.forEach(function(expr) {
      _parseAnimationTransitionExpr(expr, errors).forEach(function(transExpr) {
        transitionExprs.push(transExpr);
      });
    });
    var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
    var animation = _normalizeStyleSteps(entry, stateStyles, errors);
    var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
    if (errors.length == 0) {
      _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
    }
    var sequenceAst = (animationAst instanceof animation_ast_1.AnimationSequenceAst) ? animationAst : new animation_ast_1.AnimationSequenceAst([animationAst]);
    return new animation_ast_1.AnimationStateTransitionAst(transitionExprs, sequenceAst);
  }
  function _parseAnimationTransitionExpr(eventStr, errors) {
    var expressions = [];
    var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (!lang_1.isPresent(match) || match.length < 4) {
      errors.push(new AnimationParseError("the provided " + eventStr + " is not of a supported format"));
      return expressions;
    }
    var fromState = match[1];
    var separator = match[2];
    var toState = match[3];
    expressions.push(new animation_ast_1.AnimationStateTransitionExpression(fromState, toState));
    var isFullAnyStateExpr = fromState == core_private_1.ANY_STATE && toState == core_private_1.ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
      expressions.push(new animation_ast_1.AnimationStateTransitionExpression(toState, fromState));
    }
    return expressions;
  }
  function _fetchSylesFromState(stateName, stateStyles) {
    var entry = stateStyles[stateName];
    if (lang_1.isPresent(entry)) {
      var styles = entry.styles;
      return new compile_metadata_1.CompileAnimationStyleMetadata(0, styles);
    }
    return null;
  }
  function _normalizeAnimationEntry(entry) {
    return lang_1.isArray(entry) ? new compile_metadata_1.CompileAnimationSequenceMetadata(entry) : entry;
  }
  function _normalizeStyleMetadata(entry, stateStyles, errors) {
    var normalizedStyles = [];
    entry.styles.forEach(function(styleEntry) {
      if (lang_1.isString(styleEntry)) {
        collection_1.ListWrapper.addAll(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));
      } else {
        normalizedStyles.push(styleEntry);
      }
    });
    return normalizedStyles;
  }
  function _normalizeStyleSteps(entry, stateStyles, errors) {
    var steps = _normalizeStyleStepEntry(entry, stateStyles, errors);
    return new compile_metadata_1.CompileAnimationSequenceMetadata(steps);
  }
  function _mergeAnimationStyles(stylesList, newItem) {
    if (lang_1.isStringMap(newItem) && stylesList.length > 0) {
      var lastIndex = stylesList.length - 1;
      var lastItem = stylesList[lastIndex];
      if (lang_1.isStringMap(lastItem)) {
        stylesList[lastIndex] = collection_1.StringMapWrapper.merge(lastItem, newItem);
        return;
      }
    }
    stylesList.push(newItem);
  }
  function _normalizeStyleStepEntry(entry, stateStyles, errors) {
    var steps;
    if (entry instanceof compile_metadata_1.CompileAnimationWithStepsMetadata) {
      steps = entry.steps;
    } else {
      return [entry];
    }
    var newSteps = [];
    var combinedStyles;
    steps.forEach(function(step) {
      if (step instanceof compile_metadata_1.CompileAnimationStyleMetadata) {
        if (!lang_1.isPresent(combinedStyles)) {
          combinedStyles = [];
        }
        _normalizeStyleMetadata(step, stateStyles, errors).forEach(function(entry) {
          _mergeAnimationStyles(combinedStyles, entry);
        });
      } else {
        if (lang_1.isPresent(combinedStyles)) {
          newSteps.push(new compile_metadata_1.CompileAnimationStyleMetadata(0, combinedStyles));
          combinedStyles = null;
        }
        if (step instanceof compile_metadata_1.CompileAnimationAnimateMetadata) {
          var animateStyleValue = step.styles;
          if (animateStyleValue instanceof compile_metadata_1.CompileAnimationStyleMetadata) {
            animateStyleValue.styles = _normalizeStyleMetadata(animateStyleValue, stateStyles, errors);
          } else if (animateStyleValue instanceof compile_metadata_1.CompileAnimationKeyframesSequenceMetadata) {
            animateStyleValue.steps.forEach(function(step) {
              step.styles = _normalizeStyleMetadata(step, stateStyles, errors);
            });
          }
        } else if (step instanceof compile_metadata_1.CompileAnimationWithStepsMetadata) {
          var innerSteps = _normalizeStyleStepEntry(step, stateStyles, errors);
          step = step instanceof compile_metadata_1.CompileAnimationGroupMetadata ? new compile_metadata_1.CompileAnimationGroupMetadata(innerSteps) : new compile_metadata_1.CompileAnimationSequenceMetadata(innerSteps);
        }
        newSteps.push(step);
      }
    });
    if (lang_1.isPresent(combinedStyles)) {
      newSteps.push(new compile_metadata_1.CompileAnimationStyleMetadata(0, combinedStyles));
    }
    return newSteps;
  }
  function _resolveStylesFromState(stateName, stateStyles, errors) {
    var styles = [];
    if (stateName[0] != ':') {
      errors.push(new AnimationParseError("Animation states via styles must be prefixed with a \":\""));
    } else {
      var normalizedStateName = stateName.substring(1);
      var value = stateStyles[normalizedStateName];
      if (!lang_1.isPresent(value)) {
        errors.push(new AnimationParseError("Unable to apply styles due to missing a state: \"" + normalizedStateName + "\""));
      } else {
        value.styles.forEach(function(stylesEntry) {
          if (lang_1.isStringMap(stylesEntry)) {
            styles.push(stylesEntry);
          }
        });
      }
    }
    return styles;
  }
  var _AnimationTimings = (function() {
    function _AnimationTimings(duration, delay, easing) {
      this.duration = duration;
      this.delay = delay;
      this.easing = easing;
    }
    return _AnimationTimings;
  }());
  function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
    var totalEntries = keyframeSequence.steps.length;
    var totalOffsets = 0;
    keyframeSequence.steps.forEach(function(step) {
      return totalOffsets += (lang_1.isPresent(step.offset) ? 1 : 0);
    });
    if (totalOffsets > 0 && totalOffsets < totalEntries) {
      errors.push(new AnimationParseError("Not all style() entries contain an offset for the provided keyframe()"));
      totalOffsets = totalEntries;
    }
    var limit = totalEntries - 1;
    var margin = totalOffsets == 0 ? (1 / limit) : 0;
    var rawKeyframes = [];
    var index = 0;
    var doSortKeyframes = false;
    var lastOffset = 0;
    keyframeSequence.steps.forEach(function(styleMetadata) {
      var offset = styleMetadata.offset;
      var keyframeStyles = {};
      styleMetadata.styles.forEach(function(entry) {
        collection_1.StringMapWrapper.forEach(entry, function(value, prop) {
          if (prop != 'offset') {
            keyframeStyles[prop] = value;
          }
        });
      });
      if (lang_1.isPresent(offset)) {
        doSortKeyframes = doSortKeyframes || (offset < lastOffset);
      } else {
        offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);
      }
      rawKeyframes.push([offset, keyframeStyles]);
      lastOffset = offset;
      index++;
    });
    if (doSortKeyframes) {
      collection_1.ListWrapper.sort(rawKeyframes, function(a, b) {
        return a[0] <= b[0] ? -1 : 1;
      });
    }
    var i;
    var firstKeyframe = rawKeyframes[0];
    if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
      collection_1.ListWrapper.insert(rawKeyframes, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
    }
    var firstKeyframeStyles = firstKeyframe[1];
    limit = rawKeyframes.length - 1;
    var lastKeyframe = rawKeyframes[limit];
    if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
      rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
      limit++;
    }
    var lastKeyframeStyles = lastKeyframe[1];
    for (i = 1; i <= limit; i++) {
      var entry = rawKeyframes[i];
      var styles = entry[1];
      collection_1.StringMapWrapper.forEach(styles, function(value, prop) {
        if (!lang_1.isPresent(firstKeyframeStyles[prop])) {
          firstKeyframeStyles[prop] = core_private_1.FILL_STYLE_FLAG;
        }
      });
    }
    for (i = limit - 1; i >= 0; i--) {
      var entry = rawKeyframes[i];
      var styles = entry[1];
      collection_1.StringMapWrapper.forEach(styles, function(value, prop) {
        if (!lang_1.isPresent(lastKeyframeStyles[prop])) {
          lastKeyframeStyles[prop] = value;
        }
      });
    }
    return rawKeyframes.map(function(entry) {
      return new animation_ast_1.AnimationKeyframeAst(entry[0], new animation_ast_1.AnimationStylesAst([entry[1]]));
    });
  }
  function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
    var ast;
    var playTime = 0;
    var startingTime = currentTime;
    if (entry instanceof compile_metadata_1.CompileAnimationWithStepsMetadata) {
      var maxDuration = 0;
      var steps = [];
      var isGroup = entry instanceof compile_metadata_1.CompileAnimationGroupMetadata;
      var previousStyles;
      entry.steps.forEach(function(entry) {
        var time = isGroup ? startingTime : currentTime;
        if (entry instanceof compile_metadata_1.CompileAnimationStyleMetadata) {
          entry.styles.forEach(function(stylesEntry) {
            var map = stylesEntry;
            collection_1.StringMapWrapper.forEach(map, function(value, prop) {
              collectedStyles.insertAtTime(prop, time, value);
            });
          });
          previousStyles = entry.styles;
          return;
        }
        var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
        if (lang_1.isPresent(previousStyles)) {
          if (entry instanceof compile_metadata_1.CompileAnimationWithStepsMetadata) {
            var startingStyles = new animation_ast_1.AnimationStylesAst(previousStyles);
            steps.push(new animation_ast_1.AnimationStepAst(startingStyles, [], 0, 0, ''));
          } else {
            var innerStep = innerAst;
            collection_1.ListWrapper.addAll(innerStep.startingStyles.styles, previousStyles);
          }
          previousStyles = null;
        }
        var astDuration = innerAst.playTime;
        currentTime += astDuration;
        playTime += astDuration;
        maxDuration = math_1.Math.max(astDuration, maxDuration);
        steps.push(innerAst);
      });
      if (lang_1.isPresent(previousStyles)) {
        var startingStyles = new animation_ast_1.AnimationStylesAst(previousStyles);
        steps.push(new animation_ast_1.AnimationStepAst(startingStyles, [], 0, 0, ''));
      }
      if (isGroup) {
        ast = new animation_ast_1.AnimationGroupAst(steps);
        playTime = maxDuration;
        currentTime = startingTime + playTime;
      } else {
        ast = new animation_ast_1.AnimationSequenceAst(steps);
      }
    } else if (entry instanceof compile_metadata_1.CompileAnimationAnimateMetadata) {
      var timings = _parseTimeExpression(entry.timings, errors);
      var styles = entry.styles;
      var keyframes;
      if (styles instanceof compile_metadata_1.CompileAnimationKeyframesSequenceMetadata) {
        keyframes = _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
      } else {
        var styleData = styles;
        var offset = _TERMINAL_KEYFRAME;
        var styleAst = new animation_ast_1.AnimationStylesAst(styleData.styles);
        var keyframe = new animation_ast_1.AnimationKeyframeAst(offset, styleAst);
        keyframes = [keyframe];
      }
      ast = new animation_ast_1.AnimationStepAst(new animation_ast_1.AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
      playTime = timings.duration + timings.delay;
      currentTime += playTime;
      keyframes.forEach(function(keyframe) {
        return keyframe.styles.styles.forEach(function(entry) {
          return collection_1.StringMapWrapper.forEach(entry, function(value, prop) {
            return collectedStyles.insertAtTime(prop, currentTime, value);
          });
        });
      });
    } else {
      ast = new animation_ast_1.AnimationStepAst(null, [], 0, 0, '');
    }
    ast.playTime = playTime;
    ast.startTime = startingTime;
    return ast;
  }
  function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
    if ((ast instanceof animation_ast_1.AnimationStepAst) && ast.keyframes.length > 0) {
      var keyframes = ast.keyframes;
      if (keyframes.length == 1) {
        var endKeyframe = keyframes[0];
        var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
        ast.keyframes = [startKeyframe, endKeyframe];
      }
    } else if (ast instanceof animation_ast_1.AnimationWithStepsAst) {
      ast.steps.forEach(function(entry) {
        return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors);
      });
    }
  }
  function _parseTimeExpression(exp, errors) {
    var regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/i;
    var duration;
    var delay = 0;
    var easing = null;
    if (lang_1.isString(exp)) {
      var matches = exp.match(regex);
      if (matches === null) {
        errors.push(new AnimationParseError("The provided timing value \"" + exp + "\" is invalid."));
        return new _AnimationTimings(0, 0, null);
      }
      var durationMatch = lang_1.NumberWrapper.parseFloat(matches[1]);
      var durationUnit = matches[2];
      if (durationUnit == 's') {
        durationMatch *= _ONE_SECOND;
      }
      duration = math_1.Math.floor(durationMatch);
      var delayMatch = matches[3];
      var delayUnit = matches[4];
      if (lang_1.isPresent(delayMatch)) {
        var delayVal = lang_1.NumberWrapper.parseFloat(delayMatch);
        if (lang_1.isPresent(delayUnit) && delayUnit == 's') {
          delayVal *= _ONE_SECOND;
        }
        delay = math_1.Math.floor(delayVal);
      }
      var easingVal = matches[5];
      if (!lang_1.isBlank(easingVal)) {
        easing = easingVal;
      }
    } else {
      duration = exp;
    }
    return new _AnimationTimings(duration, delay, easing);
  }
  function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
    var values = {};
    var endTime = startTime + duration;
    endKeyframe.styles.styles.forEach(function(styleData) {
      collection_1.StringMapWrapper.forEach(styleData, function(val, prop) {
        if (prop == 'offset')
          return;
        var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
        var resultEntry,
            nextEntry,
            value;
        if (lang_1.isPresent(resultIndex)) {
          resultEntry = collectedStyles.getByIndex(prop, resultIndex);
          value = resultEntry.value;
          nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
        } else {
          value = core_private_1.FILL_STYLE_FLAG;
        }
        if (lang_1.isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {
          errors.push(new AnimationParseError("The animated CSS property \"" + prop + "\" unexpectedly changes between steps \"" + resultEntry.time + "ms\" and \"" + endTime + "ms\" at \"" + nextEntry.time + "ms\""));
        }
        values[prop] = value;
      });
    });
    return new animation_ast_1.AnimationKeyframeAst(_INITIAL_KEYFRAME, new animation_ast_1.AnimationStylesAst([values]));
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/animation/animation_compiler.js", ["../../core_private", "../facade/collection", "../facade/exceptions", "../facade/lang", "../identifiers", "../output/output_ast", "../template_parser/template_ast", "./animation_ast", "./animation_parser"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_private_1 = $__require('../../core_private');
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var t = $__require('../template_parser/template_ast');
  var animation_ast_1 = $__require('./animation_ast');
  var animation_parser_1 = $__require('./animation_parser');
  var CompiledAnimation = (function() {
    function CompiledAnimation(name, statesMapStatement, statesVariableName, fnStatement, fnVariable) {
      this.name = name;
      this.statesMapStatement = statesMapStatement;
      this.statesVariableName = statesVariableName;
      this.fnStatement = fnStatement;
      this.fnVariable = fnVariable;
    }
    return CompiledAnimation;
  }());
  exports.CompiledAnimation = CompiledAnimation;
  var AnimationCompiler = (function() {
    function AnimationCompiler() {}
    AnimationCompiler.prototype.compileComponent = function(component, template) {
      var compiledAnimations = [];
      var groupedErrors = [];
      var triggerLookup = {};
      var componentName = component.type.name;
      component.template.animations.forEach(function(entry) {
        var result = animation_parser_1.parseAnimationEntry(entry);
        var triggerName = entry.name;
        if (result.errors.length > 0) {
          var errorMessage = "Unable to parse the animation sequence for \"" + triggerName + "\" due to the following errors:";
          result.errors.forEach(function(error) {
            errorMessage += '\n-- ' + error.msg;
          });
          groupedErrors.push(errorMessage);
        }
        if (triggerLookup[triggerName]) {
          groupedErrors.push("The animation trigger \"" + triggerName + "\" has already been registered on \"" + componentName + "\"");
        } else {
          var factoryName = componentName + "_" + entry.name;
          var visitor = new _AnimationBuilder(triggerName, factoryName);
          var compileResult = visitor.build(result.ast);
          compiledAnimations.push(compileResult);
          triggerLookup[entry.name] = compileResult;
        }
      });
      _validateAnimationProperties(compiledAnimations, template).forEach(function(entry) {
        groupedErrors.push(entry.msg);
      });
      if (groupedErrors.length > 0) {
        var errorMessageStr = "Animation parsing for " + component.type.name + " has failed due to the following errors:";
        groupedErrors.forEach(function(error) {
          return errorMessageStr += "\n- " + error;
        });
        throw new exceptions_1.BaseException(errorMessageStr);
      }
      return compiledAnimations;
    };
    return AnimationCompiler;
  }());
  exports.AnimationCompiler = AnimationCompiler;
  var _ANIMATION_FACTORY_ELEMENT_VAR = o.variable('element');
  var _ANIMATION_DEFAULT_STATE_VAR = o.variable('defaultStateStyles');
  var _ANIMATION_FACTORY_VIEW_VAR = o.variable('view');
  var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
  var _ANIMATION_CURRENT_STATE_VAR = o.variable('currentState');
  var _ANIMATION_NEXT_STATE_VAR = o.variable('nextState');
  var _ANIMATION_PLAYER_VAR = o.variable('player');
  var _ANIMATION_START_STATE_STYLES_VAR = o.variable('startStateStyles');
  var _ANIMATION_END_STATE_STYLES_VAR = o.variable('endStateStyles');
  var _ANIMATION_COLLECTED_STYLES = o.variable('collectedStyles');
  var EMPTY_MAP = o.literalMap([]);
  var _AnimationBuilder = (function() {
    function _AnimationBuilder(animationName, factoryName) {
      this.animationName = animationName;
      this._fnVarName = factoryName + '_factory';
      this._statesMapVarName = factoryName + '_states';
      this._statesMapVar = o.variable(this._statesMapVarName);
    }
    _AnimationBuilder.prototype.visitAnimationStyles = function(ast, context) {
      var stylesArr = [];
      if (context.isExpectingFirstStyleStep) {
        stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
        context.isExpectingFirstStyleStep = false;
      }
      ast.styles.forEach(function(entry) {
        stylesArr.push(o.literalMap(collection_1.StringMapWrapper.keys(entry).map(function(key) {
          return [key, o.literal(entry[key])];
        })));
      });
      return o.importExpr(identifiers_1.Identifiers.AnimationStyles).instantiate([o.importExpr(identifiers_1.Identifiers.collectAndResolveStyles).callFn([_ANIMATION_COLLECTED_STYLES, o.literalArr(stylesArr)])]);
    };
    _AnimationBuilder.prototype.visitAnimationKeyframe = function(ast, context) {
      return o.importExpr(identifiers_1.Identifiers.AnimationKeyframe).instantiate([o.literal(ast.offset), ast.styles.visit(this, context)]);
    };
    _AnimationBuilder.prototype.visitAnimationStep = function(ast, context) {
      var _this = this;
      if (context.endStateAnimateStep === ast) {
        return this._visitEndStateAnimation(ast, context);
      }
      var startingStylesExpr = ast.startingStyles.visit(this, context);
      var keyframeExpressions = ast.keyframes.map(function(keyframeEntry) {
        return keyframeEntry.visit(_this, context);
      });
      return this._callAnimateMethod(ast, startingStylesExpr, o.literalArr(keyframeExpressions));
    };
    _AnimationBuilder.prototype._visitEndStateAnimation = function(ast, context) {
      var _this = this;
      var startingStylesExpr = ast.startingStyles.visit(this, context);
      var keyframeExpressions = ast.keyframes.map(function(keyframe) {
        return keyframe.visit(_this, context);
      });
      var keyframesExpr = o.importExpr(identifiers_1.Identifiers.balanceAnimationKeyframes).callFn([_ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR, o.literalArr(keyframeExpressions)]);
      return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr);
    };
    _AnimationBuilder.prototype._callAnimateMethod = function(ast, startingStylesExpr, keyframesExpr) {
      return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [_ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, o.literal(ast.duration), o.literal(ast.delay), o.literal(ast.easing)]);
    };
    _AnimationBuilder.prototype.visitAnimationSequence = function(ast, context) {
      var _this = this;
      var playerExprs = ast.steps.map(function(step) {
        return step.visit(_this, context);
      });
      return o.importExpr(identifiers_1.Identifiers.AnimationSequencePlayer).instantiate([o.literalArr(playerExprs)]);
    };
    _AnimationBuilder.prototype.visitAnimationGroup = function(ast, context) {
      var _this = this;
      var playerExprs = ast.steps.map(function(step) {
        return step.visit(_this, context);
      });
      return o.importExpr(identifiers_1.Identifiers.AnimationGroupPlayer).instantiate([o.literalArr(playerExprs)]);
    };
    _AnimationBuilder.prototype.visitAnimationStateDeclaration = function(ast, context) {
      var flatStyles = {};
      _getStylesArray(ast).forEach(function(entry) {
        collection_1.StringMapWrapper.forEach(entry, function(value, key) {
          flatStyles[key] = value;
        });
      });
      context.stateMap.registerState(ast.stateName, flatStyles);
    };
    _AnimationBuilder.prototype.visitAnimationStateTransition = function(ast, context) {
      var steps = ast.animation.steps;
      var lastStep = steps[steps.length - 1];
      if (_isEndStateAnimateStep(lastStep)) {
        context.endStateAnimateStep = lastStep;
      }
      context.isExpectingFirstStyleStep = true;
      var stateChangePreconditions = [];
      ast.stateChanges.forEach(function(stateChange) {
        stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState).and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
        if (stateChange.fromState != core_private_1.ANY_STATE) {
          context.stateMap.registerState(stateChange.fromState);
        }
        if (stateChange.toState != core_private_1.ANY_STATE) {
          context.stateMap.registerState(stateChange.toState);
        }
      });
      var animationPlayerExpr = ast.animation.visit(this, context);
      var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function(a, b) {
        return a.or(b);
      });
      var precondition = _ANIMATION_PLAYER_VAR.equals(o.NULL_EXPR).and(reducedStateChangesPrecondition);
      return new o.IfStmt(precondition, [_ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt()]);
    };
    _AnimationBuilder.prototype.visitAnimationEntry = function(ast, context) {
      var _this = this;
      ast.stateDeclarations.forEach(function(def) {
        return def.visit(_this, context);
      });
      context.stateMap.registerState(core_private_1.DEFAULT_STATE, {});
      var statements = [];
      statements.push(_ANIMATION_FACTORY_VIEW_VAR.callMethod('cancelActiveAnimation', [_ANIMATION_FACTORY_ELEMENT_VAR, o.literal(this.animationName), _ANIMATION_NEXT_STATE_VAR.equals(o.literal(core_private_1.EMPTY_STATE))]).toStmt());
      statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP).toDeclStmt());
      statements.push(_ANIMATION_PLAYER_VAR.set(o.NULL_EXPR).toDeclStmt());
      statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(o.literal(core_private_1.DEFAULT_STATE))).toDeclStmt());
      statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR)).toDeclStmt());
      statements.push(new o.IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(o.NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
      statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR)).toDeclStmt());
      statements.push(new o.IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(o.NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
      var RENDER_STYLES_FN = o.importExpr(identifiers_1.Identifiers.renderStyles);
      statements.push(RENDER_STYLES_FN.callFn([_ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR, o.importExpr(identifiers_1.Identifiers.clearStyles).callFn([_ANIMATION_START_STATE_STYLES_VAR])]).toStmt());
      ast.stateTransitions.forEach(function(transAst) {
        return statements.push(transAst.visit(_this, context));
      });
      statements.push(new o.IfStmt(_ANIMATION_PLAYER_VAR.equals(o.NULL_EXPR), [_ANIMATION_PLAYER_VAR.set(o.importExpr(identifiers_1.Identifiers.NoOpAnimationPlayer).instantiate([])).toStmt()]));
      statements.push(_ANIMATION_PLAYER_VAR.callMethod('onDone', [o.fn([], [RENDER_STYLES_FN.callFn([_ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR, o.importExpr(identifiers_1.Identifiers.prepareFinalAnimationStyles).callFn([_ANIMATION_START_STATE_STYLES_VAR, _ANIMATION_END_STATE_STYLES_VAR])]).toStmt()])]).toStmt());
      statements.push(_ANIMATION_FACTORY_VIEW_VAR.callMethod('queueAnimation', [_ANIMATION_FACTORY_ELEMENT_VAR, o.literal(this.animationName), _ANIMATION_PLAYER_VAR]).toStmt());
      return o.fn([new o.FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, o.importType(identifiers_1.Identifiers.AppView, [o.DYNAMIC_TYPE])), new o.FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, o.DYNAMIC_TYPE), new o.FnParam(_ANIMATION_CURRENT_STATE_VAR.name, o.DYNAMIC_TYPE), new o.FnParam(_ANIMATION_NEXT_STATE_VAR.name, o.DYNAMIC_TYPE)], statements);
    };
    _AnimationBuilder.prototype.build = function(ast) {
      var context = new _AnimationBuilderContext();
      var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
      var fnVariable = o.variable(this._fnVarName);
      var lookupMap = [];
      collection_1.StringMapWrapper.forEach(context.stateMap.states, function(value, stateName) {
        var variableValue = EMPTY_MAP;
        if (lang_1.isPresent(value)) {
          var styleMap_1 = [];
          collection_1.StringMapWrapper.forEach(value, function(value, key) {
            styleMap_1.push([key, o.literal(value)]);
          });
          variableValue = o.literalMap(styleMap_1);
        }
        lookupMap.push([stateName, variableValue]);
      });
      var compiledStatesMapExpr = this._statesMapVar.set(o.literalMap(lookupMap)).toDeclStmt();
      return new CompiledAnimation(this.animationName, compiledStatesMapExpr, this._statesMapVarName, fnStatement, fnVariable);
    };
    return _AnimationBuilder;
  }());
  var _AnimationBuilderContext = (function() {
    function _AnimationBuilderContext() {
      this.stateMap = new _AnimationBuilderStateMap();
      this.endStateAnimateStep = null;
      this.isExpectingFirstStyleStep = false;
    }
    return _AnimationBuilderContext;
  }());
  var _AnimationBuilderStateMap = (function() {
    function _AnimationBuilderStateMap() {
      this._states = {};
    }
    Object.defineProperty(_AnimationBuilderStateMap.prototype, "states", {
      get: function() {
        return this._states;
      },
      enumerable: true,
      configurable: true
    });
    _AnimationBuilderStateMap.prototype.registerState = function(name, value) {
      if (value === void 0) {
        value = null;
      }
      var existingEntry = this._states[name];
      if (lang_1.isBlank(existingEntry)) {
        this._states[name] = value;
      }
    };
    return _AnimationBuilderStateMap;
  }());
  function _compareToAnimationStateExpr(value, animationState) {
    var emptyStateLiteral = o.literal(core_private_1.EMPTY_STATE);
    switch (animationState) {
      case core_private_1.EMPTY_STATE:
        return value.equals(emptyStateLiteral);
      case core_private_1.ANY_STATE:
        return o.literal(true);
      default:
        return value.equals(o.literal(animationState));
    }
  }
  function _isEndStateAnimateStep(step) {
    if (step instanceof animation_ast_1.AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
      var styles1 = _getStylesArray(step.keyframes[0])[0];
      var styles2 = _getStylesArray(step.keyframes[1])[0];
      return collection_1.StringMapWrapper.isEmpty(styles1) && collection_1.StringMapWrapper.isEmpty(styles2);
    }
    return false;
  }
  function _getStylesArray(obj) {
    return obj.styles.styles;
  }
  function _validateAnimationProperties(compiledAnimations, template) {
    var visitor = new _AnimationTemplatePropertyVisitor(compiledAnimations);
    t.templateVisitAll(visitor, template);
    return visitor.errors;
  }
  var _AnimationTemplatePropertyVisitor = (function() {
    function _AnimationTemplatePropertyVisitor(animations) {
      var _this = this;
      this._animationRegistry = {};
      this.errors = [];
      animations.forEach(function(entry) {
        _this._animationRegistry[entry.name] = true;
      });
    }
    _AnimationTemplatePropertyVisitor.prototype.visitElement = function(ast, ctx) {
      var _this = this;
      ast.inputs.forEach(function(input) {
        if (input.type == t.PropertyBindingType.Animation) {
          var animationName = input.name;
          if (!lang_1.isPresent(_this._animationRegistry[animationName])) {
            _this.errors.push(new animation_parser_1.AnimationParseError("couldn't find an animation entry for " + animationName));
          }
        }
      });
      t.templateVisitAll(this, ast.children);
    };
    _AnimationTemplatePropertyVisitor.prototype.visitBoundText = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitText = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitEmbeddedTemplate = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitNgContent = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitAttr = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitDirective = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitEvent = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitReference = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitVariable = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitDirectiveProperty = function(ast, ctx) {};
    _AnimationTemplatePropertyVisitor.prototype.visitElementProperty = function(ast, ctx) {};
    return _AnimationTemplatePropertyVisitor;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/value_util.js", ["../compile_metadata", "../facade/collection", "../facade/exceptions", "../util", "./output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var compile_metadata_1 = $__require('../compile_metadata');
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var util_1 = $__require('../util');
  var o = $__require('./output_ast');
  function convertValueToOutputAst(value, type) {
    if (type === void 0) {
      type = null;
    }
    return util_1.visitValue(value, new _ValueOutputAstTransformer(), type);
  }
  exports.convertValueToOutputAst = convertValueToOutputAst;
  var _ValueOutputAstTransformer = (function() {
    function _ValueOutputAstTransformer() {}
    _ValueOutputAstTransformer.prototype.visitArray = function(arr, type) {
      var _this = this;
      return o.literalArr(arr.map(function(value) {
        return util_1.visitValue(value, _this, null);
      }), type);
    };
    _ValueOutputAstTransformer.prototype.visitStringMap = function(map, type) {
      var _this = this;
      var entries = [];
      collection_1.StringMapWrapper.forEach(map, function(value, key) {
        entries.push([key, util_1.visitValue(value, _this, null)]);
      });
      return o.literalMap(entries, type);
    };
    _ValueOutputAstTransformer.prototype.visitPrimitive = function(value, type) {
      return o.literal(value, type);
    };
    _ValueOutputAstTransformer.prototype.visitOther = function(value, type) {
      if (value instanceof compile_metadata_1.CompileIdentifierMetadata) {
        return o.importExpr(value);
      } else if (value instanceof o.Expression) {
        return value;
      } else {
        throw new exceptions_1.BaseException("Illegal state: Don't now how to compile value " + value);
      }
    };
    return _ValueOutputAstTransformer;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/template_parser/template_ast.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var TextAst = (function() {
    function TextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    TextAst.prototype.visit = function(visitor, context) {
      return visitor.visitText(this, context);
    };
    return TextAst;
  }());
  exports.TextAst = TextAst;
  var BoundTextAst = (function() {
    function BoundTextAst(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    BoundTextAst.prototype.visit = function(visitor, context) {
      return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
  }());
  exports.BoundTextAst = BoundTextAst;
  var AttrAst = (function() {
    function AttrAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    AttrAst.prototype.visit = function(visitor, context) {
      return visitor.visitAttr(this, context);
    };
    return AttrAst;
  }());
  exports.AttrAst = AttrAst;
  var BoundElementPropertyAst = (function() {
    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
    }
    BoundElementPropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitElementProperty(this, context);
    };
    return BoundElementPropertyAst;
  }());
  exports.BoundElementPropertyAst = BoundElementPropertyAst;
  var BoundEventAst = (function() {
    function BoundEventAst(name, target, handler, sourceSpan) {
      this.name = name;
      this.target = target;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
    }
    BoundEventAst.prototype.visit = function(visitor, context) {
      return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
      get: function() {
        if (lang_1.isPresent(this.target)) {
          return this.target + ":" + this.name;
        } else {
          return this.name;
        }
      },
      enumerable: true,
      configurable: true
    });
    return BoundEventAst;
  }());
  exports.BoundEventAst = BoundEventAst;
  var ReferenceAst = (function() {
    function ReferenceAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    ReferenceAst.prototype.visit = function(visitor, context) {
      return visitor.visitReference(this, context);
    };
    return ReferenceAst;
  }());
  exports.ReferenceAst = ReferenceAst;
  var VariableAst = (function() {
    function VariableAst(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    VariableAst.prototype.visit = function(visitor, context) {
      return visitor.visitVariable(this, context);
    };
    return VariableAst;
  }());
  exports.VariableAst = VariableAst;
  var ElementAst = (function() {
    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.references = references;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    ElementAst.prototype.visit = function(visitor, context) {
      return visitor.visitElement(this, context);
    };
    return ElementAst;
  }());
  exports.ElementAst = ElementAst;
  var EmbeddedTemplateAst = (function() {
    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
      this.attrs = attrs;
      this.outputs = outputs;
      this.references = references;
      this.variables = variables;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    EmbeddedTemplateAst.prototype.visit = function(visitor, context) {
      return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
  }());
  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
  var BoundDirectivePropertyAst = (function() {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
      this.directiveName = directiveName;
      this.templateName = templateName;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    BoundDirectivePropertyAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
  }());
  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
  var DirectiveAst = (function() {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
      this.directive = directive;
      this.inputs = inputs;
      this.hostProperties = hostProperties;
      this.hostEvents = hostEvents;
      this.sourceSpan = sourceSpan;
    }
    DirectiveAst.prototype.visit = function(visitor, context) {
      return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
  }());
  exports.DirectiveAst = DirectiveAst;
  var ProviderAst = (function() {
    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
      this.token = token;
      this.multiProvider = multiProvider;
      this.eager = eager;
      this.providers = providers;
      this.providerType = providerType;
      this.lifecycleHooks = lifecycleHooks;
      this.sourceSpan = sourceSpan;
    }
    ProviderAst.prototype.visit = function(visitor, context) {
      return null;
    };
    return ProviderAst;
  }());
  exports.ProviderAst = ProviderAst;
  (function(ProviderAstType) {
    ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
    ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
    ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
    ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
    ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
  })(exports.ProviderAstType || (exports.ProviderAstType = {}));
  var ProviderAstType = exports.ProviderAstType;
  var NgContentAst = (function() {
    function NgContentAst(index, ngContentIndex, sourceSpan) {
      this.index = index;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    NgContentAst.prototype.visit = function(visitor, context) {
      return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
  }());
  exports.NgContentAst = NgContentAst;
  (function(PropertyBindingType) {
    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
    PropertyBindingType[PropertyBindingType["Animation"] = 4] = "Animation";
  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
  var PropertyBindingType = exports.PropertyBindingType;
  function templateVisitAll(visitor, asts, context) {
    if (context === void 0) {
      context = null;
    }
    var result = [];
    asts.forEach(function(ast) {
      var astResult = ast.visit(visitor, context);
      if (lang_1.isPresent(astResult)) {
        result.push(astResult);
      }
    });
    return result;
  }
  exports.templateVisitAll = templateVisitAll;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_element.js", ["../compile_metadata", "../facade/collection", "../facade/lang", "../identifiers", "../output/output_ast", "../output/value_util", "../template_parser/template_ast", "../util", "./compile_method", "./compile_query", "./constants", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var compile_metadata_1 = $__require('../compile_metadata');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var value_util_1 = $__require('../output/value_util');
  var template_ast_1 = $__require('../template_parser/template_ast');
  var util_1 = $__require('../util');
  var compile_method_1 = $__require('./compile_method');
  var compile_query_1 = $__require('./compile_query');
  var constants_1 = $__require('./constants');
  var util_2 = $__require('./util');
  var CompileNode = (function() {
    function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
      this.parent = parent;
      this.view = view;
      this.nodeIndex = nodeIndex;
      this.renderNode = renderNode;
      this.sourceAst = sourceAst;
    }
    CompileNode.prototype.isNull = function() {
      return lang_1.isBlank(this.renderNode);
    };
    CompileNode.prototype.isRootElement = function() {
      return this.view != this.parent.view;
    };
    return CompileNode;
  }());
  exports.CompileNode = CompileNode;
  var CompileElement = (function(_super) {
    __extends(CompileElement, _super);
    function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
      var _this = this;
      _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
      this.component = component;
      this._directives = _directives;
      this._resolvedProvidersArray = _resolvedProvidersArray;
      this.hasViewContainer = hasViewContainer;
      this.hasEmbeddedView = hasEmbeddedView;
      this._compViewExpr = null;
      this.instances = new compile_metadata_1.CompileIdentifierMap();
      this._queryCount = 0;
      this._queries = new compile_metadata_1.CompileIdentifierMap();
      this._componentConstructorViewQueryLists = [];
      this.contentNodesByNgContentIndex = null;
      this.referenceTokens = {};
      references.forEach(function(ref) {
        return _this.referenceTokens[ref.name] = ref.value;
      });
      this.elementRef = o.importExpr(identifiers_1.Identifiers.ElementRef).instantiate([this.renderNode]);
      this.instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.ElementRef), this.elementRef);
      this.injector = o.THIS_EXPR.callMethod('injector', [o.literal(this.nodeIndex)]);
      this.instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector), this.injector);
      this.instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.Renderer), o.THIS_EXPR.prop('renderer'));
      if (this.hasViewContainer || this.hasEmbeddedView || lang_1.isPresent(this.component)) {
        this._createAppElement();
      }
    }
    CompileElement.createNull = function() {
      return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
    };
    CompileElement.prototype._createAppElement = function() {
      var fieldName = "_appEl_" + this.nodeIndex;
      var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
      this.view.fields.push(new o.ClassField(fieldName, o.importType(identifiers_1.Identifiers.AppElement), [o.StmtModifier.Private]));
      var statement = o.THIS_EXPR.prop(fieldName).set(o.importExpr(identifiers_1.Identifiers.AppElement).instantiate([o.literal(this.nodeIndex), o.literal(parentNodeIndex), o.THIS_EXPR, this.renderNode])).toStmt();
      this.view.createMethod.addStmt(statement);
      this.appElement = o.THIS_EXPR.prop(fieldName);
      this.instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.AppElement), this.appElement);
    };
    CompileElement.prototype.createComponentFactoryResolver = function(entryComponents) {
      if (!entryComponents || entryComponents.length === 0) {
        return;
      }
      var createComponentFactoryResolverExpr = o.importExpr(identifiers_1.Identifiers.CodegenComponentFactoryResolver).instantiate([o.literalArr(entryComponents.map(function(entryComponent) {
        return o.importExpr(entryComponent);
      })), util_2.injectFromViewParentInjector(identifiers_1.identifierToken(identifiers_1.Identifiers.ComponentFactoryResolver), false)]);
      var provider = new compile_metadata_1.CompileProviderMetadata({
        token: identifiers_1.identifierToken(identifiers_1.Identifiers.ComponentFactoryResolver),
        useValue: createComponentFactoryResolverExpr
      });
      this._resolvedProvidersArray.unshift(new template_ast_1.ProviderAst(provider.token, false, true, [provider], template_ast_1.ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));
    };
    CompileElement.prototype.setComponentView = function(compViewExpr) {
      this._compViewExpr = compViewExpr;
      this.contentNodesByNgContentIndex = collection_1.ListWrapper.createFixedSize(this.component.template.ngContentSelectors.length);
      for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
        this.contentNodesByNgContentIndex[i] = [];
      }
    };
    CompileElement.prototype.setEmbeddedView = function(embeddedView) {
      this.embeddedView = embeddedView;
      if (lang_1.isPresent(embeddedView)) {
        var createTemplateRefExpr = o.importExpr(identifiers_1.Identifiers.TemplateRef_).instantiate([this.appElement, this.embeddedView.viewFactory]);
        var provider = new compile_metadata_1.CompileProviderMetadata({
          token: identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef),
          useValue: createTemplateRefExpr
        });
        this._resolvedProvidersArray.unshift(new template_ast_1.ProviderAst(provider.token, false, true, [provider], template_ast_1.ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));
      }
    };
    CompileElement.prototype.beforeChildren = function() {
      var _this = this;
      if (this.hasViewContainer) {
        this.instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef), this.appElement.prop('vcRef'));
      }
      this._resolvedProviders = new compile_metadata_1.CompileIdentifierMap();
      this._resolvedProvidersArray.forEach(function(provider) {
        return _this._resolvedProviders.add(provider.token, provider);
      });
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var providerValueExpressions = resolvedProvider.providers.map(function(provider) {
          if (lang_1.isPresent(provider.useExisting)) {
            return _this._getDependency(resolvedProvider.providerType, new compile_metadata_1.CompileDiDependencyMetadata({token: provider.useExisting}));
          } else if (lang_1.isPresent(provider.useFactory)) {
            var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
            var depsExpr = deps.map(function(dep) {
              return _this._getDependency(resolvedProvider.providerType, dep);
            });
            return o.importExpr(provider.useFactory).callFn(depsExpr);
          } else if (lang_1.isPresent(provider.useClass)) {
            var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
            var depsExpr = deps.map(function(dep) {
              return _this._getDependency(resolvedProvider.providerType, dep);
            });
            return o.importExpr(provider.useClass).instantiate(depsExpr, o.importType(provider.useClass));
          } else {
            return value_util_1.convertValueToOutputAst(provider.useValue);
          }
        });
        var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this.instances.size;
        var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
        _this.instances.add(resolvedProvider.token, instance);
      });
      for (var i = 0; i < this._directives.length; i++) {
        var directive = this._directives[i];
        var directiveInstance = this.instances.get(identifiers_1.identifierToken(directive.type));
        directive.queries.forEach(function(queryMeta) {
          _this._addQuery(queryMeta, directiveInstance);
        });
      }
      var queriesWithReads = [];
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
        collection_1.ListWrapper.addAll(queriesWithReads, queriesForProvider.map(function(query) {
          return new _QueryWithRead(query, resolvedProvider.token);
        }));
      });
      collection_1.StringMapWrapper.forEach(this.referenceTokens, function(_, varName) {
        var token = _this.referenceTokens[varName];
        var varValue;
        if (lang_1.isPresent(token)) {
          varValue = _this.instances.get(token);
        } else {
          varValue = _this.renderNode;
        }
        _this.view.locals.set(varName, varValue);
        var varToken = new compile_metadata_1.CompileTokenMetadata({value: varName});
        collection_1.ListWrapper.addAll(queriesWithReads, _this._getQueriesFor(varToken).map(function(query) {
          return new _QueryWithRead(query, varToken);
        }));
      });
      queriesWithReads.forEach(function(queryWithRead) {
        var value;
        if (lang_1.isPresent(queryWithRead.read.identifier)) {
          value = _this.instances.get(queryWithRead.read);
        } else {
          var token = _this.referenceTokens[queryWithRead.read.value];
          if (lang_1.isPresent(token)) {
            value = _this.instances.get(token);
          } else {
            value = _this.elementRef;
          }
        }
        if (lang_1.isPresent(value)) {
          queryWithRead.query.addValue(value, _this.view);
        }
      });
      if (lang_1.isPresent(this.component)) {
        var componentConstructorViewQueryList = lang_1.isPresent(this.component) ? o.literalArr(this._componentConstructorViewQueryLists) : o.NULL_EXPR;
        var compExpr = lang_1.isPresent(this.getComponent()) ? this.getComponent() : o.NULL_EXPR;
        this.view.createMethod.addStmt(this.appElement.callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr]).toStmt());
      }
    };
    CompileElement.prototype.afterChildren = function(childNodeCount) {
      var _this = this;
      this._resolvedProviders.values().forEach(function(resolvedProvider) {
        var providerExpr = _this.instances.get(resolvedProvider.token);
        var providerChildNodeCount = resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService ? 0 : childNodeCount;
        _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
      });
      this._queries.values().forEach(function(queries) {
        return queries.forEach(function(query) {
          return query.afterChildren(_this.view.createMethod, _this.view.updateContentQueriesMethod);
        });
      });
    };
    CompileElement.prototype.addContentNode = function(ngContentIndex, nodeExpr) {
      this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
    };
    CompileElement.prototype.getComponent = function() {
      return lang_1.isPresent(this.component) ? this.instances.get(identifiers_1.identifierToken(this.component.type)) : null;
    };
    CompileElement.prototype.getProviderTokens = function() {
      return this._resolvedProviders.values().map(function(resolvedProvider) {
        return util_1.createDiTokenExpression(resolvedProvider.token);
      });
    };
    CompileElement.prototype._getQueriesFor = function(token) {
      var result = [];
      var currentEl = this;
      var distance = 0;
      var queries;
      while (!currentEl.isNull()) {
        queries = currentEl._queries.get(token);
        if (lang_1.isPresent(queries)) {
          collection_1.ListWrapper.addAll(result, queries.filter(function(query) {
            return query.meta.descendants || distance <= 1;
          }));
        }
        if (currentEl._directives.length > 0) {
          distance++;
        }
        currentEl = currentEl.parent;
      }
      queries = this.view.componentView.viewQueries.get(token);
      if (lang_1.isPresent(queries)) {
        collection_1.ListWrapper.addAll(result, queries);
      }
      return result;
    };
    CompileElement.prototype._addQuery = function(queryMeta, directiveInstance) {
      var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
      var queryList = compile_query_1.createQueryList(queryMeta, directiveInstance, propName, this.view);
      var query = new compile_query_1.CompileQuery(queryMeta, queryList, directiveInstance, this.view);
      compile_query_1.addQueryToTokenMap(this._queries, query);
      return query;
    };
    CompileElement.prototype._getLocalDependency = function(requestingProviderType, dep) {
      var result = null;
      if (lang_1.isBlank(result) && lang_1.isPresent(dep.query)) {
        result = this._addQuery(dep.query, null).queryList;
      }
      if (lang_1.isBlank(result) && lang_1.isPresent(dep.viewQuery)) {
        result = compile_query_1.createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
        this._componentConstructorViewQueryLists.push(result);
      }
      if (lang_1.isPresent(dep.token)) {
        if (lang_1.isBlank(result)) {
          if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef))) {
            if (requestingProviderType === template_ast_1.ProviderAstType.Component) {
              return this._compViewExpr.prop('ref');
            } else {
              return util_2.getPropertyInView(o.THIS_EXPR.prop('ref'), this.view, this.view.componentView);
            }
          }
        }
        if (lang_1.isBlank(result)) {
          var resolvedProvider = this._resolvedProviders.get(dep.token);
          if (resolvedProvider && (requestingProviderType === template_ast_1.ProviderAstType.Directive || requestingProviderType === template_ast_1.ProviderAstType.PublicService) && resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService) {
            return null;
          }
          result = this.instances.get(dep.token);
        }
      }
      return result;
    };
    CompileElement.prototype._getDependency = function(requestingProviderType, dep) {
      var currElement = this;
      var result = null;
      if (dep.isValue) {
        result = o.literal(dep.value);
      }
      if (lang_1.isBlank(result) && !dep.isSkipSelf) {
        result = this._getLocalDependency(requestingProviderType, dep);
      }
      while (lang_1.isBlank(result) && !currElement.parent.isNull()) {
        currElement = currElement.parent;
        result = currElement._getLocalDependency(template_ast_1.ProviderAstType.PublicService, new compile_metadata_1.CompileDiDependencyMetadata({token: dep.token}));
      }
      if (lang_1.isBlank(result)) {
        result = util_2.injectFromViewParentInjector(dep.token, dep.isOptional);
      }
      if (lang_1.isBlank(result)) {
        result = o.NULL_EXPR;
      }
      return util_2.getPropertyInView(result, this.view, currElement.view);
    };
    return CompileElement;
  }(CompileNode));
  exports.CompileElement = CompileElement;
  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
    var indexCondition;
    if (childNodeCount > 0) {
      indexCondition = o.literal(nodeIndex).lowerEquals(constants_1.InjectMethodVars.requestNodeIndex).and(constants_1.InjectMethodVars.requestNodeIndex.lowerEquals(o.literal(nodeIndex + childNodeCount)));
    } else {
      indexCondition = o.literal(nodeIndex).identical(constants_1.InjectMethodVars.requestNodeIndex);
    }
    return new o.IfStmt(constants_1.InjectMethodVars.token.identical(util_1.createDiTokenExpression(provider.token)).and(indexCondition), [new o.ReturnStatement(providerExpr)]);
  }
  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
    var view = compileElement.view;
    var resolvedProviderValueExpr;
    var type;
    if (isMulti) {
      resolvedProviderValueExpr = o.literalArr(providerValueExpressions);
      type = new o.ArrayType(o.DYNAMIC_TYPE);
    } else {
      resolvedProviderValueExpr = providerValueExpressions[0];
      type = providerValueExpressions[0].type;
    }
    if (lang_1.isBlank(type)) {
      type = o.DYNAMIC_TYPE;
    }
    if (isEager) {
      view.fields.push(new o.ClassField(propName, type));
      view.createMethod.addStmt(o.THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
    } else {
      var internalField = "_" + propName;
      view.fields.push(new o.ClassField(internalField, type));
      var getter = new compile_method_1.CompileMethod(view);
      getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      getter.addStmt(new o.IfStmt(o.THIS_EXPR.prop(internalField).isBlank(), [o.THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
      getter.addStmt(new o.ReturnStatement(o.THIS_EXPR.prop(internalField)));
      view.getters.push(new o.ClassGetter(propName, getter.finish(), type));
    }
    return o.THIS_EXPR.prop(propName);
  }
  var _QueryWithRead = (function() {
    function _QueryWithRead(query, match) {
      this.query = query;
      this.read = lang_1.isPresent(query.meta.read) ? query.meta.read : match;
    }
    return _QueryWithRead;
  }());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_method.js", ["../facade/collection", "../facade/lang", "../output/output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var o = $__require('../output/output_ast');
  var _DebugState = (function() {
    function _DebugState(nodeIndex, sourceAst) {
      this.nodeIndex = nodeIndex;
      this.sourceAst = sourceAst;
    }
    return _DebugState;
  }());
  var NULL_DEBUG_STATE = new _DebugState(null, null);
  var CompileMethod = (function() {
    function CompileMethod(_view) {
      this._view = _view;
      this._newState = NULL_DEBUG_STATE;
      this._currState = NULL_DEBUG_STATE;
      this._bodyStatements = [];
      this._debugEnabled = this._view.genConfig.genDebugInfo;
    }
    CompileMethod.prototype._updateDebugContextIfNeeded = function() {
      if (this._newState.nodeIndex !== this._currState.nodeIndex || this._newState.sourceAst !== this._currState.sourceAst) {
        var expr = this._updateDebugContext(this._newState);
        if (lang_1.isPresent(expr)) {
          this._bodyStatements.push(expr.toStmt());
        }
      }
    };
    CompileMethod.prototype._updateDebugContext = function(newState) {
      this._currState = this._newState = newState;
      if (this._debugEnabled) {
        var sourceLocation = lang_1.isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
        return o.THIS_EXPR.callMethod('debug', [o.literal(newState.nodeIndex), lang_1.isPresent(sourceLocation) ? o.literal(sourceLocation.line) : o.NULL_EXPR, lang_1.isPresent(sourceLocation) ? o.literal(sourceLocation.col) : o.NULL_EXPR]);
      } else {
        return null;
      }
    };
    CompileMethod.prototype.resetDebugInfoExpr = function(nodeIndex, templateAst) {
      var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
      return lang_1.isPresent(res) ? res : o.NULL_EXPR;
    };
    CompileMethod.prototype.resetDebugInfo = function(nodeIndex, templateAst) {
      this._newState = new _DebugState(nodeIndex, templateAst);
    };
    CompileMethod.prototype.addStmt = function(stmt) {
      this._updateDebugContextIfNeeded();
      this._bodyStatements.push(stmt);
    };
    CompileMethod.prototype.addStmts = function(stmts) {
      this._updateDebugContextIfNeeded();
      collection_1.ListWrapper.addAll(this._bodyStatements, stmts);
    };
    CompileMethod.prototype.finish = function() {
      return this._bodyStatements;
    };
    CompileMethod.prototype.isEmpty = function() {
      return this._bodyStatements.length === 0;
    };
    return CompileMethod;
  }());
  exports.CompileMethod = CompileMethod;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_pipe.js", ["../facade/exceptions", "../facade/lang", "../identifiers", "../output/output_ast", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var util_1 = $__require('./util');
  var CompilePipe = (function() {
    function CompilePipe(view, meta) {
      var _this = this;
      this.view = view;
      this.meta = meta;
      this._purePipeProxyCount = 0;
      this.instance = o.THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
      var deps = this.meta.type.diDeps.map(function(diDep) {
        if (diDep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef))) {
          return util_1.getPropertyInView(o.THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
        }
        return util_1.injectFromViewParentInjector(diDep.token, false);
      });
      this.view.fields.push(new o.ClassField(this.instance.name, o.importType(this.meta.type)));
      this.view.createMethod.resetDebugInfo(null, null);
      this.view.createMethod.addStmt(o.THIS_EXPR.prop(this.instance.name).set(o.importExpr(this.meta.type).instantiate(deps)).toStmt());
    }
    CompilePipe.call = function(view, name, args) {
      var compView = view.componentView;
      var meta = _findPipeMeta(compView, name);
      var pipe;
      if (meta.pure) {
        pipe = compView.purePipes.get(name);
        if (lang_1.isBlank(pipe)) {
          pipe = new CompilePipe(compView, meta);
          compView.purePipes.set(name, pipe);
          compView.pipes.push(pipe);
        }
      } else {
        pipe = new CompilePipe(view, meta);
        view.pipes.push(pipe);
      }
      return pipe._call(view, args);
    };
    Object.defineProperty(CompilePipe.prototype, "pure", {
      get: function() {
        return this.meta.pure;
      },
      enumerable: true,
      configurable: true
    });
    CompilePipe.prototype._call = function(callingView, args) {
      if (this.meta.pure) {
        var purePipeProxyInstance = o.THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxyCount++);
        var pipeInstanceSeenFromPureProxy = util_1.getPropertyInView(this.instance, callingView, this.view);
        util_1.createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform').callMethod(o.BuiltinMethod.bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, callingView);
        return o.importExpr(identifiers_1.Identifiers.castByValue).callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')]).callFn(args);
      } else {
        return util_1.getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
      }
    };
    return CompilePipe;
  }());
  exports.CompilePipe = CompilePipe;
  function _findPipeMeta(view, name) {
    var pipeMeta = null;
    for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
      var localPipeMeta = view.pipeMetas[i];
      if (localPipeMeta.name == name) {
        pipeMeta = localPipeMeta;
        break;
      }
    }
    if (lang_1.isBlank(pipeMeta)) {
      throw new exceptions_1.BaseException("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
    }
    return pipeMeta;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_query.js", ["../facade/collection", "../facade/lang", "../identifiers", "../output/output_ast", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var util_1 = $__require('./util');
  var ViewQueryValues = (function() {
    function ViewQueryValues(view, values) {
      this.view = view;
      this.values = values;
    }
    return ViewQueryValues;
  }());
  var CompileQuery = (function() {
    function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
      this.meta = meta;
      this.queryList = queryList;
      this.ownerDirectiveExpression = ownerDirectiveExpression;
      this.view = view;
      this._values = new ViewQueryValues(view, []);
    }
    CompileQuery.prototype.addValue = function(value, view) {
      var currentView = view;
      var elPath = [];
      while (lang_1.isPresent(currentView) && currentView !== this.view) {
        var parentEl = currentView.declarationElement;
        elPath.unshift(parentEl);
        currentView = parentEl.view;
      }
      var queryListForDirtyExpr = util_1.getPropertyInView(this.queryList, view, this.view);
      var viewValues = this._values;
      elPath.forEach(function(el) {
        var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
        if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
          viewValues = last;
        } else {
          var newViewValues = new ViewQueryValues(el.embeddedView, []);
          viewValues.values.push(newViewValues);
          viewValues = newViewValues;
        }
      });
      viewValues.values.push(value);
      if (elPath.length > 0) {
        view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
      }
    };
    CompileQuery.prototype._isStatic = function() {
      return !this._values.values.some(function(value) {
        return value instanceof ViewQueryValues;
      });
    };
    CompileQuery.prototype.afterChildren = function(targetStaticMethod, targetDynamicMethod) {
      var values = createQueryValues(this._values);
      var updateStmts = [this.queryList.callMethod('reset', [o.literalArr(values)]).toStmt()];
      if (lang_1.isPresent(this.ownerDirectiveExpression)) {
        var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
        updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
      }
      if (!this.meta.first) {
        updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
      }
      if (this.meta.first && this._isStatic()) {
        targetStaticMethod.addStmts(updateStmts);
      } else {
        targetDynamicMethod.addStmt(new o.IfStmt(this.queryList.prop('dirty'), updateStmts));
      }
    };
    return CompileQuery;
  }());
  exports.CompileQuery = CompileQuery;
  function createQueryValues(viewValues) {
    return collection_1.ListWrapper.flatten(viewValues.values.map(function(entry) {
      if (entry instanceof ViewQueryValues) {
        return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
      } else {
        return entry;
      }
    }));
  }
  function mapNestedViews(declarationAppElement, view, expressions) {
    var adjustedExpressions = expressions.map(function(expr) {
      return o.replaceVarInExpression(o.THIS_EXPR.name, o.variable('nestedView'), expr);
    });
    return declarationAppElement.callMethod('mapNestedViews', [o.variable(view.className), o.fn([new o.FnParam('nestedView', view.classType)], [new o.ReturnStatement(o.literalArr(adjustedExpressions))], o.DYNAMIC_TYPE)]);
  }
  function createQueryList(query, directiveInstance, propertyName, compileView) {
    compileView.fields.push(new o.ClassField(propertyName, o.importType(identifiers_1.Identifiers.QueryList, [o.DYNAMIC_TYPE])));
    var expr = o.THIS_EXPR.prop(propertyName);
    compileView.createMethod.addStmt(o.THIS_EXPR.prop(propertyName).set(o.importExpr(identifiers_1.Identifiers.QueryList, [o.DYNAMIC_TYPE]).instantiate([])).toStmt());
    return expr;
  }
  exports.createQueryList = createQueryList;
  function addQueryToTokenMap(map, query) {
    query.meta.selectors.forEach(function(selector) {
      var entry = map.get(selector);
      if (lang_1.isBlank(entry)) {
        entry = [];
        map.add(selector, entry);
      }
      entry.push(query);
    });
  }
  exports.addQueryToTokenMap = addQueryToTokenMap;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/compile_view.js", ["../../core_private", "../compile_metadata", "../facade/collection", "../facade/lang", "../identifiers", "../output/output_ast", "./compile_method", "./compile_pipe", "./compile_query", "./constants", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_private_1 = $__require('../../core_private');
  var compile_metadata_1 = $__require('../compile_metadata');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var compile_method_1 = $__require('./compile_method');
  var compile_pipe_1 = $__require('./compile_pipe');
  var compile_query_1 = $__require('./compile_query');
  var constants_1 = $__require('./constants');
  var util_1 = $__require('./util');
  var CompileView = (function() {
    function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {
      var _this = this;
      this.component = component;
      this.genConfig = genConfig;
      this.pipeMetas = pipeMetas;
      this.styles = styles;
      this.animations = animations;
      this.viewIndex = viewIndex;
      this.declarationElement = declarationElement;
      this.templateVariableBindings = templateVariableBindings;
      this.nodes = [];
      this.rootNodesOrAppElements = [];
      this.bindings = [];
      this.classStatements = [];
      this.eventHandlerMethods = [];
      this.fields = [];
      this.getters = [];
      this.disposables = [];
      this.subscriptions = [];
      this.purePipes = new Map();
      this.pipes = [];
      this.locals = new Map();
      this.literalArrayCount = 0;
      this.literalMapCount = 0;
      this.pipeCount = 0;
      this.createMethod = new compile_method_1.CompileMethod(this);
      this.injectorGetMethod = new compile_method_1.CompileMethod(this);
      this.updateContentQueriesMethod = new compile_method_1.CompileMethod(this);
      this.dirtyParentQueriesMethod = new compile_method_1.CompileMethod(this);
      this.updateViewQueriesMethod = new compile_method_1.CompileMethod(this);
      this.detectChangesInInputsMethod = new compile_method_1.CompileMethod(this);
      this.detectChangesRenderPropertiesMethod = new compile_method_1.CompileMethod(this);
      this.afterContentLifecycleCallbacksMethod = new compile_method_1.CompileMethod(this);
      this.afterViewLifecycleCallbacksMethod = new compile_method_1.CompileMethod(this);
      this.destroyMethod = new compile_method_1.CompileMethod(this);
      this.detachMethod = new compile_method_1.CompileMethod(this);
      this.viewType = getViewType(component, viewIndex);
      this.className = "_View_" + component.type.name + viewIndex;
      this.classType = o.importType(new compile_metadata_1.CompileIdentifierMetadata({name: this.className}));
      this.viewFactory = o.variable(util_1.getViewFactoryName(component, viewIndex));
      if (this.viewType === core_private_1.ViewType.COMPONENT || this.viewType === core_private_1.ViewType.HOST) {
        this.componentView = this;
      } else {
        this.componentView = this.declarationElement.view.componentView;
      }
      this.componentContext = util_1.getPropertyInView(o.THIS_EXPR.prop('context'), this, this.componentView);
      var viewQueries = new compile_metadata_1.CompileIdentifierMap();
      if (this.viewType === core_private_1.ViewType.COMPONENT) {
        var directiveInstance = o.THIS_EXPR.prop('context');
        collection_1.ListWrapper.forEachWithIndex(this.component.viewQueries, function(queryMeta, queryIndex) {
          var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
          var queryList = compile_query_1.createQueryList(queryMeta, directiveInstance, propName, _this);
          var query = new compile_query_1.CompileQuery(queryMeta, queryList, directiveInstance, _this);
          compile_query_1.addQueryToTokenMap(viewQueries, query);
        });
        var constructorViewQueryCount = 0;
        this.component.type.diDeps.forEach(function(dep) {
          if (lang_1.isPresent(dep.viewQuery)) {
            var queryList = o.THIS_EXPR.prop('declarationAppElement').prop('componentConstructorViewQueries').key(o.literal(constructorViewQueryCount++));
            var query = new compile_query_1.CompileQuery(dep.viewQuery, queryList, null, _this);
            compile_query_1.addQueryToTokenMap(viewQueries, query);
          }
        });
      }
      this.viewQueries = viewQueries;
      templateVariableBindings.forEach(function(entry) {
        _this.locals.set(entry[1], o.THIS_EXPR.prop('context').prop(entry[0]));
      });
      if (!this.declarationElement.isNull()) {
        this.declarationElement.setEmbeddedView(this);
      }
    }
    CompileView.prototype.callPipe = function(name, input, args) {
      return compile_pipe_1.CompilePipe.call(this, name, [input].concat(args));
    };
    CompileView.prototype.getLocal = function(name) {
      if (name == constants_1.EventHandlerVars.event.name) {
        return constants_1.EventHandlerVars.event;
      }
      var currView = this;
      var result = currView.locals.get(name);
      while (lang_1.isBlank(result) && lang_1.isPresent(currView.declarationElement.view)) {
        currView = currView.declarationElement.view;
        result = currView.locals.get(name);
      }
      if (lang_1.isPresent(result)) {
        return util_1.getPropertyInView(result, this, currView);
      } else {
        return null;
      }
    };
    CompileView.prototype.createLiteralArray = function(values) {
      if (values.length === 0) {
        return o.importExpr(identifiers_1.Identifiers.EMPTY_ARRAY);
      }
      var proxyExpr = o.THIS_EXPR.prop("_arr_" + this.literalArrayCount++);
      var proxyParams = [];
      var proxyReturnEntries = [];
      for (var i = 0; i < values.length; i++) {
        var paramName = "p" + i;
        proxyParams.push(new o.FnParam(paramName));
        proxyReturnEntries.push(o.variable(paramName));
      }
      util_1.createPureProxy(o.fn(proxyParams, [new o.ReturnStatement(o.literalArr(proxyReturnEntries))], new o.ArrayType(o.DYNAMIC_TYPE)), values.length, proxyExpr, this);
      return proxyExpr.callFn(values);
    };
    CompileView.prototype.createLiteralMap = function(entries) {
      if (entries.length === 0) {
        return o.importExpr(identifiers_1.Identifiers.EMPTY_MAP);
      }
      var proxyExpr = o.THIS_EXPR.prop("_map_" + this.literalMapCount++);
      var proxyParams = [];
      var proxyReturnEntries = [];
      var values = [];
      for (var i = 0; i < entries.length; i++) {
        var paramName = "p" + i;
        proxyParams.push(new o.FnParam(paramName));
        proxyReturnEntries.push([entries[i][0], o.variable(paramName)]);
        values.push(entries[i][1]);
      }
      util_1.createPureProxy(o.fn(proxyParams, [new o.ReturnStatement(o.literalMap(proxyReturnEntries))], new o.MapType(o.DYNAMIC_TYPE)), entries.length, proxyExpr, this);
      return proxyExpr.callFn(values);
    };
    CompileView.prototype.afterNodes = function() {
      var _this = this;
      this.viewQueries.values().forEach(function(queries) {
        return queries.forEach(function(query) {
          return query.afterChildren(_this.createMethod, _this.updateViewQueriesMethod);
        });
      });
    };
    return CompileView;
  }());
  exports.CompileView = CompileView;
  function getViewType(component, embeddedTemplateIndex) {
    if (embeddedTemplateIndex > 0) {
      return core_private_1.ViewType.EMBEDDED;
    } else if (component.type.isHost) {
      return core_private_1.ViewType.HOST;
    } else {
      return core_private_1.ViewType.COMPONENT;
    }
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/constants.js", ["@angular/core", "../../core_private", "../compile_metadata", "../facade/lang", "../identifiers", "../output/output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../core_private');
  var compile_metadata_1 = $__require('../compile_metadata');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  function _enumExpression(classIdentifier, value) {
    if (lang_1.isBlank(value))
      return o.NULL_EXPR;
    var name = lang_1.resolveEnumToken(classIdentifier.runtime, value);
    return o.importExpr(new compile_metadata_1.CompileIdentifierMetadata({
      name: classIdentifier.name + "." + name,
      moduleUrl: classIdentifier.moduleUrl,
      runtime: value
    }));
  }
  var ViewTypeEnum = (function() {
    function ViewTypeEnum() {}
    ViewTypeEnum.fromValue = function(value) {
      return _enumExpression(identifiers_1.Identifiers.ViewType, value);
    };
    ViewTypeEnum.HOST = ViewTypeEnum.fromValue(core_private_1.ViewType.HOST);
    ViewTypeEnum.COMPONENT = ViewTypeEnum.fromValue(core_private_1.ViewType.COMPONENT);
    ViewTypeEnum.EMBEDDED = ViewTypeEnum.fromValue(core_private_1.ViewType.EMBEDDED);
    return ViewTypeEnum;
  }());
  exports.ViewTypeEnum = ViewTypeEnum;
  var ViewEncapsulationEnum = (function() {
    function ViewEncapsulationEnum() {}
    ViewEncapsulationEnum.fromValue = function(value) {
      return _enumExpression(identifiers_1.Identifiers.ViewEncapsulation, value);
    };
    ViewEncapsulationEnum.Emulated = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.Emulated);
    ViewEncapsulationEnum.Native = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.Native);
    ViewEncapsulationEnum.None = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.None);
    return ViewEncapsulationEnum;
  }());
  exports.ViewEncapsulationEnum = ViewEncapsulationEnum;
  var ChangeDetectionStrategyEnum = (function() {
    function ChangeDetectionStrategyEnum() {}
    ChangeDetectionStrategyEnum.fromValue = function(value) {
      return _enumExpression(identifiers_1.Identifiers.ChangeDetectionStrategy, value);
    };
    ChangeDetectionStrategyEnum.OnPush = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.OnPush);
    ChangeDetectionStrategyEnum.Default = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.Default);
    return ChangeDetectionStrategyEnum;
  }());
  exports.ChangeDetectionStrategyEnum = ChangeDetectionStrategyEnum;
  var ChangeDetectorStatusEnum = (function() {
    function ChangeDetectorStatusEnum() {}
    ChangeDetectorStatusEnum.fromValue = function(value) {
      return _enumExpression(identifiers_1.Identifiers.ChangeDetectorStatus, value);
    };
    ChangeDetectorStatusEnum.CheckOnce = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.CheckOnce);
    ChangeDetectorStatusEnum.Checked = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.Checked);
    ChangeDetectorStatusEnum.CheckAlways = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.CheckAlways);
    ChangeDetectorStatusEnum.Detached = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.Detached);
    ChangeDetectorStatusEnum.Errored = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.Errored);
    ChangeDetectorStatusEnum.Destroyed = ChangeDetectorStatusEnum.fromValue(core_private_1.ChangeDetectorStatus.Destroyed);
    return ChangeDetectorStatusEnum;
  }());
  exports.ChangeDetectorStatusEnum = ChangeDetectorStatusEnum;
  var ViewConstructorVars = (function() {
    function ViewConstructorVars() {}
    ViewConstructorVars.viewUtils = o.variable('viewUtils');
    ViewConstructorVars.parentInjector = o.variable('parentInjector');
    ViewConstructorVars.declarationEl = o.variable('declarationEl');
    return ViewConstructorVars;
  }());
  exports.ViewConstructorVars = ViewConstructorVars;
  var ViewProperties = (function() {
    function ViewProperties() {}
    ViewProperties.renderer = o.THIS_EXPR.prop('renderer');
    ViewProperties.projectableNodes = o.THIS_EXPR.prop('projectableNodes');
    ViewProperties.viewUtils = o.THIS_EXPR.prop('viewUtils');
    return ViewProperties;
  }());
  exports.ViewProperties = ViewProperties;
  var EventHandlerVars = (function() {
    function EventHandlerVars() {}
    EventHandlerVars.event = o.variable('$event');
    return EventHandlerVars;
  }());
  exports.EventHandlerVars = EventHandlerVars;
  var InjectMethodVars = (function() {
    function InjectMethodVars() {}
    InjectMethodVars.token = o.variable('token');
    InjectMethodVars.requestNodeIndex = o.variable('requestNodeIndex');
    InjectMethodVars.notFoundResult = o.variable('notFoundResult');
    return InjectMethodVars;
  }());
  exports.InjectMethodVars = InjectMethodVars;
  var DetectChangesVars = (function() {
    function DetectChangesVars() {}
    DetectChangesVars.throwOnChange = o.variable("throwOnChange");
    DetectChangesVars.changes = o.variable("changes");
    DetectChangesVars.changed = o.variable("changed");
    DetectChangesVars.valUnwrapper = o.variable("valUnwrapper");
    return DetectChangesVars;
  }());
  exports.DetectChangesVars = DetectChangesVars;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/core_private.js", ["@angular/core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  exports.isDefaultChangeDetectionStrategy = core_1.__core_private__.isDefaultChangeDetectionStrategy;
  exports.ChangeDetectorStatus = core_1.__core_private__.ChangeDetectorStatus;
  exports.CHANGE_DETECTION_STRATEGY_VALUES = core_1.__core_private__.CHANGE_DETECTION_STRATEGY_VALUES;
  exports.constructDependencies = core_1.__core_private__.constructDependencies;
  exports.LifecycleHooks = core_1.__core_private__.LifecycleHooks;
  exports.LIFECYCLE_HOOKS_VALUES = core_1.__core_private__.LIFECYCLE_HOOKS_VALUES;
  exports.ReflectorReader = core_1.__core_private__.ReflectorReader;
  exports.AppElement = core_1.__core_private__.AppElement;
  exports.CodegenComponentFactoryResolver = core_1.__core_private__.CodegenComponentFactoryResolver;
  exports.AppView = core_1.__core_private__.AppView;
  exports.DebugAppView = core_1.__core_private__.DebugAppView;
  exports.NgModuleInjector = core_1.__core_private__.NgModuleInjector;
  exports.ViewType = core_1.__core_private__.ViewType;
  exports.MAX_INTERPOLATION_VALUES = core_1.__core_private__.MAX_INTERPOLATION_VALUES;
  exports.checkBinding = core_1.__core_private__.checkBinding;
  exports.flattenNestedViewRenderNodes = core_1.__core_private__.flattenNestedViewRenderNodes;
  exports.interpolate = core_1.__core_private__.interpolate;
  exports.ViewUtils = core_1.__core_private__.ViewUtils;
  exports.VIEW_ENCAPSULATION_VALUES = core_1.__core_private__.VIEW_ENCAPSULATION_VALUES;
  exports.DebugContext = core_1.__core_private__.DebugContext;
  exports.StaticNodeDebugInfo = core_1.__core_private__.StaticNodeDebugInfo;
  exports.devModeEqual = core_1.__core_private__.devModeEqual;
  exports.UNINITIALIZED = core_1.__core_private__.UNINITIALIZED;
  exports.ValueUnwrapper = core_1.__core_private__.ValueUnwrapper;
  exports.TemplateRef_ = core_1.__core_private__.TemplateRef_;
  exports.RenderDebugInfo = core_1.__core_private__.RenderDebugInfo;
  exports.createProvider = core_1.__core_private__.createProvider;
  exports.isProviderLiteral = core_1.__core_private__.isProviderLiteral;
  exports.EMPTY_ARRAY = core_1.__core_private__.EMPTY_ARRAY;
  exports.EMPTY_MAP = core_1.__core_private__.EMPTY_MAP;
  exports.pureProxy1 = core_1.__core_private__.pureProxy1;
  exports.pureProxy2 = core_1.__core_private__.pureProxy2;
  exports.pureProxy3 = core_1.__core_private__.pureProxy3;
  exports.pureProxy4 = core_1.__core_private__.pureProxy4;
  exports.pureProxy5 = core_1.__core_private__.pureProxy5;
  exports.pureProxy6 = core_1.__core_private__.pureProxy6;
  exports.pureProxy7 = core_1.__core_private__.pureProxy7;
  exports.pureProxy8 = core_1.__core_private__.pureProxy8;
  exports.pureProxy9 = core_1.__core_private__.pureProxy9;
  exports.pureProxy10 = core_1.__core_private__.pureProxy10;
  exports.castByValue = core_1.__core_private__.castByValue;
  exports.Console = core_1.__core_private__.Console;
  exports.reflector = core_1.__core_private__.reflector;
  exports.Reflector = core_1.__core_private__.Reflector;
  exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;
  exports.NoOpAnimationPlayer = core_1.__core_private__.NoOpAnimationPlayer;
  exports.AnimationPlayer = core_1.__core_private__.AnimationPlayer;
  exports.AnimationSequencePlayer = core_1.__core_private__.AnimationSequencePlayer;
  exports.AnimationGroupPlayer = core_1.__core_private__.AnimationGroupPlayer;
  exports.AnimationKeyframe = core_1.__core_private__.AnimationKeyframe;
  exports.AnimationStyles = core_1.__core_private__.AnimationStyles;
  exports.ANY_STATE = core_1.__core_private__.ANY_STATE;
  exports.DEFAULT_STATE = core_1.__core_private__.DEFAULT_STATE;
  exports.EMPTY_STATE = core_1.__core_private__.EMPTY_STATE;
  exports.FILL_STYLE_FLAG = core_1.__core_private__.FILL_STYLE_FLAG;
  exports.prepareFinalAnimationStyles = core_1.__core_private__.prepareFinalAnimationStyles;
  exports.balanceAnimationKeyframes = core_1.__core_private__.balanceAnimationKeyframes;
  exports.flattenStyles = core_1.__core_private__.flattenStyles;
  exports.clearStyles = core_1.__core_private__.clearStyles;
  exports.collectAndResolveStyles = core_1.__core_private__.collectAndResolveStyles;
  exports.renderStyles = core_1.__core_private__.renderStyles;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/base_wrapped_exception.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  exports.BaseWrappedException = BaseWrappedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/exception_handler.js", ["./base_wrapped_exception", "./collection", "./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var collection_1 = $__require('./collection');
  var lang_1 = $__require('./lang');
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join('\n');
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
        this._logger.logError('STACKTRACE:');
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (lang_1.isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (lang_1.isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (lang_1.isPresent(originalStack)) {
        this._logger.logError('ORIGINAL STACKTRACE:');
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (lang_1.isPresent(context)) {
        this._logger.logError('ERROR CONTEXT:');
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
          return null;
        return lang_1.isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  exports.ExceptionHandler = ExceptionHandler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/exceptions.js", ["./base_wrapped_exception", "./exception_handler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var exception_handler_1 = $__require('./exception_handler');
  var exception_handler_2 = $__require('./exception_handler');
  exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = '--';
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  exports.BaseException = BaseException;
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return exception_handler_1.ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(base_wrapped_exception_1.BaseWrappedException));
  exports.WrappedException = WrappedException;
  function makeTypeError(message) {
    return new TypeError(message);
  }
  exports.makeTypeError = makeTypeError;
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  exports.unimplemented = unimplemented;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/selector.js", ["./facade/collection", "./facade/exceptions", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var _EMPTY_ATTR_VALUE = '';
  var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)', 'g');
  var CssSelector = (function() {
    function CssSelector() {
      this.element = null;
      this.classNames = [];
      this.attrs = [];
      this.notSelectors = [];
    }
    CssSelector.parse = function(selector) {
      var results = [];
      var _addResult = function(res, cssSel) {
        if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) && collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {
          cssSel.element = '*';
        }
        res.push(cssSel);
      };
      var cssSelector = new CssSelector();
      var match;
      var current = cssSelector;
      var inNot = false;
      _SELECTOR_REGEXP.lastIndex = 0;
      while (lang_1.isPresent(match = _SELECTOR_REGEXP.exec(selector))) {
        if (lang_1.isPresent(match[1])) {
          if (inNot) {
            throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');
          }
          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }
        if (lang_1.isPresent(match[2])) {
          current.setElement(match[2]);
        }
        if (lang_1.isPresent(match[3])) {
          current.addClassName(match[3]);
        }
        if (lang_1.isPresent(match[4])) {
          current.addAttribute(match[4], match[5]);
        }
        if (lang_1.isPresent(match[6])) {
          inNot = false;
          current = cssSelector;
        }
        if (lang_1.isPresent(match[7])) {
          if (inNot) {
            throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');
          }
          _addResult(results, cssSelector);
          cssSelector = current = new CssSelector();
        }
      }
      _addResult(results, cssSelector);
      return results;
    };
    CssSelector.prototype.isElementSelector = function() {
      return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) && collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
    };
    CssSelector.prototype.setElement = function(element) {
      if (element === void 0) {
        element = null;
      }
      this.element = element;
    };
    CssSelector.prototype.getMatchingElementTemplate = function() {
      var tagName = lang_1.isPresent(this.element) ? this.element : 'div';
      var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
      var attrs = '';
      for (var i = 0; i < this.attrs.length; i += 2) {
        var attrName = this.attrs[i];
        var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
        attrs += " " + attrName + attrValue;
      }
      return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function(name, value) {
      if (value === void 0) {
        value = _EMPTY_ATTR_VALUE;
      }
      this.attrs.push(name);
      if (lang_1.isPresent(value)) {
        value = value.toLowerCase();
      } else {
        value = _EMPTY_ATTR_VALUE;
      }
      this.attrs.push(value);
    };
    CssSelector.prototype.addClassName = function(name) {
      this.classNames.push(name.toLowerCase());
    };
    CssSelector.prototype.toString = function() {
      var res = '';
      if (lang_1.isPresent(this.element)) {
        res += this.element;
      }
      if (lang_1.isPresent(this.classNames)) {
        for (var i = 0; i < this.classNames.length; i++) {
          res += '.' + this.classNames[i];
        }
      }
      if (lang_1.isPresent(this.attrs)) {
        for (var i = 0; i < this.attrs.length; ) {
          var attrName = this.attrs[i++];
          var attrValue = this.attrs[i++];
          res += '[' + attrName;
          if (attrValue.length > 0) {
            res += '=' + attrValue;
          }
          res += ']';
        }
      }
      this.notSelectors.forEach(function(notSelector) {
        return res += ":not(" + notSelector + ")";
      });
      return res;
    };
    return CssSelector;
  }());
  exports.CssSelector = CssSelector;
  var SelectorMatcher = (function() {
    function SelectorMatcher() {
      this._elementMap = new Map();
      this._elementPartialMap = new Map();
      this._classMap = new Map();
      this._classPartialMap = new Map();
      this._attrValueMap = new Map();
      this._attrValuePartialMap = new Map();
      this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function(notSelectors) {
      var notMatcher = new SelectorMatcher();
      notMatcher.addSelectables(notSelectors, null);
      return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function(cssSelectors, callbackCtxt) {
      var listContext = null;
      if (cssSelectors.length > 1) {
        listContext = new SelectorListContext(cssSelectors);
        this._listContexts.push(listContext);
      }
      for (var i = 0; i < cssSelectors.length; i++) {
        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
      }
    };
    SelectorMatcher.prototype._addSelectable = function(cssSelector, callbackCtxt, listContext) {
      var matcher = this;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
      if (lang_1.isPresent(element)) {
        var isTerminal = attrs.length === 0 && classNames.length === 0;
        if (isTerminal) {
          this._addTerminal(matcher._elementMap, element, selectable);
        } else {
          matcher = this._addPartial(matcher._elementPartialMap, element);
        }
      }
      if (lang_1.isPresent(classNames)) {
        for (var index = 0; index < classNames.length; index++) {
          var isTerminal = attrs.length === 0 && index === classNames.length - 1;
          var className = classNames[index];
          if (isTerminal) {
            this._addTerminal(matcher._classMap, className, selectable);
          } else {
            matcher = this._addPartial(matcher._classPartialMap, className);
          }
        }
      }
      if (lang_1.isPresent(attrs)) {
        for (var index = 0; index < attrs.length; ) {
          var isTerminal = index === attrs.length - 2;
          var attrName = attrs[index++];
          var attrValue = attrs[index++];
          if (isTerminal) {
            var terminalMap = matcher._attrValueMap;
            var terminalValuesMap = terminalMap.get(attrName);
            if (lang_1.isBlank(terminalValuesMap)) {
              terminalValuesMap = new Map();
              terminalMap.set(attrName, terminalValuesMap);
            }
            this._addTerminal(terminalValuesMap, attrValue, selectable);
          } else {
            var parttialMap = matcher._attrValuePartialMap;
            var partialValuesMap = parttialMap.get(attrName);
            if (lang_1.isBlank(partialValuesMap)) {
              partialValuesMap = new Map();
              parttialMap.set(attrName, partialValuesMap);
            }
            matcher = this._addPartial(partialValuesMap, attrValue);
          }
        }
      }
    };
    SelectorMatcher.prototype._addTerminal = function(map, name, selectable) {
      var terminalList = map.get(name);
      if (lang_1.isBlank(terminalList)) {
        terminalList = [];
        map.set(name, terminalList);
      }
      terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function(map, name) {
      var matcher = map.get(name);
      if (lang_1.isBlank(matcher)) {
        matcher = new SelectorMatcher();
        map.set(name, matcher);
      }
      return matcher;
    };
    SelectorMatcher.prototype.match = function(cssSelector, matchedCallback) {
      var result = false;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      for (var i = 0; i < this._listContexts.length; i++) {
        this._listContexts[i].alreadyMatched = false;
      }
      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
      if (lang_1.isPresent(classNames)) {
        for (var index = 0; index < classNames.length; index++) {
          var className = classNames[index];
          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
        }
      }
      if (lang_1.isPresent(attrs)) {
        for (var index = 0; index < attrs.length; ) {
          var attrName = attrs[index++];
          var attrValue = attrs[index++];
          var terminalValuesMap = this._attrValueMap.get(attrName);
          if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
            result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
          }
          result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
          var partialValuesMap = this._attrValuePartialMap.get(attrName);
          if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
            result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
          }
          result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
        }
      }
      return result;
    };
    SelectorMatcher.prototype._matchTerminal = function(map, name, cssSelector, matchedCallback) {
      if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
        return false;
      }
      var selectables = map.get(name);
      var starSelectables = map.get('*');
      if (lang_1.isPresent(starSelectables)) {
        selectables = selectables.concat(starSelectables);
      }
      if (lang_1.isBlank(selectables)) {
        return false;
      }
      var selectable;
      var result = false;
      for (var index = 0; index < selectables.length; index++) {
        selectable = selectables[index];
        result = selectable.finalize(cssSelector, matchedCallback) || result;
      }
      return result;
    };
    SelectorMatcher.prototype._matchPartial = function(map, name, cssSelector, matchedCallback) {
      if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
        return false;
      }
      var nestedSelector = map.get(name);
      if (lang_1.isBlank(nestedSelector)) {
        return false;
      }
      return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
  }());
  exports.SelectorMatcher = SelectorMatcher;
  var SelectorListContext = (function() {
    function SelectorListContext(selectors) {
      this.selectors = selectors;
      this.alreadyMatched = false;
    }
    return SelectorListContext;
  }());
  exports.SelectorListContext = SelectorListContext;
  var SelectorContext = (function() {
    function SelectorContext(selector, cbContext, listContext) {
      this.selector = selector;
      this.cbContext = cbContext;
      this.listContext = listContext;
      this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function(cssSelector, callback) {
      var result = true;
      if (this.notSelectors.length > 0 && (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
        result = !notMatcher.match(cssSelector, null);
      }
      if (result && lang_1.isPresent(callback) && (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
        if (lang_1.isPresent(this.listContext)) {
          this.listContext.alreadyMatched = true;
        }
        callback(this.selector, this.cbContext);
      }
      return result;
    };
    return SelectorContext;
  }());
  exports.SelectorContext = SelectorContext;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/url_resolver.js", ["@angular/core", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('./facade/lang');
  var _ASSET_SCHEME = 'asset:';
  function createUrlResolverWithoutPackagePrefix() {
    return new UrlResolver();
  }
  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
  function createOfflineCompileUrlResolver() {
    return new UrlResolver(_ASSET_SCHEME);
  }
  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = {
    provide: core_1.PACKAGE_ROOT_URL,
    useValue: '/'
  };
  var UrlResolver = (function() {
    function UrlResolver(_packagePrefix) {
      if (_packagePrefix === void 0) {
        _packagePrefix = null;
      }
      this._packagePrefix = _packagePrefix;
    }
    UrlResolver.prototype.resolve = function(baseUrl, url) {
      var resolvedUrl = url;
      if (lang_1.isPresent(baseUrl) && baseUrl.length > 0) {
        resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
      }
      var resolvedParts = _split(resolvedUrl);
      var prefix = this._packagePrefix;
      if (lang_1.isPresent(prefix) && lang_1.isPresent(resolvedParts) && resolvedParts[_ComponentIndex.Scheme] == 'package') {
        var path = resolvedParts[_ComponentIndex.Path];
        if (this._packagePrefix === _ASSET_SCHEME) {
          var pathSegements = path.split(/\//);
          resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
        } else {
          prefix = lang_1.StringWrapper.stripRight(prefix, '/');
          path = lang_1.StringWrapper.stripLeft(path, '/');
          return prefix + "/" + path;
        }
      }
      return resolvedUrl;
    };
    UrlResolver.decorators = [{type: core_1.Injectable}];
    UrlResolver.ctorParameters = [{
      type: undefined,
      decorators: [{
        type: core_1.Inject,
        args: [core_1.PACKAGE_ROOT_URL]
      }]
    }];
    return UrlResolver;
  }());
  exports.UrlResolver = UrlResolver;
  function getUrlScheme(url) {
    var match = _split(url);
    return (match && match[_ComponentIndex.Scheme]) || '';
  }
  exports.getUrlScheme = getUrlScheme;
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (lang_1.isPresent(opt_scheme)) {
      out.push(opt_scheme + ':');
    }
    if (lang_1.isPresent(opt_domain)) {
      out.push('//');
      if (lang_1.isPresent(opt_userInfo)) {
        out.push(opt_userInfo + '@');
      }
      out.push(opt_domain);
      if (lang_1.isPresent(opt_port)) {
        out.push(':' + opt_port);
      }
    }
    if (lang_1.isPresent(opt_path)) {
      out.push(opt_path);
    }
    if (lang_1.isPresent(opt_queryData)) {
      out.push('?' + opt_queryData);
    }
    if (lang_1.isPresent(opt_fragment)) {
      out.push('#' + opt_fragment);
    }
    return out.join('');
  }
  var _splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var _ComponentIndex;
  (function(_ComponentIndex) {
    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  function _split(uri) {
    return uri.match(_splitRe);
  }
  function _removeDotSegments(path) {
    if (path == '/')
      return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length > 0) {
            out.pop();
          } else {
            up++;
          }
          break;
        default:
          out.push(segment);
      }
    }
    if (leadingSlash == '') {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {
      return _joinAndCanonicalizePath(parts);
    } else {
      parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
      if (lang_1.isBlank(parts[i])) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
      return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (lang_1.isBlank(path))
      path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/compile_metadata.js", ["@angular/core", "../core_private", "./facade/collection", "./facade/exceptions", "./facade/lang", "./selector", "./url_resolver", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var collection_1 = $__require('./facade/collection');
  var exceptions_1 = $__require('./facade/exceptions');
  var lang_1 = $__require('./facade/lang');
  var selector_1 = $__require('./selector');
  var url_resolver_1 = $__require('./url_resolver');
  var util_1 = $__require('./util');
  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  var UNDEFINED = new Object();
  var CompileMetadataWithIdentifier = (function() {
    function CompileMetadataWithIdentifier() {}
    Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileMetadataWithIdentifier.prototype, "runtimeCacheKey", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileMetadataWithIdentifier.prototype, "assetCacheKey", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    CompileMetadataWithIdentifier.prototype.equalsTo = function(id2) {
      return exceptions_1.unimplemented();
    };
    return CompileMetadataWithIdentifier;
  }());
  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
  var CompileAnimationEntryMetadata = (function() {
    function CompileAnimationEntryMetadata(name, definitions) {
      if (name === void 0) {
        name = null;
      }
      if (definitions === void 0) {
        definitions = null;
      }
      this.name = name;
      this.definitions = definitions;
    }
    return CompileAnimationEntryMetadata;
  }());
  exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;
  var CompileAnimationStateMetadata = (function() {
    function CompileAnimationStateMetadata() {}
    return CompileAnimationStateMetadata;
  }());
  exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;
  var CompileAnimationStateDeclarationMetadata = (function(_super) {
    __extends(CompileAnimationStateDeclarationMetadata, _super);
    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
      _super.call(this);
      this.stateNameExpr = stateNameExpr;
      this.styles = styles;
    }
    return CompileAnimationStateDeclarationMetadata;
  }(CompileAnimationStateMetadata));
  exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;
  var CompileAnimationStateTransitionMetadata = (function(_super) {
    __extends(CompileAnimationStateTransitionMetadata, _super);
    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
      _super.call(this);
      this.stateChangeExpr = stateChangeExpr;
      this.steps = steps;
    }
    return CompileAnimationStateTransitionMetadata;
  }(CompileAnimationStateMetadata));
  exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;
  var CompileAnimationMetadata = (function() {
    function CompileAnimationMetadata() {}
    return CompileAnimationMetadata;
  }());
  exports.CompileAnimationMetadata = CompileAnimationMetadata;
  var CompileAnimationKeyframesSequenceMetadata = (function(_super) {
    __extends(CompileAnimationKeyframesSequenceMetadata, _super);
    function CompileAnimationKeyframesSequenceMetadata(steps) {
      if (steps === void 0) {
        steps = [];
      }
      _super.call(this);
      this.steps = steps;
    }
    return CompileAnimationKeyframesSequenceMetadata;
  }(CompileAnimationMetadata));
  exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;
  var CompileAnimationStyleMetadata = (function(_super) {
    __extends(CompileAnimationStyleMetadata, _super);
    function CompileAnimationStyleMetadata(offset, styles) {
      if (styles === void 0) {
        styles = null;
      }
      _super.call(this);
      this.offset = offset;
      this.styles = styles;
    }
    return CompileAnimationStyleMetadata;
  }(CompileAnimationMetadata));
  exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;
  var CompileAnimationAnimateMetadata = (function(_super) {
    __extends(CompileAnimationAnimateMetadata, _super);
    function CompileAnimationAnimateMetadata(timings, styles) {
      if (timings === void 0) {
        timings = 0;
      }
      if (styles === void 0) {
        styles = null;
      }
      _super.call(this);
      this.timings = timings;
      this.styles = styles;
    }
    return CompileAnimationAnimateMetadata;
  }(CompileAnimationMetadata));
  exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;
  var CompileAnimationWithStepsMetadata = (function(_super) {
    __extends(CompileAnimationWithStepsMetadata, _super);
    function CompileAnimationWithStepsMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      _super.call(this);
      this.steps = steps;
    }
    return CompileAnimationWithStepsMetadata;
  }(CompileAnimationMetadata));
  exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;
  var CompileAnimationSequenceMetadata = (function(_super) {
    __extends(CompileAnimationSequenceMetadata, _super);
    function CompileAnimationSequenceMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      _super.call(this, steps);
    }
    return CompileAnimationSequenceMetadata;
  }(CompileAnimationWithStepsMetadata));
  exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;
  var CompileAnimationGroupMetadata = (function(_super) {
    __extends(CompileAnimationGroupMetadata, _super);
    function CompileAnimationGroupMetadata(steps) {
      if (steps === void 0) {
        steps = null;
      }
      _super.call(this, steps);
    }
    return CompileAnimationGroupMetadata;
  }(CompileAnimationWithStepsMetadata));
  exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;
  var CompileIdentifierMetadata = (function() {
    function CompileIdentifierMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          runtime = _b.runtime,
          name = _b.name,
          moduleUrl = _b.moduleUrl,
          prefix = _b.prefix,
          value = _b.value;
      this._assetCacheKey = UNDEFINED;
      this.runtime = runtime;
      this.name = name;
      this.prefix = prefix;
      this.moduleUrl = moduleUrl;
      this.value = value;
    }
    Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileIdentifierMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        return this.identifier.runtime;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileIdentifierMetadata.prototype, "assetCacheKey", {
      get: function() {
        if (this._assetCacheKey === UNDEFINED) {
          if (lang_1.isPresent(this.moduleUrl) && lang_1.isPresent(url_resolver_1.getUrlScheme(this.moduleUrl))) {
            var uri = core_private_1.reflector.importUri({
              'filePath': this.moduleUrl,
              'name': this.name
            });
            this._assetCacheKey = this.name + "|" + uri;
          } else {
            this._assetCacheKey = null;
          }
        }
        return this._assetCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    CompileIdentifierMetadata.prototype.equalsTo = function(id2) {
      var rk = this.runtimeCacheKey;
      var ak = this.assetCacheKey;
      return (lang_1.isPresent(rk) && rk == id2.runtimeCacheKey) || (lang_1.isPresent(ak) && ak == id2.assetCacheKey);
    };
    return CompileIdentifierMetadata;
  }());
  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
  var CompileDiDependencyMetadata = (function() {
    function CompileDiDependencyMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          isAttribute = _b.isAttribute,
          isSelf = _b.isSelf,
          isHost = _b.isHost,
          isSkipSelf = _b.isSkipSelf,
          isOptional = _b.isOptional,
          isValue = _b.isValue,
          query = _b.query,
          viewQuery = _b.viewQuery,
          token = _b.token,
          value = _b.value;
      this.isAttribute = lang_1.normalizeBool(isAttribute);
      this.isSelf = lang_1.normalizeBool(isSelf);
      this.isHost = lang_1.normalizeBool(isHost);
      this.isSkipSelf = lang_1.normalizeBool(isSkipSelf);
      this.isOptional = lang_1.normalizeBool(isOptional);
      this.isValue = lang_1.normalizeBool(isValue);
      this.query = query;
      this.viewQuery = viewQuery;
      this.token = token;
      this.value = value;
    }
    return CompileDiDependencyMetadata;
  }());
  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
  var CompileProviderMetadata = (function() {
    function CompileProviderMetadata(_a) {
      var token = _a.token,
          useClass = _a.useClass,
          useValue = _a.useValue,
          useExisting = _a.useExisting,
          useFactory = _a.useFactory,
          deps = _a.deps,
          multi = _a.multi;
      this.token = token;
      this.useClass = useClass;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory;
      this.deps = lang_1.normalizeBlank(deps);
      this.multi = lang_1.normalizeBool(multi);
    }
    return CompileProviderMetadata;
  }());
  exports.CompileProviderMetadata = CompileProviderMetadata;
  var CompileFactoryMetadata = (function(_super) {
    __extends(CompileFactoryMetadata, _super);
    function CompileFactoryMetadata(_a) {
      var runtime = _a.runtime,
          name = _a.name,
          moduleUrl = _a.moduleUrl,
          prefix = _a.prefix,
          diDeps = _a.diDeps,
          value = _a.value;
      _super.call(this, {
        runtime: runtime,
        name: name,
        prefix: prefix,
        moduleUrl: moduleUrl,
        value: value
      });
      this.diDeps = _normalizeArray(diDeps);
    }
    return CompileFactoryMetadata;
  }(CompileIdentifierMetadata));
  exports.CompileFactoryMetadata = CompileFactoryMetadata;
  var CompileTokenMetadata = (function() {
    function CompileTokenMetadata(_a) {
      var value = _a.value,
          identifier = _a.identifier,
          identifierIsInstance = _a.identifierIsInstance;
      this.value = value;
      this.identifier = identifier;
      this.identifierIsInstance = lang_1.normalizeBool(identifierIsInstance);
    }
    Object.defineProperty(CompileTokenMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        if (lang_1.isPresent(this.identifier)) {
          return this.identifier.runtimeCacheKey;
        } else {
          return this.value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileTokenMetadata.prototype, "assetCacheKey", {
      get: function() {
        if (lang_1.isPresent(this.identifier)) {
          return this.identifier.assetCacheKey;
        } else {
          return this.value;
        }
      },
      enumerable: true,
      configurable: true
    });
    CompileTokenMetadata.prototype.equalsTo = function(token2) {
      var rk = this.runtimeCacheKey;
      var ak = this.assetCacheKey;
      return (lang_1.isPresent(rk) && rk == token2.runtimeCacheKey) || (lang_1.isPresent(ak) && ak == token2.assetCacheKey);
    };
    Object.defineProperty(CompileTokenMetadata.prototype, "name", {
      get: function() {
        return lang_1.isPresent(this.value) ? util_1.sanitizeIdentifier(this.value) : this.identifier.name;
      },
      enumerable: true,
      configurable: true
    });
    return CompileTokenMetadata;
  }());
  exports.CompileTokenMetadata = CompileTokenMetadata;
  var CompileIdentifierMap = (function() {
    function CompileIdentifierMap() {
      this._valueMap = new Map();
      this._values = [];
      this._tokens = [];
    }
    CompileIdentifierMap.prototype.add = function(token, value) {
      var existing = this.get(token);
      if (lang_1.isPresent(existing)) {
        throw new exceptions_1.BaseException("Cannot overwrite in a CompileIdentifierMap! Token: " + token.identifier.name);
      }
      this._tokens.push(token);
      this._values.push(value);
      var rk = token.runtimeCacheKey;
      if (lang_1.isPresent(rk)) {
        this._valueMap.set(rk, value);
      }
      var ak = token.assetCacheKey;
      if (lang_1.isPresent(ak)) {
        this._valueMap.set(ak, value);
      }
    };
    CompileIdentifierMap.prototype.get = function(token) {
      var rk = token.runtimeCacheKey;
      var ak = token.assetCacheKey;
      var result;
      if (lang_1.isPresent(rk)) {
        result = this._valueMap.get(rk);
      }
      if (lang_1.isBlank(result) && lang_1.isPresent(ak)) {
        result = this._valueMap.get(ak);
      }
      return result;
    };
    CompileIdentifierMap.prototype.keys = function() {
      return this._tokens;
    };
    CompileIdentifierMap.prototype.values = function() {
      return this._values;
    };
    Object.defineProperty(CompileIdentifierMap.prototype, "size", {
      get: function() {
        return this._values.length;
      },
      enumerable: true,
      configurable: true
    });
    return CompileIdentifierMap;
  }());
  exports.CompileIdentifierMap = CompileIdentifierMap;
  var CompileTypeMetadata = (function(_super) {
    __extends(CompileTypeMetadata, _super);
    function CompileTypeMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          runtime = _b.runtime,
          name = _b.name,
          moduleUrl = _b.moduleUrl,
          prefix = _b.prefix,
          isHost = _b.isHost,
          value = _b.value,
          diDeps = _b.diDeps,
          lifecycleHooks = _b.lifecycleHooks;
      _super.call(this, {
        runtime: runtime,
        name: name,
        moduleUrl: moduleUrl,
        prefix: prefix,
        value: value
      });
      this.isHost = lang_1.normalizeBool(isHost);
      this.diDeps = _normalizeArray(diDeps);
      this.lifecycleHooks = _normalizeArray(lifecycleHooks);
    }
    return CompileTypeMetadata;
  }(CompileIdentifierMetadata));
  exports.CompileTypeMetadata = CompileTypeMetadata;
  var CompileQueryMetadata = (function() {
    function CompileQueryMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selectors = _b.selectors,
          descendants = _b.descendants,
          first = _b.first,
          propertyName = _b.propertyName,
          read = _b.read;
      this.selectors = selectors;
      this.descendants = lang_1.normalizeBool(descendants);
      this.first = lang_1.normalizeBool(first);
      this.propertyName = propertyName;
      this.read = read;
    }
    return CompileQueryMetadata;
  }());
  exports.CompileQueryMetadata = CompileQueryMetadata;
  var CompileStylesheetMetadata = (function() {
    function CompileStylesheetMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          moduleUrl = _b.moduleUrl,
          styles = _b.styles,
          styleUrls = _b.styleUrls;
      this.moduleUrl = moduleUrl;
      this.styles = _normalizeArray(styles);
      this.styleUrls = _normalizeArray(styleUrls);
    }
    return CompileStylesheetMetadata;
  }());
  exports.CompileStylesheetMetadata = CompileStylesheetMetadata;
  var CompileTemplateMetadata = (function() {
    function CompileTemplateMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          encapsulation = _b.encapsulation,
          template = _b.template,
          templateUrl = _b.templateUrl,
          styles = _b.styles,
          styleUrls = _b.styleUrls,
          externalStylesheets = _b.externalStylesheets,
          animations = _b.animations,
          ngContentSelectors = _b.ngContentSelectors,
          interpolation = _b.interpolation;
      this.encapsulation = encapsulation;
      this.template = template;
      this.templateUrl = templateUrl;
      this.styles = _normalizeArray(styles);
      this.styleUrls = _normalizeArray(styleUrls);
      this.externalStylesheets = _normalizeArray(externalStylesheets);
      this.animations = lang_1.isPresent(animations) ? collection_1.ListWrapper.flatten(animations) : [];
      this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];
      if (lang_1.isPresent(interpolation) && interpolation.length != 2) {
        throw new exceptions_1.BaseException("'interpolation' should have a start and an end symbol.");
      }
      this.interpolation = interpolation;
    }
    return CompileTemplateMetadata;
  }());
  exports.CompileTemplateMetadata = CompileTemplateMetadata;
  var CompileDirectiveMetadata = (function() {
    function CompileDirectiveMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          isComponent = _b.isComponent,
          selector = _b.selector,
          exportAs = _b.exportAs,
          changeDetection = _b.changeDetection,
          inputs = _b.inputs,
          outputs = _b.outputs,
          hostListeners = _b.hostListeners,
          hostProperties = _b.hostProperties,
          hostAttributes = _b.hostAttributes,
          providers = _b.providers,
          viewProviders = _b.viewProviders,
          queries = _b.queries,
          viewQueries = _b.viewQueries,
          entryComponents = _b.entryComponents,
          viewDirectives = _b.viewDirectives,
          viewPipes = _b.viewPipes,
          template = _b.template;
      this.type = type;
      this.isComponent = isComponent;
      this.selector = selector;
      this.exportAs = exportAs;
      this.changeDetection = changeDetection;
      this.inputs = inputs;
      this.outputs = outputs;
      this.hostListeners = hostListeners;
      this.hostProperties = hostProperties;
      this.hostAttributes = hostAttributes;
      this.providers = _normalizeArray(providers);
      this.viewProviders = _normalizeArray(viewProviders);
      this.queries = _normalizeArray(queries);
      this.viewQueries = _normalizeArray(viewQueries);
      this.entryComponents = _normalizeArray(entryComponents);
      this.viewDirectives = _normalizeArray(viewDirectives);
      this.viewPipes = _normalizeArray(viewPipes);
      this.template = template;
    }
    CompileDirectiveMetadata.create = function(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          isComponent = _b.isComponent,
          selector = _b.selector,
          exportAs = _b.exportAs,
          changeDetection = _b.changeDetection,
          inputs = _b.inputs,
          outputs = _b.outputs,
          host = _b.host,
          providers = _b.providers,
          viewProviders = _b.viewProviders,
          queries = _b.queries,
          viewQueries = _b.viewQueries,
          entryComponents = _b.entryComponents,
          viewDirectives = _b.viewDirectives,
          viewPipes = _b.viewPipes,
          template = _b.template;
      var hostListeners = {};
      var hostProperties = {};
      var hostAttributes = {};
      if (lang_1.isPresent(host)) {
        collection_1.StringMapWrapper.forEach(host, function(value, key) {
          var matches = key.match(HOST_REG_EXP);
          if (matches === null) {
            hostAttributes[key] = value;
          } else if (lang_1.isPresent(matches[1])) {
            hostProperties[matches[1]] = value;
          } else if (lang_1.isPresent(matches[2])) {
            hostListeners[matches[2]] = value;
          } else if (lang_1.isPresent(matches[3])) {
            hostProperties['@' + matches[3]] = value;
          }
        });
      }
      var inputsMap = {};
      if (lang_1.isPresent(inputs)) {
        inputs.forEach(function(bindConfig) {
          var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
          inputsMap[parts[0]] = parts[1];
        });
      }
      var outputsMap = {};
      if (lang_1.isPresent(outputs)) {
        outputs.forEach(function(bindConfig) {
          var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
          outputsMap[parts[0]] = parts[1];
        });
      }
      return new CompileDirectiveMetadata({
        type: type,
        isComponent: lang_1.normalizeBool(isComponent),
        selector: selector,
        exportAs: exportAs,
        changeDetection: changeDetection,
        inputs: inputsMap,
        outputs: outputsMap,
        hostListeners: hostListeners,
        hostProperties: hostProperties,
        hostAttributes: hostAttributes,
        providers: providers,
        viewProviders: viewProviders,
        queries: queries,
        viewQueries: viewQueries,
        entryComponents: entryComponents,
        viewDirectives: viewDirectives,
        viewPipes: viewPipes,
        template: template
      });
    };
    Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
      get: function() {
        return this.type;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileDirectiveMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        return this.type.runtimeCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileDirectiveMetadata.prototype, "assetCacheKey", {
      get: function() {
        return this.type.assetCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    CompileDirectiveMetadata.prototype.equalsTo = function(other) {
      return this.type.equalsTo(other.identifier);
    };
    return CompileDirectiveMetadata;
  }());
  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
  function createHostComponentMeta(compMeta) {
    var template = selector_1.CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
      type: new CompileTypeMetadata({
        runtime: Object,
        name: compMeta.type.name + "_Host",
        moduleUrl: compMeta.type.moduleUrl,
        isHost: true
      }),
      template: new CompileTemplateMetadata({
        template: template,
        templateUrl: '',
        styles: [],
        styleUrls: [],
        ngContentSelectors: [],
        animations: []
      }),
      changeDetection: core_1.ChangeDetectionStrategy.Default,
      inputs: [],
      outputs: [],
      host: {},
      isComponent: true,
      selector: '*',
      providers: [],
      viewProviders: [],
      queries: [],
      viewQueries: []
    });
  }
  exports.createHostComponentMeta = createHostComponentMeta;
  var CompilePipeMetadata = (function() {
    function CompilePipeMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          name = _b.name,
          pure = _b.pure;
      this.type = type;
      this.name = name;
      this.pure = lang_1.normalizeBool(pure);
    }
    Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
      get: function() {
        return this.type;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompilePipeMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        return this.type.runtimeCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompilePipeMetadata.prototype, "assetCacheKey", {
      get: function() {
        return this.type.assetCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    CompilePipeMetadata.prototype.equalsTo = function(other) {
      return this.type.equalsTo(other.identifier);
    };
    return CompilePipeMetadata;
  }());
  exports.CompilePipeMetadata = CompilePipeMetadata;
  var CompileNgModuleMetadata = (function() {
    function CompileNgModuleMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          type = _b.type,
          providers = _b.providers,
          declaredDirectives = _b.declaredDirectives,
          exportedDirectives = _b.exportedDirectives,
          declaredPipes = _b.declaredPipes,
          exportedPipes = _b.exportedPipes,
          entryComponents = _b.entryComponents,
          bootstrapComponents = _b.bootstrapComponents,
          importedModules = _b.importedModules,
          exportedModules = _b.exportedModules,
          schemas = _b.schemas,
          transitiveModule = _b.transitiveModule;
      this.type = type;
      this.declaredDirectives = _normalizeArray(declaredDirectives);
      this.exportedDirectives = _normalizeArray(exportedDirectives);
      this.declaredPipes = _normalizeArray(declaredPipes);
      this.exportedPipes = _normalizeArray(exportedPipes);
      this.providers = _normalizeArray(providers);
      this.entryComponents = _normalizeArray(entryComponents);
      this.bootstrapComponents = _normalizeArray(bootstrapComponents);
      this.importedModules = _normalizeArray(importedModules);
      this.exportedModules = _normalizeArray(exportedModules);
      this.schemas = _normalizeArray(schemas);
      this.transitiveModule = transitiveModule;
    }
    Object.defineProperty(CompileNgModuleMetadata.prototype, "identifier", {
      get: function() {
        return this.type;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileNgModuleMetadata.prototype, "runtimeCacheKey", {
      get: function() {
        return this.type.runtimeCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompileNgModuleMetadata.prototype, "assetCacheKey", {
      get: function() {
        return this.type.assetCacheKey;
      },
      enumerable: true,
      configurable: true
    });
    CompileNgModuleMetadata.prototype.equalsTo = function(other) {
      return this.type.equalsTo(other.identifier);
    };
    return CompileNgModuleMetadata;
  }());
  exports.CompileNgModuleMetadata = CompileNgModuleMetadata;
  var TransitiveCompileNgModuleMetadata = (function() {
    function TransitiveCompileNgModuleMetadata(modules, providers, entryComponents, directives, pipes) {
      var _this = this;
      this.modules = modules;
      this.providers = providers;
      this.entryComponents = entryComponents;
      this.directives = directives;
      this.pipes = pipes;
      this.directivesSet = new Set();
      this.pipesSet = new Set();
      directives.forEach(function(dir) {
        return _this.directivesSet.add(dir.type.runtime);
      });
      pipes.forEach(function(pipe) {
        return _this.pipesSet.add(pipe.type.runtime);
      });
    }
    return TransitiveCompileNgModuleMetadata;
  }());
  exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
  function removeIdentifierDuplicates(items) {
    var map = new CompileIdentifierMap();
    items.forEach(function(item) {
      if (!map.get(item)) {
        map.add(item, item);
      }
    });
    return map.keys();
  }
  exports.removeIdentifierDuplicates = removeIdentifierDuplicates;
  function _normalizeArray(obj) {
    return lang_1.isPresent(obj) ? obj : [];
  }
  function isStaticSymbol(value) {
    return lang_1.isStringMap(value) && lang_1.isPresent(value['name']) && lang_1.isPresent(value['filePath']);
  }
  exports.isStaticSymbol = isStaticSymbol;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/identifiers.js", ["@angular/core", "../core_private", "./compile_metadata", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../core_private');
  var compile_metadata_1 = $__require('./compile_metadata');
  var util_1 = $__require('./util');
  var APP_VIEW_MODULE_URL = util_1.assetUrl('core', 'linker/view');
  var VIEW_UTILS_MODULE_URL = util_1.assetUrl('core', 'linker/view_utils');
  var CD_MODULE_URL = util_1.assetUrl('core', 'change_detection/change_detection');
  var impViewUtils = core_private_1.ViewUtils;
  var impAppView = core_private_1.AppView;
  var impDebugAppView = core_private_1.DebugAppView;
  var impDebugContext = core_private_1.DebugContext;
  var impAppElement = core_private_1.AppElement;
  var impElementRef = core_1.ElementRef;
  var impViewContainerRef = core_1.ViewContainerRef;
  var impChangeDetectorRef = core_1.ChangeDetectorRef;
  var impRenderComponentType = core_1.RenderComponentType;
  var impQueryList = core_1.QueryList;
  var impTemplateRef = core_1.TemplateRef;
  var impTemplateRef_ = core_private_1.TemplateRef_;
  var impValueUnwrapper = core_private_1.ValueUnwrapper;
  var impInjector = core_1.Injector;
  var impViewEncapsulation = core_1.ViewEncapsulation;
  var impViewType = core_private_1.ViewType;
  var impChangeDetectionStrategy = core_1.ChangeDetectionStrategy;
  var impStaticNodeDebugInfo = core_private_1.StaticNodeDebugInfo;
  var impRenderer = core_1.Renderer;
  var impSimpleChange = core_1.SimpleChange;
  var impUNINITIALIZED = core_private_1.UNINITIALIZED;
  var impChangeDetectorStatus = core_private_1.ChangeDetectorStatus;
  var impFlattenNestedViewRenderNodes = core_private_1.flattenNestedViewRenderNodes;
  var impDevModeEqual = core_private_1.devModeEqual;
  var impInterpolate = core_private_1.interpolate;
  var impCheckBinding = core_private_1.checkBinding;
  var impCastByValue = core_private_1.castByValue;
  var impEMPTY_ARRAY = core_private_1.EMPTY_ARRAY;
  var impEMPTY_MAP = core_private_1.EMPTY_MAP;
  var impAnimationGroupPlayer = core_private_1.AnimationGroupPlayer;
  var impAnimationSequencePlayer = core_private_1.AnimationSequencePlayer;
  var impAnimationKeyframe = core_private_1.AnimationKeyframe;
  var impAnimationStyles = core_private_1.AnimationStyles;
  var impNoOpAnimationPlayer = core_private_1.NoOpAnimationPlayer;
  var ANIMATION_STYLE_UTIL_ASSET_URL = util_1.assetUrl('core', 'animation/animation_style_util');
  var Identifiers = (function() {
    function Identifiers() {}
    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
      moduleUrl: util_1.assetUrl('core', 'metadata/di'),
      runtime: core_1.ANALYZE_FOR_ENTRY_COMPONENTS
    });
    Identifiers.ViewUtils = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ViewUtils',
      moduleUrl: util_1.assetUrl('core', 'linker/view_utils'),
      runtime: impViewUtils
    });
    Identifiers.AppView = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AppView',
      moduleUrl: APP_VIEW_MODULE_URL,
      runtime: impAppView
    });
    Identifiers.DebugAppView = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'DebugAppView',
      moduleUrl: APP_VIEW_MODULE_URL,
      runtime: impDebugAppView
    });
    Identifiers.AppElement = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AppElement',
      moduleUrl: util_1.assetUrl('core', 'linker/element'),
      runtime: impAppElement
    });
    Identifiers.ElementRef = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ElementRef',
      moduleUrl: util_1.assetUrl('core', 'linker/element_ref'),
      runtime: impElementRef
    });
    Identifiers.ViewContainerRef = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ViewContainerRef',
      moduleUrl: util_1.assetUrl('core', 'linker/view_container_ref'),
      runtime: impViewContainerRef
    });
    Identifiers.ChangeDetectorRef = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ChangeDetectorRef',
      moduleUrl: util_1.assetUrl('core', 'change_detection/change_detector_ref'),
      runtime: impChangeDetectorRef
    });
    Identifiers.RenderComponentType = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'RenderComponentType',
      moduleUrl: util_1.assetUrl('core', 'render/api'),
      runtime: impRenderComponentType
    });
    Identifiers.QueryList = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'QueryList',
      moduleUrl: util_1.assetUrl('core', 'linker/query_list'),
      runtime: impQueryList
    });
    Identifiers.TemplateRef = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'TemplateRef',
      moduleUrl: util_1.assetUrl('core', 'linker/template_ref'),
      runtime: impTemplateRef
    });
    Identifiers.TemplateRef_ = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'TemplateRef_',
      moduleUrl: util_1.assetUrl('core', 'linker/template_ref'),
      runtime: impTemplateRef_
    });
    Identifiers.CodegenComponentFactoryResolver = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'CodegenComponentFactoryResolver',
      moduleUrl: util_1.assetUrl('core', 'linker/component_factory_resolver'),
      runtime: core_private_1.CodegenComponentFactoryResolver
    });
    Identifiers.ComponentFactoryResolver = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ComponentFactoryResolver',
      moduleUrl: util_1.assetUrl('core', 'linker/component_factory_resolver'),
      runtime: core_1.ComponentFactoryResolver
    });
    Identifiers.ComponentFactory = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ComponentFactory',
      runtime: core_1.ComponentFactory,
      moduleUrl: util_1.assetUrl('core', 'linker/component_factory')
    });
    Identifiers.NgModuleFactory = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'NgModuleFactory',
      runtime: core_1.NgModuleFactory,
      moduleUrl: util_1.assetUrl('core', 'linker/ng_module_factory')
    });
    Identifiers.NgModuleInjector = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'NgModuleInjector',
      runtime: core_private_1.NgModuleInjector,
      moduleUrl: util_1.assetUrl('core', 'linker/ng_module_factory')
    });
    Identifiers.ValueUnwrapper = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ValueUnwrapper',
      moduleUrl: CD_MODULE_URL,
      runtime: impValueUnwrapper
    });
    Identifiers.Injector = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'Injector',
      moduleUrl: util_1.assetUrl('core', 'di/injector'),
      runtime: impInjector
    });
    Identifiers.ViewEncapsulation = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ViewEncapsulation',
      moduleUrl: util_1.assetUrl('core', 'metadata/view'),
      runtime: impViewEncapsulation
    });
    Identifiers.ViewType = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ViewType',
      moduleUrl: util_1.assetUrl('core', 'linker/view_type'),
      runtime: impViewType
    });
    Identifiers.ChangeDetectionStrategy = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ChangeDetectionStrategy',
      moduleUrl: CD_MODULE_URL,
      runtime: impChangeDetectionStrategy
    });
    Identifiers.StaticNodeDebugInfo = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'StaticNodeDebugInfo',
      moduleUrl: util_1.assetUrl('core', 'linker/debug_context'),
      runtime: impStaticNodeDebugInfo
    });
    Identifiers.DebugContext = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'DebugContext',
      moduleUrl: util_1.assetUrl('core', 'linker/debug_context'),
      runtime: impDebugContext
    });
    Identifiers.Renderer = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'Renderer',
      moduleUrl: util_1.assetUrl('core', 'render/api'),
      runtime: impRenderer
    });
    Identifiers.SimpleChange = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'SimpleChange',
      moduleUrl: CD_MODULE_URL,
      runtime: impSimpleChange
    });
    Identifiers.UNINITIALIZED = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'UNINITIALIZED',
      moduleUrl: CD_MODULE_URL,
      runtime: impUNINITIALIZED
    });
    Identifiers.ChangeDetectorStatus = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'ChangeDetectorStatus',
      moduleUrl: CD_MODULE_URL,
      runtime: impChangeDetectorStatus
    });
    Identifiers.checkBinding = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'checkBinding',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impCheckBinding
    });
    Identifiers.flattenNestedViewRenderNodes = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'flattenNestedViewRenderNodes',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impFlattenNestedViewRenderNodes
    });
    Identifiers.devModeEqual = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'devModeEqual',
      moduleUrl: CD_MODULE_URL,
      runtime: impDevModeEqual
    });
    Identifiers.interpolate = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'interpolate',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impInterpolate
    });
    Identifiers.castByValue = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'castByValue',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impCastByValue
    });
    Identifiers.EMPTY_ARRAY = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'EMPTY_ARRAY',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impEMPTY_ARRAY
    });
    Identifiers.EMPTY_MAP = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'EMPTY_MAP',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: impEMPTY_MAP
    });
    Identifiers.pureProxies = [null, new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy1',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy1
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy2',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy2
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy3',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy3
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy4',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy4
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy5',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy5
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy6',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy6
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy7',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy7
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy8',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy8
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy9',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy9
    }), new compile_metadata_1.CompileIdentifierMetadata({
      name: 'pureProxy10',
      moduleUrl: VIEW_UTILS_MODULE_URL,
      runtime: core_private_1.pureProxy10
    })];
    Identifiers.SecurityContext = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'SecurityContext',
      moduleUrl: util_1.assetUrl('core', 'security'),
      runtime: core_1.SecurityContext
    });
    Identifiers.AnimationKeyframe = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AnimationKeyframe',
      moduleUrl: util_1.assetUrl('core', 'animation/animation_keyframe'),
      runtime: impAnimationKeyframe
    });
    Identifiers.AnimationStyles = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AnimationStyles',
      moduleUrl: util_1.assetUrl('core', 'animation/animation_styles'),
      runtime: impAnimationStyles
    });
    Identifiers.NoOpAnimationPlayer = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'NoOpAnimationPlayer',
      moduleUrl: util_1.assetUrl('core', 'animation/animation_player'),
      runtime: impNoOpAnimationPlayer
    });
    Identifiers.AnimationGroupPlayer = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AnimationGroupPlayer',
      moduleUrl: util_1.assetUrl('core', 'animation/animation_group_player'),
      runtime: impAnimationGroupPlayer
    });
    Identifiers.AnimationSequencePlayer = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'AnimationSequencePlayer',
      moduleUrl: util_1.assetUrl('core', 'animation/animation_sequence_player'),
      runtime: impAnimationSequencePlayer
    });
    Identifiers.prepareFinalAnimationStyles = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'prepareFinalAnimationStyles',
      moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
      runtime: core_private_1.prepareFinalAnimationStyles
    });
    Identifiers.balanceAnimationKeyframes = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'balanceAnimationKeyframes',
      moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
      runtime: core_private_1.balanceAnimationKeyframes
    });
    Identifiers.clearStyles = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'clearStyles',
      moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
      runtime: core_private_1.clearStyles
    });
    Identifiers.renderStyles = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'renderStyles',
      moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
      runtime: core_private_1.renderStyles
    });
    Identifiers.collectAndResolveStyles = new compile_metadata_1.CompileIdentifierMetadata({
      name: 'collectAndResolveStyles',
      moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
      runtime: core_private_1.collectAndResolveStyles
    });
    return Identifiers;
  }());
  exports.Identifiers = Identifiers;
  function identifierToken(identifier) {
    return new compile_metadata_1.CompileTokenMetadata({identifier: identifier});
  }
  exports.identifierToken = identifierToken;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/collection.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Map = lang_1.global.Map;
  exports.Set = lang_1.global.Set;
  var createMapFromPairs = (function() {
    try {
      if (new exports.Map([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new exports.Map(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new exports.Map();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new exports.Map(new exports.Map())) {
        return function createMapFromMap(m) {
          return new exports.Map(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new exports.Map();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new exports.Map()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new exports.Map()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new exports.Map();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  exports.MapWrapper = MapWrapper;
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).map(function(k) {
        return map[k];
      });
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var _i = 0,
          _a = Object.keys(map); _i < _a.length; _i++) {
        var k = _a[_i];
        callback(map[k], k);
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var _i = 0,
          _a = Object.keys(m1); _i < _a.length; _i++) {
        var k = _a[_i];
        m[k] = m1[k];
      }
      for (var _b = 0,
          _c = Object.keys(m2); _b < _c.length; _b++) {
        var k = _c[_b];
        m[k] = m2[k];
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  exports.StringMapWrapper = StringMapWrapper;
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (lang_1.isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (lang_1.isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  exports.ListWrapper = ListWrapper;
  function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (lang_1.isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
      return false;
    return lang_1.isArray(obj) || (!(obj instanceof exports.Map) && lang_1.getSymbolIterator() in obj);
  }
  exports.isListLikeIterable = isListLikeIterable;
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  exports.areIterablesEqual = areIterablesEqual;
  function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[lang_1.getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  exports.iterateListLike = iterateListLike;
  var createSetFromList = (function() {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new exports.Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new exports.Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  exports.SetWrapper = SetWrapper;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/facade/lang.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  exports.scheduleMicroTask = scheduleMicroTask;
  var _global = globalScope;
  exports.global = _global;
  exports.Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  exports.getTypeNameForDebugging = getTypeNameForDebugging;
  exports.Math = _global.Math;
  exports.Date = _global.Date;
  _global.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  exports.isPresent = isPresent;
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  exports.isBlank = isBlank;
  function isBoolean(obj) {
    return typeof obj === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  exports.isNumber = isNumber;
  function isString(obj) {
    return typeof obj === 'string';
  }
  exports.isString = isString;
  function isFunction(obj) {
    return typeof obj === 'function';
  }
  exports.isFunction = isFunction;
  function isType(obj) {
    return isFunction(obj);
  }
  exports.isType = isType;
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  exports.isStringMap = isStringMap;
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  exports.isStrictStringMap = isStrictStringMap;
  function isPromise(obj) {
    return isPresent(obj) && isFunction(obj.then);
  }
  exports.isPromise = isPromise;
  function isArray(obj) {
    return Array.isArray(obj);
  }
  exports.isArray = isArray;
  function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
  }
  exports.isDate = isDate;
  function noop() {}
  exports.noop = noop;
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf('\n');
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  exports.stringify = stringify;
  function serializeEnum(val) {
    return val;
  }
  exports.serializeEnum = serializeEnum;
  function deserializeEnum(val, values) {
    return val;
  }
  exports.deserializeEnum = deserializeEnum;
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  exports.resolveEnumToken = resolveEnumToken;
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  exports.StringWrapper = StringWrapper;
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join('');
    };
    return StringJoiner;
  }());
  exports.StringJoiner = StringJoiner;
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  exports.NumberParseError = NumberParseError;
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError('Invalid integer literal when parsing ' + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNumeric = function(value) {
      return !isNaN(value - parseFloat(value));
    };
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  exports.NumberWrapper = NumberWrapper;
  exports.RegExp = _global.RegExp;
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    FunctionWrapper.bind = function(fn, scope) {
      return fn.bind(scope);
    };
    return FunctionWrapper;
  }());
  exports.FunctionWrapper = FunctionWrapper;
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  exports.looseIdentical = looseIdentical;
  function getMapKey(value) {
    return value;
  }
  exports.getMapKey = getMapKey;
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  exports.normalizeBlank = normalizeBlank;
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  exports.normalizeBool = normalizeBool;
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  exports.isJsObject = isJsObject;
  function print(obj) {
    console.log(obj);
  }
  exports.print = print;
  function warn(obj) {
    console.warn(obj);
  }
  exports.warn = warn;
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return _global.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return _global.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  exports.Json = Json;
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new exports.Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new exports.Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new exports.Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  exports.DateWrapper = DateWrapper;
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  exports.setValueOnPath = setValueOnPath;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  exports.evalExpression = evalExpression;
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  exports.isPrimitive = isPrimitive;
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  exports.hasConstructor = hasConstructor;
  function escape(s) {
    return _global.encodeURI(s);
  }
  exports.escape = escape;
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  exports.escapeRegExp = escapeRegExp;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/output/output_ast.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var lang_1 = $__require('../facade/lang');
  (function(TypeModifier) {
    TypeModifier[TypeModifier["Const"] = 0] = "Const";
  })(exports.TypeModifier || (exports.TypeModifier = {}));
  var TypeModifier = exports.TypeModifier;
  var Type = (function() {
    function Type(modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      this.modifiers = modifiers;
      if (lang_1.isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    Type.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return Type;
  }());
  exports.Type = Type;
  (function(BuiltinTypeName) {
    BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
    BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
    BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
    BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
    BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
    BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
  })(exports.BuiltinTypeName || (exports.BuiltinTypeName = {}));
  var BuiltinTypeName = exports.BuiltinTypeName;
  var BuiltinType = (function(_super) {
    __extends(BuiltinType, _super);
    function BuiltinType(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
    }
    BuiltinType.prototype.visitType = function(visitor, context) {
      return visitor.visitBuiltintType(this, context);
    };
    return BuiltinType;
  }(Type));
  exports.BuiltinType = BuiltinType;
  var ExternalType = (function(_super) {
    __extends(ExternalType, _super);
    function ExternalType(value, typeParams, modifiers) {
      if (typeParams === void 0) {
        typeParams = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.value = value;
      this.typeParams = typeParams;
    }
    ExternalType.prototype.visitType = function(visitor, context) {
      return visitor.visitExternalType(this, context);
    };
    return ExternalType;
  }(Type));
  exports.ExternalType = ExternalType;
  var ArrayType = (function(_super) {
    __extends(ArrayType, _super);
    function ArrayType(of, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.of = of;
    }
    ArrayType.prototype.visitType = function(visitor, context) {
      return visitor.visitArrayType(this, context);
    };
    return ArrayType;
  }(Type));
  exports.ArrayType = ArrayType;
  var MapType = (function(_super) {
    __extends(MapType, _super);
    function MapType(valueType, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.valueType = valueType;
    }
    MapType.prototype.visitType = function(visitor, context) {
      return visitor.visitMapType(this, context);
    };
    return MapType;
  }(Type));
  exports.MapType = MapType;
  exports.DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  exports.BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  exports.INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  exports.NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  exports.STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  exports.FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  (function(BinaryOperator) {
    BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
    BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
    BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
    BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
    BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
    BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
    BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
    BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
    BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
    BinaryOperator[BinaryOperator["And"] = 9] = "And";
    BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
    BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
    BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
    BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
    BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
  })(exports.BinaryOperator || (exports.BinaryOperator = {}));
  var BinaryOperator = exports.BinaryOperator;
  var Expression = (function() {
    function Expression(type) {
      this.type = type;
    }
    Expression.prototype.prop = function(name) {
      return new ReadPropExpr(this, name);
    };
    Expression.prototype.key = function(index, type) {
      if (type === void 0) {
        type = null;
      }
      return new ReadKeyExpr(this, index, type);
    };
    Expression.prototype.callMethod = function(name, params) {
      return new InvokeMethodExpr(this, name, params);
    };
    Expression.prototype.callFn = function(params) {
      return new InvokeFunctionExpr(this, params);
    };
    Expression.prototype.instantiate = function(params, type) {
      if (type === void 0) {
        type = null;
      }
      return new InstantiateExpr(this, params, type);
    };
    Expression.prototype.conditional = function(trueCase, falseCase) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      return new ConditionalExpr(this, trueCase, falseCase);
    };
    Expression.prototype.equals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
    };
    Expression.prototype.notEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
    };
    Expression.prototype.identical = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
    };
    Expression.prototype.notIdentical = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
    };
    Expression.prototype.minus = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
    };
    Expression.prototype.plus = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
    };
    Expression.prototype.divide = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
    };
    Expression.prototype.multiply = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
    };
    Expression.prototype.modulo = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
    };
    Expression.prototype.and = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
    };
    Expression.prototype.or = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
    };
    Expression.prototype.lower = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
    };
    Expression.prototype.lowerEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
    };
    Expression.prototype.bigger = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
    };
    Expression.prototype.biggerEquals = function(rhs) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
    };
    Expression.prototype.isBlank = function() {
      return this.equals(exports.NULL_EXPR);
    };
    Expression.prototype.cast = function(type) {
      return new CastExpr(this, type);
    };
    Expression.prototype.toStmt = function() {
      return new ExpressionStatement(this);
    };
    return Expression;
  }());
  exports.Expression = Expression;
  (function(BuiltinVar) {
    BuiltinVar[BuiltinVar["This"] = 0] = "This";
    BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
    BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
    BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
  })(exports.BuiltinVar || (exports.BuiltinVar = {}));
  var BuiltinVar = exports.BuiltinVar;
  var ReadVarExpr = (function(_super) {
    __extends(ReadVarExpr, _super);
    function ReadVarExpr(name, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      if (lang_1.isString(name)) {
        this.name = name;
        this.builtin = null;
      } else {
        this.name = null;
        this.builtin = name;
      }
    }
    ReadVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadVarExpr(this, context);
    };
    ReadVarExpr.prototype.set = function(value) {
      return new WriteVarExpr(this.name, value);
    };
    return ReadVarExpr;
  }(Expression));
  exports.ReadVarExpr = ReadVarExpr;
  var WriteVarExpr = (function(_super) {
    __extends(WriteVarExpr, _super);
    function WriteVarExpr(name, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, lang_1.isPresent(type) ? type : value.type);
      this.name = name;
      this.value = value;
    }
    WriteVarExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteVarExpr(this, context);
    };
    WriteVarExpr.prototype.toDeclStmt = function(type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      return new DeclareVarStmt(this.name, this.value, type, modifiers);
    };
    return WriteVarExpr;
  }(Expression));
  exports.WriteVarExpr = WriteVarExpr;
  var WriteKeyExpr = (function(_super) {
    __extends(WriteKeyExpr, _super);
    function WriteKeyExpr(receiver, index, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, lang_1.isPresent(type) ? type : value.type);
      this.receiver = receiver;
      this.index = index;
      this.value = value;
    }
    WriteKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWriteKeyExpr(this, context);
    };
    return WriteKeyExpr;
  }(Expression));
  exports.WriteKeyExpr = WriteKeyExpr;
  var WritePropExpr = (function(_super) {
    __extends(WritePropExpr, _super);
    function WritePropExpr(receiver, name, value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, lang_1.isPresent(type) ? type : value.type);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    WritePropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitWritePropExpr(this, context);
    };
    return WritePropExpr;
  }(Expression));
  exports.WritePropExpr = WritePropExpr;
  (function(BuiltinMethod) {
    BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
    BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
    BuiltinMethod[BuiltinMethod["bind"] = 2] = "bind";
  })(exports.BuiltinMethod || (exports.BuiltinMethod = {}));
  var BuiltinMethod = exports.BuiltinMethod;
  var InvokeMethodExpr = (function(_super) {
    __extends(InvokeMethodExpr, _super);
    function InvokeMethodExpr(receiver, method, args, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.args = args;
      if (lang_1.isString(method)) {
        this.name = method;
        this.builtin = null;
      } else {
        this.name = null;
        this.builtin = method;
      }
    }
    InvokeMethodExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeMethodExpr(this, context);
    };
    return InvokeMethodExpr;
  }(Expression));
  exports.InvokeMethodExpr = InvokeMethodExpr;
  var InvokeFunctionExpr = (function(_super) {
    __extends(InvokeFunctionExpr, _super);
    function InvokeFunctionExpr(fn, args, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.fn = fn;
      this.args = args;
    }
    InvokeFunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInvokeFunctionExpr(this, context);
    };
    return InvokeFunctionExpr;
  }(Expression));
  exports.InvokeFunctionExpr = InvokeFunctionExpr;
  var InstantiateExpr = (function(_super) {
    __extends(InstantiateExpr, _super);
    function InstantiateExpr(classExpr, args, type) {
      _super.call(this, type);
      this.classExpr = classExpr;
      this.args = args;
    }
    InstantiateExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitInstantiateExpr(this, context);
    };
    return InstantiateExpr;
  }(Expression));
  exports.InstantiateExpr = InstantiateExpr;
  var LiteralExpr = (function(_super) {
    __extends(LiteralExpr, _super);
    function LiteralExpr(value, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.value = value;
    }
    LiteralExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralExpr(this, context);
    };
    return LiteralExpr;
  }(Expression));
  exports.LiteralExpr = LiteralExpr;
  var ExternalExpr = (function(_super) {
    __extends(ExternalExpr, _super);
    function ExternalExpr(value, type, typeParams) {
      if (type === void 0) {
        type = null;
      }
      if (typeParams === void 0) {
        typeParams = null;
      }
      _super.call(this, type);
      this.value = value;
      this.typeParams = typeParams;
    }
    ExternalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitExternalExpr(this, context);
    };
    return ExternalExpr;
  }(Expression));
  exports.ExternalExpr = ExternalExpr;
  var ConditionalExpr = (function(_super) {
    __extends(ConditionalExpr, _super);
    function ConditionalExpr(condition, trueCase, falseCase, type) {
      if (falseCase === void 0) {
        falseCase = null;
      }
      if (type === void 0) {
        type = null;
      }
      _super.call(this, lang_1.isPresent(type) ? type : trueCase.type);
      this.condition = condition;
      this.falseCase = falseCase;
      this.trueCase = trueCase;
    }
    ConditionalExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitConditionalExpr(this, context);
    };
    return ConditionalExpr;
  }(Expression));
  exports.ConditionalExpr = ConditionalExpr;
  var NotExpr = (function(_super) {
    __extends(NotExpr, _super);
    function NotExpr(condition) {
      _super.call(this, exports.BOOL_TYPE);
      this.condition = condition;
    }
    NotExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitNotExpr(this, context);
    };
    return NotExpr;
  }(Expression));
  exports.NotExpr = NotExpr;
  var CastExpr = (function(_super) {
    __extends(CastExpr, _super);
    function CastExpr(value, type) {
      _super.call(this, type);
      this.value = value;
    }
    CastExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitCastExpr(this, context);
    };
    return CastExpr;
  }(Expression));
  exports.CastExpr = CastExpr;
  var FnParam = (function() {
    function FnParam(name, type) {
      if (type === void 0) {
        type = null;
      }
      this.name = name;
      this.type = type;
    }
    return FnParam;
  }());
  exports.FnParam = FnParam;
  var FunctionExpr = (function(_super) {
    __extends(FunctionExpr, _super);
    function FunctionExpr(params, statements, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.params = params;
      this.statements = statements;
    }
    FunctionExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitFunctionExpr(this, context);
    };
    FunctionExpr.prototype.toDeclStmt = function(name, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
    };
    return FunctionExpr;
  }(Expression));
  exports.FunctionExpr = FunctionExpr;
  var BinaryOperatorExpr = (function(_super) {
    __extends(BinaryOperatorExpr, _super);
    function BinaryOperatorExpr(operator, lhs, rhs, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, lang_1.isPresent(type) ? type : lhs.type);
      this.operator = operator;
      this.rhs = rhs;
      this.lhs = lhs;
    }
    BinaryOperatorExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitBinaryOperatorExpr(this, context);
    };
    return BinaryOperatorExpr;
  }(Expression));
  exports.BinaryOperatorExpr = BinaryOperatorExpr;
  var ReadPropExpr = (function(_super) {
    __extends(ReadPropExpr, _super);
    function ReadPropExpr(receiver, name, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.name = name;
    }
    ReadPropExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadPropExpr(this, context);
    };
    ReadPropExpr.prototype.set = function(value) {
      return new WritePropExpr(this.receiver, this.name, value);
    };
    return ReadPropExpr;
  }(Expression));
  exports.ReadPropExpr = ReadPropExpr;
  var ReadKeyExpr = (function(_super) {
    __extends(ReadKeyExpr, _super);
    function ReadKeyExpr(receiver, index, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.receiver = receiver;
      this.index = index;
    }
    ReadKeyExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitReadKeyExpr(this, context);
    };
    ReadKeyExpr.prototype.set = function(value) {
      return new WriteKeyExpr(this.receiver, this.index, value);
    };
    return ReadKeyExpr;
  }(Expression));
  exports.ReadKeyExpr = ReadKeyExpr;
  var LiteralArrayExpr = (function(_super) {
    __extends(LiteralArrayExpr, _super);
    function LiteralArrayExpr(entries, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.entries = entries;
    }
    LiteralArrayExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralArrayExpr(this, context);
    };
    return LiteralArrayExpr;
  }(Expression));
  exports.LiteralArrayExpr = LiteralArrayExpr;
  var LiteralMapExpr = (function(_super) {
    __extends(LiteralMapExpr, _super);
    function LiteralMapExpr(entries, type) {
      if (type === void 0) {
        type = null;
      }
      _super.call(this, type);
      this.entries = entries;
      this.valueType = null;
      if (lang_1.isPresent(type)) {
        this.valueType = type.valueType;
      }
    }
    LiteralMapExpr.prototype.visitExpression = function(visitor, context) {
      return visitor.visitLiteralMapExpr(this, context);
    };
    return LiteralMapExpr;
  }(Expression));
  exports.LiteralMapExpr = LiteralMapExpr;
  exports.THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
  exports.SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
  exports.CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
  exports.CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
  exports.NULL_EXPR = new LiteralExpr(null, null);
  (function(StmtModifier) {
    StmtModifier[StmtModifier["Final"] = 0] = "Final";
    StmtModifier[StmtModifier["Private"] = 1] = "Private";
  })(exports.StmtModifier || (exports.StmtModifier = {}));
  var StmtModifier = exports.StmtModifier;
  var Statement = (function() {
    function Statement(modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      this.modifiers = modifiers;
      if (lang_1.isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    Statement.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return Statement;
  }());
  exports.Statement = Statement;
  var DeclareVarStmt = (function(_super) {
    __extends(DeclareVarStmt, _super);
    function DeclareVarStmt(name, value, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.value = value;
      this.type = lang_1.isPresent(type) ? type : value.type;
    }
    DeclareVarStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareVarStmt(this, context);
    };
    return DeclareVarStmt;
  }(Statement));
  exports.DeclareVarStmt = DeclareVarStmt;
  var DeclareFunctionStmt = (function(_super) {
    __extends(DeclareFunctionStmt, _super);
    function DeclareFunctionStmt(name, params, statements, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.params = params;
      this.statements = statements;
      this.type = type;
    }
    DeclareFunctionStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareFunctionStmt(this, context);
    };
    return DeclareFunctionStmt;
  }(Statement));
  exports.DeclareFunctionStmt = DeclareFunctionStmt;
  var ExpressionStatement = (function(_super) {
    __extends(ExpressionStatement, _super);
    function ExpressionStatement(expr) {
      _super.call(this);
      this.expr = expr;
    }
    ExpressionStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitExpressionStmt(this, context);
    };
    return ExpressionStatement;
  }(Statement));
  exports.ExpressionStatement = ExpressionStatement;
  var ReturnStatement = (function(_super) {
    __extends(ReturnStatement, _super);
    function ReturnStatement(value) {
      _super.call(this);
      this.value = value;
    }
    ReturnStatement.prototype.visitStatement = function(visitor, context) {
      return visitor.visitReturnStmt(this, context);
    };
    return ReturnStatement;
  }(Statement));
  exports.ReturnStatement = ReturnStatement;
  var AbstractClassPart = (function() {
    function AbstractClassPart(type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      this.type = type;
      this.modifiers = modifiers;
      if (lang_1.isBlank(modifiers)) {
        this.modifiers = [];
      }
    }
    AbstractClassPart.prototype.hasModifier = function(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    };
    return AbstractClassPart;
  }());
  exports.AbstractClassPart = AbstractClassPart;
  var ClassField = (function(_super) {
    __extends(ClassField, _super);
    function ClassField(name, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
    }
    return ClassField;
  }(AbstractClassPart));
  exports.ClassField = ClassField;
  var ClassMethod = (function(_super) {
    __extends(ClassMethod, _super);
    function ClassMethod(name, params, body, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
      this.params = params;
      this.body = body;
    }
    return ClassMethod;
  }(AbstractClassPart));
  exports.ClassMethod = ClassMethod;
  var ClassGetter = (function(_super) {
    __extends(ClassGetter, _super);
    function ClassGetter(name, body, type, modifiers) {
      if (type === void 0) {
        type = null;
      }
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, type, modifiers);
      this.name = name;
      this.body = body;
    }
    return ClassGetter;
  }(AbstractClassPart));
  exports.ClassGetter = ClassGetter;
  var ClassStmt = (function(_super) {
    __extends(ClassStmt, _super);
    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
      if (modifiers === void 0) {
        modifiers = null;
      }
      _super.call(this, modifiers);
      this.name = name;
      this.parent = parent;
      this.fields = fields;
      this.getters = getters;
      this.constructorMethod = constructorMethod;
      this.methods = methods;
    }
    ClassStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitDeclareClassStmt(this, context);
    };
    return ClassStmt;
  }(Statement));
  exports.ClassStmt = ClassStmt;
  var IfStmt = (function(_super) {
    __extends(IfStmt, _super);
    function IfStmt(condition, trueCase, falseCase) {
      if (falseCase === void 0) {
        falseCase = [];
      }
      _super.call(this);
      this.condition = condition;
      this.trueCase = trueCase;
      this.falseCase = falseCase;
    }
    IfStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitIfStmt(this, context);
    };
    return IfStmt;
  }(Statement));
  exports.IfStmt = IfStmt;
  var CommentStmt = (function(_super) {
    __extends(CommentStmt, _super);
    function CommentStmt(comment) {
      _super.call(this);
      this.comment = comment;
    }
    CommentStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitCommentStmt(this, context);
    };
    return CommentStmt;
  }(Statement));
  exports.CommentStmt = CommentStmt;
  var TryCatchStmt = (function(_super) {
    __extends(TryCatchStmt, _super);
    function TryCatchStmt(bodyStmts, catchStmts) {
      _super.call(this);
      this.bodyStmts = bodyStmts;
      this.catchStmts = catchStmts;
    }
    TryCatchStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitTryCatchStmt(this, context);
    };
    return TryCatchStmt;
  }(Statement));
  exports.TryCatchStmt = TryCatchStmt;
  var ThrowStmt = (function(_super) {
    __extends(ThrowStmt, _super);
    function ThrowStmt(error) {
      _super.call(this);
      this.error = error;
    }
    ThrowStmt.prototype.visitStatement = function(visitor, context) {
      return visitor.visitThrowStmt(this, context);
    };
    return ThrowStmt;
  }(Statement));
  exports.ThrowStmt = ThrowStmt;
  var ExpressionTransformer = (function() {
    function ExpressionTransformer() {}
    ExpressionTransformer.prototype.visitReadVarExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitWriteVarExpr = function(expr, context) {
      return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWriteKeyExpr = function(expr, context) {
      return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWritePropExpr = function(expr, context) {
      return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitInvokeMethodExpr = function(ast, context) {
      var method = lang_1.isPresent(ast.builtin) ? ast.builtin : ast.name;
      return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInvokeFunctionExpr = function(ast, context) {
      return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInstantiateExpr = function(ast, context) {
      return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitExternalExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitConditionalExpr = function(ast, context) {
      return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitNotExpr = function(ast, context) {
      return new NotExpr(ast.condition.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCastExpr = function(ast, context) {
      return new CastExpr(ast.value.visitExpression(this, context), context);
    };
    ExpressionTransformer.prototype.visitFunctionExpr = function(ast, context) {
      return ast;
    };
    ExpressionTransformer.prototype.visitBinaryOperatorExpr = function(ast, context) {
      return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitReadPropExpr = function(ast, context) {
      return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
    };
    ExpressionTransformer.prototype.visitReadKeyExpr = function(ast, context) {
      return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralArrayExpr = function(ast, context) {
      return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
    };
    ExpressionTransformer.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      return new LiteralMapExpr(ast.entries.map(function(entry) {
        return [entry[0], entry[1].visitExpression(_this, context)];
      }));
    };
    ExpressionTransformer.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      return exprs.map(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    ExpressionTransformer.prototype.visitDeclareVarStmt = function(stmt, context) {
      return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
    };
    ExpressionTransformer.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitExpressionStmt = function(stmt, context) {
      return new ExpressionStatement(stmt.expr.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitReturnStmt = function(stmt, context) {
      return new ReturnStatement(stmt.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitDeclareClassStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitIfStmt = function(stmt, context) {
      return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
    };
    ExpressionTransformer.prototype.visitTryCatchStmt = function(stmt, context) {
      return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
    };
    ExpressionTransformer.prototype.visitThrowStmt = function(stmt, context) {
      return new ThrowStmt(stmt.error.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCommentStmt = function(stmt, context) {
      return stmt;
    };
    ExpressionTransformer.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      return stmts.map(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return ExpressionTransformer;
  }());
  exports.ExpressionTransformer = ExpressionTransformer;
  var RecursiveExpressionVisitor = (function() {
    function RecursiveExpressionVisitor() {}
    RecursiveExpressionVisitor.prototype.visitReadVarExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function(expr, context) {
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.index.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWritePropExpr = function(expr, context) {
      expr.receiver.visitExpression(this, context);
      expr.value.visitExpression(this, context);
      return expr;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function(ast, context) {
      ast.fn.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function(ast, context) {
      ast.classExpr.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitExternalExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitConditionalExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      ast.trueCase.visitExpression(this, context);
      ast.falseCase.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitNotExpr = function(ast, context) {
      ast.condition.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitCastExpr = function(ast, context) {
      ast.value.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitFunctionExpr = function(ast, context) {
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function(ast, context) {
      ast.lhs.visitExpression(this, context);
      ast.rhs.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadPropExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.index.visitExpression(this, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function(ast, context) {
      this.visitAllExpressions(ast.entries, context);
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function(ast, context) {
      var _this = this;
      ast.entries.forEach(function(entry) {
        return entry[1].visitExpression(_this, context);
      });
      return ast;
    };
    RecursiveExpressionVisitor.prototype.visitAllExpressions = function(exprs, context) {
      var _this = this;
      exprs.forEach(function(expr) {
        return expr.visitExpression(_this, context);
      });
    };
    RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitExpressionStmt = function(stmt, context) {
      stmt.expr.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitReturnStmt = function(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitIfStmt = function(stmt, context) {
      stmt.condition.visitExpression(this, context);
      this.visitAllStatements(stmt.trueCase, context);
      this.visitAllStatements(stmt.falseCase, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function(stmt, context) {
      this.visitAllStatements(stmt.bodyStmts, context);
      this.visitAllStatements(stmt.catchStmts, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitThrowStmt = function(stmt, context) {
      stmt.error.visitExpression(this, context);
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitCommentStmt = function(stmt, context) {
      return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitAllStatements = function(stmts, context) {
      var _this = this;
      stmts.forEach(function(stmt) {
        return stmt.visitStatement(_this, context);
      });
    };
    return RecursiveExpressionVisitor;
  }());
  exports.RecursiveExpressionVisitor = RecursiveExpressionVisitor;
  function replaceVarInExpression(varName, newValue, expression) {
    var transformer = new _ReplaceVariableTransformer(varName, newValue);
    return expression.visitExpression(transformer, null);
  }
  exports.replaceVarInExpression = replaceVarInExpression;
  var _ReplaceVariableTransformer = (function(_super) {
    __extends(_ReplaceVariableTransformer, _super);
    function _ReplaceVariableTransformer(_varName, _newValue) {
      _super.call(this);
      this._varName = _varName;
      this._newValue = _newValue;
    }
    _ReplaceVariableTransformer.prototype.visitReadVarExpr = function(ast, context) {
      return ast.name == this._varName ? this._newValue : ast;
    };
    return _ReplaceVariableTransformer;
  }(ExpressionTransformer));
  function findReadVarNames(stmts) {
    var finder = new _VariableFinder();
    finder.visitAllStatements(stmts, null);
    return finder.varNames;
  }
  exports.findReadVarNames = findReadVarNames;
  var _VariableFinder = (function(_super) {
    __extends(_VariableFinder, _super);
    function _VariableFinder() {
      _super.apply(this, arguments);
      this.varNames = new Set();
    }
    _VariableFinder.prototype.visitReadVarExpr = function(ast, context) {
      this.varNames.add(ast.name);
      return null;
    };
    return _VariableFinder;
  }(RecursiveExpressionVisitor));
  function variable(name, type) {
    if (type === void 0) {
      type = null;
    }
    return new ReadVarExpr(name, type);
  }
  exports.variable = variable;
  function importExpr(id, typeParams) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    return new ExternalExpr(id, null, typeParams);
  }
  exports.importExpr = importExpr;
  function importType(id, typeParams, typeModifiers) {
    if (typeParams === void 0) {
      typeParams = null;
    }
    if (typeModifiers === void 0) {
      typeModifiers = null;
    }
    return lang_1.isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
  }
  exports.importType = importType;
  function literalArr(values, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralArrayExpr(values, type);
  }
  exports.literalArr = literalArr;
  function literalMap(values, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralMapExpr(values, type);
  }
  exports.literalMap = literalMap;
  function not(expr) {
    return new NotExpr(expr);
  }
  exports.not = not;
  function fn(params, body, type) {
    if (type === void 0) {
      type = null;
    }
    return new FunctionExpr(params, body, type);
  }
  exports.fn = fn;
  function literal(value, type) {
    if (type === void 0) {
      type = null;
    }
    return new LiteralExpr(value, type);
  }
  exports.literal = literal;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/util.js", ["./facade/collection", "./facade/lang", "./output/output_ast"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('./facade/collection');
  var lang_1 = $__require('./facade/lang');
  var o = $__require('./output/output_ast');
  exports.MODULE_SUFFIX = '';
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function(m) {
      return '-' + m[1].toLowerCase();
    });
  }
  exports.camelCaseToDashCase = camelCaseToDashCase;
  function splitAtColon(input, defaultValues) {
    var colonIndex = input.indexOf(':');
    if (colonIndex == -1)
      return defaultValues;
    return [input.slice(0, colonIndex).trim(), input.slice(colonIndex + 1).trim()];
  }
  exports.splitAtColon = splitAtColon;
  function sanitizeIdentifier(name) {
    return lang_1.StringWrapper.replaceAll(name, /\W/g, '_');
  }
  exports.sanitizeIdentifier = sanitizeIdentifier;
  function visitValue(value, visitor, context) {
    if (lang_1.isArray(value)) {
      return visitor.visitArray(value, context);
    } else if (lang_1.isStrictStringMap(value)) {
      return visitor.visitStringMap(value, context);
    } else if (lang_1.isBlank(value) || lang_1.isPrimitive(value)) {
      return visitor.visitPrimitive(value, context);
    } else {
      return visitor.visitOther(value, context);
    }
  }
  exports.visitValue = visitValue;
  var ValueTransformer = (function() {
    function ValueTransformer() {}
    ValueTransformer.prototype.visitArray = function(arr, context) {
      var _this = this;
      return arr.map(function(value) {
        return visitValue(value, _this, context);
      });
    };
    ValueTransformer.prototype.visitStringMap = function(map, context) {
      var _this = this;
      var result = {};
      collection_1.StringMapWrapper.forEach(map, function(value, key) {
        result[key] = visitValue(value, _this, context);
      });
      return result;
    };
    ValueTransformer.prototype.visitPrimitive = function(value, context) {
      return value;
    };
    ValueTransformer.prototype.visitOther = function(value, context) {
      return value;
    };
    return ValueTransformer;
  }());
  exports.ValueTransformer = ValueTransformer;
  function assetUrl(pkg, path, type) {
    if (path === void 0) {
      path = null;
    }
    if (type === void 0) {
      type = 'src';
    }
    if (path == null) {
      return "asset:@angular/lib/" + pkg + "/index";
    } else {
      return "asset:@angular/lib/" + pkg + "/src/" + path;
    }
  }
  exports.assetUrl = assetUrl;
  function createDiTokenExpression(token) {
    if (lang_1.isPresent(token.value)) {
      return o.literal(token.value);
    } else if (token.identifierIsInstance) {
      return o.importExpr(token.identifier).instantiate([], o.importType(token.identifier, [], [o.TypeModifier.Const]));
    } else {
      return o.importExpr(token.identifier);
    }
  }
  exports.createDiTokenExpression = createDiTokenExpression;
  var SyncAsyncResult = (function() {
    function SyncAsyncResult(syncResult, asyncResult) {
      if (asyncResult === void 0) {
        asyncResult = null;
      }
      this.syncResult = syncResult;
      this.asyncResult = asyncResult;
      if (!asyncResult) {
        this.asyncResult = Promise.resolve(syncResult);
      }
    }
    return SyncAsyncResult;
  }());
  exports.SyncAsyncResult = SyncAsyncResult;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/util.js", ["../facade/exceptions", "../facade/lang", "../identifiers", "../output/output_ast", "../util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var util_1 = $__require('../util');
  function getPropertyInView(property, callingView, definedView) {
    if (callingView === definedView) {
      return property;
    } else {
      var viewProp = o.THIS_EXPR;
      var currView = callingView;
      while (currView !== definedView && lang_1.isPresent(currView.declarationElement.view)) {
        currView = currView.declarationElement.view;
        viewProp = viewProp.prop('parent');
      }
      if (currView !== definedView) {
        throw new exceptions_1.BaseException("Internal error: Could not calculate a property in a parent view: " + property);
      }
      if (property instanceof o.ReadPropExpr) {
        var readPropExpr_1 = property;
        if (definedView.fields.some(function(field) {
          return field.name == readPropExpr_1.name;
        }) || definedView.getters.some(function(field) {
          return field.name == readPropExpr_1.name;
        })) {
          viewProp = viewProp.cast(definedView.classType);
        }
      }
      return o.replaceVarInExpression(o.THIS_EXPR.name, viewProp, property);
    }
  }
  exports.getPropertyInView = getPropertyInView;
  function injectFromViewParentInjector(token, optional) {
    var args = [util_1.createDiTokenExpression(token)];
    if (optional) {
      args.push(o.NULL_EXPR);
    }
    return o.THIS_EXPR.prop('parentInjector').callMethod('get', args);
  }
  exports.injectFromViewParentInjector = injectFromViewParentInjector;
  function getViewFactoryName(component, embeddedTemplateIndex) {
    return "viewFactory_" + component.type.name + embeddedTemplateIndex;
  }
  exports.getViewFactoryName = getViewFactoryName;
  function createFlatArray(expressions) {
    var lastNonArrayExpressions = [];
    var result = o.literalArr([]);
    for (var i = 0; i < expressions.length; i++) {
      var expr = expressions[i];
      if (expr.type instanceof o.ArrayType) {
        if (lastNonArrayExpressions.length > 0) {
          result = result.callMethod(o.BuiltinMethod.ConcatArray, [o.literalArr(lastNonArrayExpressions)]);
          lastNonArrayExpressions = [];
        }
        result = result.callMethod(o.BuiltinMethod.ConcatArray, [expr]);
      } else {
        lastNonArrayExpressions.push(expr);
      }
    }
    if (lastNonArrayExpressions.length > 0) {
      result = result.callMethod(o.BuiltinMethod.ConcatArray, [o.literalArr(lastNonArrayExpressions)]);
    }
    return result;
  }
  exports.createFlatArray = createFlatArray;
  function createPureProxy(fn, argCount, pureProxyProp, view) {
    view.fields.push(new o.ClassField(pureProxyProp.name, null));
    var pureProxyId = argCount < identifiers_1.Identifiers.pureProxies.length ? identifiers_1.Identifiers.pureProxies[argCount] : null;
    if (lang_1.isBlank(pureProxyId)) {
      throw new exceptions_1.BaseException("Unsupported number of argument for pure functions: " + argCount);
    }
    view.createMethod.addStmt(o.THIS_EXPR.prop(pureProxyProp.name).set(o.importExpr(pureProxyId).callFn([fn])).toStmt());
  }
  exports.createPureProxy = createPureProxy;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/view_builder.js", ["@angular/core", "../../core_private", "../animation/animation_compiler", "../compile_metadata", "../facade/collection", "../facade/lang", "../identifiers", "../output/output_ast", "../template_parser/template_ast", "../util", "./compile_element", "./compile_view", "./constants", "./util"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var core_private_1 = $__require('../../core_private');
  var animation_compiler_1 = $__require('../animation/animation_compiler');
  var compile_metadata_1 = $__require('../compile_metadata');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var identifiers_1 = $__require('../identifiers');
  var o = $__require('../output/output_ast');
  var template_ast_1 = $__require('../template_parser/template_ast');
  var util_1 = $__require('../util');
  var compile_element_1 = $__require('./compile_element');
  var compile_view_1 = $__require('./compile_view');
  var constants_1 = $__require('./constants');
  var util_2 = $__require('./util');
  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
  var CLASS_ATTR = 'class';
  var STYLE_ATTR = 'style';
  var NG_CONTAINER_TAG = 'ng-container';
  var parentRenderNodeVar = o.variable('parentRenderNode');
  var rootSelectorVar = o.variable('rootSelector');
  var ViewFactoryDependency = (function() {
    function ViewFactoryDependency(comp, placeholder) {
      this.comp = comp;
      this.placeholder = placeholder;
    }
    return ViewFactoryDependency;
  }());
  exports.ViewFactoryDependency = ViewFactoryDependency;
  var ComponentFactoryDependency = (function() {
    function ComponentFactoryDependency(comp, placeholder) {
      this.comp = comp;
      this.placeholder = placeholder;
    }
    return ComponentFactoryDependency;
  }());
  exports.ComponentFactoryDependency = ComponentFactoryDependency;
  function buildView(view, template, targetDependencies) {
    var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
    template_ast_1.templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
    return builderVisitor.nestedViewCount;
  }
  exports.buildView = buildView;
  function finishView(view, targetStatements) {
    view.afterNodes();
    createViewTopLevelStmts(view, targetStatements);
    view.nodes.forEach(function(node) {
      if (node instanceof compile_element_1.CompileElement && node.hasEmbeddedView) {
        finishView(node.embeddedView, targetStatements);
      }
    });
  }
  exports.finishView = finishView;
  var ViewBuilderVisitor = (function() {
    function ViewBuilderVisitor(view, targetDependencies) {
      this.view = view;
      this.targetDependencies = targetDependencies;
      this.nestedViewCount = 0;
      this._animationCompiler = new animation_compiler_1.AnimationCompiler();
    }
    ViewBuilderVisitor.prototype._isRootNode = function(parent) {
      return parent.view !== this.view;
    };
    ViewBuilderVisitor.prototype._addRootNodeAndProject = function(node) {
      var projectedNode = _getOuterContainerOrSelf(node);
      var parent = projectedNode.parent;
      var ngContentIndex = projectedNode.sourceAst.ngContentIndex;
      var vcAppEl = (node instanceof compile_element_1.CompileElement && node.hasViewContainer) ? node.appElement : null;
      if (this._isRootNode(parent)) {
        if (this.view.viewType !== core_private_1.ViewType.COMPONENT) {
          this.view.rootNodesOrAppElements.push(lang_1.isPresent(vcAppEl) ? vcAppEl : node.renderNode);
        }
      } else if (lang_1.isPresent(parent.component) && lang_1.isPresent(ngContentIndex)) {
        parent.addContentNode(ngContentIndex, lang_1.isPresent(vcAppEl) ? vcAppEl : node.renderNode);
      }
    };
    ViewBuilderVisitor.prototype._getParentRenderNode = function(parent) {
      parent = _getOuterContainerParentOrSelf(parent);
      if (this._isRootNode(parent)) {
        if (this.view.viewType === core_private_1.ViewType.COMPONENT) {
          return parentRenderNodeVar;
        } else {
          return o.NULL_EXPR;
        }
      } else {
        return lang_1.isPresent(parent.component) && parent.component.template.encapsulation !== core_1.ViewEncapsulation.Native ? o.NULL_EXPR : parent.renderNode;
      }
    };
    ViewBuilderVisitor.prototype.visitBoundText = function(ast, parent) {
      return this._visitText(ast, '', parent);
    };
    ViewBuilderVisitor.prototype.visitText = function(ast, parent) {
      return this._visitText(ast, ast.value, parent);
    };
    ViewBuilderVisitor.prototype._visitText = function(ast, value, parent) {
      var fieldName = "_text_" + this.view.nodes.length;
      this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderText)));
      var renderNode = o.THIS_EXPR.prop(fieldName);
      var compileNode = new compile_element_1.CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
      var createRenderNode = o.THIS_EXPR.prop(fieldName).set(constants_1.ViewProperties.renderer.callMethod('createText', [this._getParentRenderNode(parent), o.literal(value), this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)])).toStmt();
      this.view.nodes.push(compileNode);
      this.view.createMethod.addStmt(createRenderNode);
      this._addRootNodeAndProject(compileNode);
      return renderNode;
    };
    ViewBuilderVisitor.prototype.visitNgContent = function(ast, parent) {
      this.view.createMethod.resetDebugInfo(null, ast);
      var parentRenderNode = this._getParentRenderNode(parent);
      var nodesExpression = constants_1.ViewProperties.projectableNodes.key(o.literal(ast.index), new o.ArrayType(o.importType(this.view.genConfig.renderTypes.renderNode)));
      if (parentRenderNode !== o.NULL_EXPR) {
        this.view.createMethod.addStmt(constants_1.ViewProperties.renderer.callMethod('projectNodes', [parentRenderNode, o.importExpr(identifiers_1.Identifiers.flattenNestedViewRenderNodes).callFn([nodesExpression])]).toStmt());
      } else if (this._isRootNode(parent)) {
        if (this.view.viewType !== core_private_1.ViewType.COMPONENT) {
          this.view.rootNodesOrAppElements.push(nodesExpression);
        }
      } else {
        if (lang_1.isPresent(parent.component) && lang_1.isPresent(ast.ngContentIndex)) {
          parent.addContentNode(ast.ngContentIndex, nodesExpression);
        }
      }
      return null;
    };
    ViewBuilderVisitor.prototype.visitElement = function(ast, parent) {
      var _this = this;
      var nodeIndex = this.view.nodes.length;
      var createRenderNodeExpr;
      var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
      if (nodeIndex === 0 && this.view.viewType === core_private_1.ViewType.HOST) {
        createRenderNodeExpr = o.THIS_EXPR.callMethod('selectOrCreateHostElement', [o.literal(ast.name), rootSelectorVar, debugContextExpr]);
      } else {
        if (ast.name === NG_CONTAINER_TAG) {
          createRenderNodeExpr = constants_1.ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
        } else {
          createRenderNodeExpr = constants_1.ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), o.literal(ast.name), debugContextExpr]);
        }
      }
      var fieldName = "_el_" + nodeIndex;
      this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderElement)));
      this.view.createMethod.addStmt(o.THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
      var renderNode = o.THIS_EXPR.prop(fieldName);
      var directives = ast.directives.map(function(directiveAst) {
        return directiveAst.directive;
      });
      var component = directives.find(function(directive) {
        return directive.isComponent;
      });
      var htmlAttrs = _readHtmlAttrs(ast.attrs);
      var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
      for (var i = 0; i < attrNameAndValues.length; i++) {
        var attrName = attrNameAndValues[i][0];
        var attrValue = attrNameAndValues[i][1];
        this.view.createMethod.addStmt(constants_1.ViewProperties.renderer.callMethod('setElementAttribute', [renderNode, o.literal(attrName), o.literal(attrValue)]).toStmt());
      }
      var compileElement = new compile_element_1.CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
      this.view.nodes.push(compileElement);
      var compViewExpr = null;
      if (lang_1.isPresent(component)) {
        var nestedComponentIdentifier = new compile_metadata_1.CompileIdentifierMetadata({name: util_2.getViewFactoryName(component, 0)});
        this.targetDependencies.push(new ViewFactoryDependency(component.type, nestedComponentIdentifier));
        var entryComponentIdentifiers = component.entryComponents.map(function(entryComponent) {
          var id = new compile_metadata_1.CompileIdentifierMetadata({name: entryComponent.name});
          _this.targetDependencies.push(new ComponentFactoryDependency(entryComponent, id));
          return id;
        });
        compileElement.createComponentFactoryResolver(entryComponentIdentifiers);
        compViewExpr = o.variable("compView_" + nodeIndex);
        compileElement.setComponentView(compViewExpr);
        this.view.createMethod.addStmt(compViewExpr.set(o.importExpr(nestedComponentIdentifier).callFn([constants_1.ViewProperties.viewUtils, compileElement.injector, compileElement.appElement])).toDeclStmt());
      }
      compileElement.beforeChildren();
      this._addRootNodeAndProject(compileElement);
      template_ast_1.templateVisitAll(this, ast.children, compileElement);
      compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
      if (lang_1.isPresent(compViewExpr)) {
        var codeGenContentNodes;
        if (this.view.component.type.isHost) {
          codeGenContentNodes = constants_1.ViewProperties.projectableNodes;
        } else {
          codeGenContentNodes = o.literalArr(compileElement.contentNodesByNgContentIndex.map(function(nodes) {
            return util_2.createFlatArray(nodes);
          }));
        }
        this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent(), codeGenContentNodes, o.NULL_EXPR]).toStmt());
      }
      return null;
    };
    ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function(ast, parent) {
      var nodeIndex = this.view.nodes.length;
      var fieldName = "_anchor_" + nodeIndex;
      this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderComment)));
      this.view.createMethod.addStmt(o.THIS_EXPR.prop(fieldName).set(constants_1.ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)])).toStmt());
      var renderNode = o.THIS_EXPR.prop(fieldName);
      var templateVariableBindings = ast.variables.map(function(varAst) {
        return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name];
      });
      var directives = ast.directives.map(function(directiveAst) {
        return directiveAst.directive;
      });
      var compileElement = new compile_element_1.CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
      this.view.nodes.push(compileElement);
      var compiledAnimations = this._animationCompiler.compileComponent(this.view.component, [ast]);
      this.nestedViewCount++;
      var embeddedView = new compile_view_1.CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, o.NULL_EXPR, compiledAnimations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
      this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
      compileElement.beforeChildren();
      this._addRootNodeAndProject(compileElement);
      compileElement.afterChildren(0);
      return null;
    };
    ViewBuilderVisitor.prototype.visitAttr = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitDirective = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitEvent = function(ast, eventTargetAndNames) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitReference = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitVariable = function(ast, ctx) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitDirectiveProperty = function(ast, context) {
      return null;
    };
    ViewBuilderVisitor.prototype.visitElementProperty = function(ast, context) {
      return null;
    };
    return ViewBuilderVisitor;
  }());
  function _getOuterContainerOrSelf(node) {
    var view = node.view;
    while (_isNgContainer(node.parent, view)) {
      node = node.parent;
    }
    return node;
  }
  function _getOuterContainerParentOrSelf(el) {
    var view = el.view;
    while (_isNgContainer(el, view)) {
      el = el.parent;
    }
    return el;
  }
  function _isNgContainer(node, view) {
    return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG && node.view === view;
  }
  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
    var result = {};
    collection_1.StringMapWrapper.forEach(declaredHtmlAttrs, function(value, key) {
      result[key] = value;
    });
    directives.forEach(function(directiveMeta) {
      collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, function(value, name) {
        var prevValue = result[name];
        result[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
      });
    });
    return mapToKeyValueArray(result);
  }
  function _readHtmlAttrs(attrs) {
    var htmlAttrs = {};
    attrs.forEach(function(ast) {
      htmlAttrs[ast.name] = ast.value;
    });
    return htmlAttrs;
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
      return attrValue1 + " " + attrValue2;
    } else {
      return attrValue2;
    }
  }
  function mapToKeyValueArray(data) {
    var entryArray = [];
    collection_1.StringMapWrapper.forEach(data, function(value, name) {
      entryArray.push([name, value]);
    });
    collection_1.ListWrapper.sort(entryArray, function(entry1, entry2) {
      return lang_1.StringWrapper.compare(entry1[0], entry2[0]);
    });
    return entryArray;
  }
  function createViewTopLevelStmts(view, targetStatements) {
    var nodeDebugInfosVar = o.NULL_EXPR;
    if (view.genConfig.genDebugInfo) {
      nodeDebugInfosVar = o.variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex);
      targetStatements.push(nodeDebugInfosVar.set(o.literalArr(view.nodes.map(createStaticNodeDebugInfo), new o.ArrayType(new o.ExternalType(identifiers_1.Identifiers.StaticNodeDebugInfo), [o.TypeModifier.Const]))).toDeclStmt(null, [o.StmtModifier.Final]));
    }
    var renderCompTypeVar = o.variable("renderType_" + view.component.type.name);
    if (view.viewIndex === 0) {
      targetStatements.push(renderCompTypeVar.set(o.NULL_EXPR).toDeclStmt(o.importType(identifiers_1.Identifiers.RenderComponentType)));
    }
    var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
    targetStatements.push(viewClass);
    targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
  }
  function createStaticNodeDebugInfo(node) {
    var compileElement = node instanceof compile_element_1.CompileElement ? node : null;
    var providerTokens = [];
    var componentToken = o.NULL_EXPR;
    var varTokenEntries = [];
    if (lang_1.isPresent(compileElement)) {
      providerTokens = compileElement.getProviderTokens();
      if (lang_1.isPresent(compileElement.component)) {
        componentToken = util_1.createDiTokenExpression(identifiers_1.identifierToken(compileElement.component.type));
      }
      collection_1.StringMapWrapper.forEach(compileElement.referenceTokens, function(token, varName) {
        varTokenEntries.push([varName, lang_1.isPresent(token) ? util_1.createDiTokenExpression(token) : o.NULL_EXPR]);
      });
    }
    return o.importExpr(identifiers_1.Identifiers.StaticNodeDebugInfo).instantiate([o.literalArr(providerTokens, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])), componentToken, o.literalMap(varTokenEntries, new o.MapType(o.DYNAMIC_TYPE, [o.TypeModifier.Const]))], o.importType(identifiers_1.Identifiers.StaticNodeDebugInfo, null, [o.TypeModifier.Const]));
  }
  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
    var viewConstructorArgs = [new o.FnParam(constants_1.ViewConstructorVars.viewUtils.name, o.importType(identifiers_1.Identifiers.ViewUtils)), new o.FnParam(constants_1.ViewConstructorVars.parentInjector.name, o.importType(identifiers_1.Identifiers.Injector)), new o.FnParam(constants_1.ViewConstructorVars.declarationEl.name, o.importType(identifiers_1.Identifiers.AppElement))];
    var superConstructorArgs = [o.variable(view.className), renderCompTypeVar, constants_1.ViewTypeEnum.fromValue(view.viewType), constants_1.ViewConstructorVars.viewUtils, constants_1.ViewConstructorVars.parentInjector, constants_1.ViewConstructorVars.declarationEl, constants_1.ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))];
    if (view.genConfig.genDebugInfo) {
      superConstructorArgs.push(nodeDebugInfosVar);
    }
    var viewConstructor = new o.ClassMethod(null, viewConstructorArgs, [o.SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
    var viewMethods = [new o.ClassMethod('createInternal', [new o.FnParam(rootSelectorVar.name, o.STRING_TYPE)], generateCreateMethod(view), o.importType(identifiers_1.Identifiers.AppElement)), new o.ClassMethod('injectorGetInternal', [new o.FnParam(constants_1.InjectMethodVars.token.name, o.DYNAMIC_TYPE), new o.FnParam(constants_1.InjectMethodVars.requestNodeIndex.name, o.NUMBER_TYPE), new o.FnParam(constants_1.InjectMethodVars.notFoundResult.name, o.DYNAMIC_TYPE)], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), constants_1.InjectMethodVars.notFoundResult), o.DYNAMIC_TYPE), new o.ClassMethod('detectChangesInternal', [new o.FnParam(constants_1.DetectChangesVars.throwOnChange.name, o.BOOL_TYPE)], generateDetectChangesMethod(view)), new o.ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()), new o.ClassMethod('destroyInternal', [], view.destroyMethod.finish()), new o.ClassMethod('detachInternal', [], view.detachMethod.finish())].concat(view.eventHandlerMethods);
    var superClass = view.genConfig.genDebugInfo ? identifiers_1.Identifiers.DebugAppView : identifiers_1.Identifiers.AppView;
    var viewClass = new o.ClassStmt(view.className, o.importExpr(superClass, [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function(method) {
      return method.body.length > 0;
    }));
    return viewClass;
  }
  function createViewFactory(view, viewClass, renderCompTypeVar) {
    var viewFactoryArgs = [new o.FnParam(constants_1.ViewConstructorVars.viewUtils.name, o.importType(identifiers_1.Identifiers.ViewUtils)), new o.FnParam(constants_1.ViewConstructorVars.parentInjector.name, o.importType(identifiers_1.Identifiers.Injector)), new o.FnParam(constants_1.ViewConstructorVars.declarationEl.name, o.importType(identifiers_1.Identifiers.AppElement))];
    var initRenderCompTypeStmts = [];
    var templateUrlInfo;
    if (view.component.template.templateUrl == view.component.type.moduleUrl) {
      templateUrlInfo = view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
    } else {
      templateUrlInfo = view.component.template.templateUrl;
    }
    if (view.viewIndex === 0) {
      var animationsExpr = o.literalMap(view.animations.map(function(entry) {
        return [entry.name, entry.fnVariable];
      }));
      initRenderCompTypeStmts = [new o.IfStmt(renderCompTypeVar.identical(o.NULL_EXPR), [renderCompTypeVar.set(constants_1.ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [o.literal(templateUrlInfo), o.literal(view.component.template.ngContentSelectors.length), constants_1.ViewEncapsulationEnum.fromValue(view.component.template.encapsulation), view.styles, animationsExpr])).toStmt()])];
    }
    return o.fn(viewFactoryArgs, initRenderCompTypeStmts.concat([new o.ReturnStatement(o.variable(viewClass.name).instantiate(viewClass.constructorMethod.params.map(function(param) {
      return o.variable(param.name);
    })))]), o.importType(identifiers_1.Identifiers.AppView, [getContextType(view)])).toDeclStmt(view.viewFactory.name, [o.StmtModifier.Final]);
  }
  function generateCreateMethod(view) {
    var parentRenderNodeExpr = o.NULL_EXPR;
    var parentRenderNodeStmts = [];
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
      parentRenderNodeExpr = constants_1.ViewProperties.renderer.callMethod('createViewRoot', [o.THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
      parentRenderNodeStmts = [parentRenderNodeVar.set(parentRenderNodeExpr).toDeclStmt(o.importType(view.genConfig.renderTypes.renderNode), [o.StmtModifier.Final])];
    }
    var resultExpr;
    if (view.viewType === core_private_1.ViewType.HOST) {
      resultExpr = view.nodes[0].appElement;
    } else {
      resultExpr = o.NULL_EXPR;
    }
    return parentRenderNodeStmts.concat(view.createMethod.finish(), [o.THIS_EXPR.callMethod('init', [util_2.createFlatArray(view.rootNodesOrAppElements), o.literalArr(view.nodes.map(function(node) {
      return node.renderNode;
    })), o.literalArr(view.disposables), o.literalArr(view.subscriptions)]).toStmt(), new o.ReturnStatement(resultExpr)]);
  }
  function generateDetectChangesMethod(view) {
    var stmts = [];
    if (view.detectChangesInInputsMethod.isEmpty() && view.updateContentQueriesMethod.isEmpty() && view.afterContentLifecycleCallbacksMethod.isEmpty() && view.detectChangesRenderPropertiesMethod.isEmpty() && view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
      return stmts;
    }
    collection_1.ListWrapper.addAll(stmts, view.detectChangesInInputsMethod.finish());
    stmts.push(o.THIS_EXPR.callMethod('detectContentChildrenChanges', [constants_1.DetectChangesVars.throwOnChange]).toStmt());
    var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
    if (afterContentStmts.length > 0) {
      stmts.push(new o.IfStmt(o.not(constants_1.DetectChangesVars.throwOnChange), afterContentStmts));
    }
    collection_1.ListWrapper.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
    stmts.push(o.THIS_EXPR.callMethod('detectViewChildrenChanges', [constants_1.DetectChangesVars.throwOnChange]).toStmt());
    var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
    if (afterViewStmts.length > 0) {
      stmts.push(new o.IfStmt(o.not(constants_1.DetectChangesVars.throwOnChange), afterViewStmts));
    }
    var varStmts = [];
    var readVars = o.findReadVarNames(stmts);
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.changed.name)) {
      varStmts.push(constants_1.DetectChangesVars.changed.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE));
    }
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.changes.name)) {
      varStmts.push(constants_1.DetectChangesVars.changes.set(o.NULL_EXPR).toDeclStmt(new o.MapType(o.importType(identifiers_1.Identifiers.SimpleChange))));
    }
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.valUnwrapper.name)) {
      varStmts.push(constants_1.DetectChangesVars.valUnwrapper.set(o.importExpr(identifiers_1.Identifiers.ValueUnwrapper).instantiate([])).toDeclStmt(null, [o.StmtModifier.Final]));
    }
    return varStmts.concat(stmts);
  }
  function addReturnValuefNotEmpty(statements, value) {
    if (statements.length > 0) {
      return statements.concat([new o.ReturnStatement(value)]);
    } else {
      return statements;
    }
  }
  function getContextType(view) {
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
      return o.importType(view.component.type);
    }
    return o.DYNAMIC_TYPE;
  }
  function getChangeDetectionMode(view) {
    var mode;
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
      mode = core_private_1.isDefaultChangeDetectionStrategy(view.component.changeDetection) ? core_private_1.ChangeDetectorStatus.CheckAlways : core_private_1.ChangeDetectorStatus.CheckOnce;
    } else {
      mode = core_private_1.ChangeDetectorStatus.CheckAlways;
    }
    return mode;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/src/view_compiler/view_compiler.js", ["@angular/core", "../animation/animation_compiler", "../config", "./compile_element", "./compile_view", "./view_binder", "./view_builder"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var core_1 = $__require('@angular/core');
  var animation_compiler_1 = $__require('../animation/animation_compiler');
  var config_1 = $__require('../config');
  var compile_element_1 = $__require('./compile_element');
  var compile_view_1 = $__require('./compile_view');
  var view_binder_1 = $__require('./view_binder');
  var view_builder_1 = $__require('./view_builder');
  var view_builder_2 = $__require('./view_builder');
  exports.ComponentFactoryDependency = view_builder_2.ComponentFactoryDependency;
  exports.ViewFactoryDependency = view_builder_2.ViewFactoryDependency;
  var ViewCompileResult = (function() {
    function ViewCompileResult(statements, viewFactoryVar, dependencies) {
      this.statements = statements;
      this.viewFactoryVar = viewFactoryVar;
      this.dependencies = dependencies;
    }
    return ViewCompileResult;
  }());
  exports.ViewCompileResult = ViewCompileResult;
  var ViewCompiler = (function() {
    function ViewCompiler(_genConfig) {
      this._genConfig = _genConfig;
      this._animationCompiler = new animation_compiler_1.AnimationCompiler();
    }
    ViewCompiler.prototype.compileComponent = function(component, template, styles, pipes) {
      var dependencies = [];
      var compiledAnimations = this._animationCompiler.compileComponent(component, template);
      var statements = [];
      compiledAnimations.map(function(entry) {
        statements.push(entry.statesMapStatement);
        statements.push(entry.fnStatement);
      });
      var view = new compile_view_1.CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, compile_element_1.CompileElement.createNull(), []);
      view_builder_1.buildView(view, template, dependencies);
      view_binder_1.bindView(view, template);
      view_builder_1.finishView(view, statements);
      return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
    };
    ViewCompiler.decorators = [{type: core_1.Injectable}];
    ViewCompiler.ctorParameters = [{type: config_1.CompilerConfig}];
    return ViewCompiler;
  }());
  exports.ViewCompiler = ViewCompiler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/private_export.js", ["./src/directive_normalizer", "./src/expression_parser/lexer", "./src/expression_parser/parser", "./src/metadata_resolver", "./src/ml_parser/html_parser", "./src/ml_parser/interpolation_config", "./src/ng_module_compiler", "./src/output/path_util", "./src/output/ts_emitter", "./src/parse_util", "./src/schema/dom_element_schema_registry", "./src/selector", "./src/style_compiler", "./src/template_parser/template_parser", "./src/view_compiler/view_compiler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var directive_normalizer = $__require('./src/directive_normalizer');
  var lexer = $__require('./src/expression_parser/lexer');
  var parser = $__require('./src/expression_parser/parser');
  var metadata_resolver = $__require('./src/metadata_resolver');
  var html_parser = $__require('./src/ml_parser/html_parser');
  var interpolation_config = $__require('./src/ml_parser/interpolation_config');
  var ng_module_compiler = $__require('./src/ng_module_compiler');
  var path_util = $__require('./src/output/path_util');
  var ts_emitter = $__require('./src/output/ts_emitter');
  var parse_util = $__require('./src/parse_util');
  var dom_element_schema_registry = $__require('./src/schema/dom_element_schema_registry');
  var selector = $__require('./src/selector');
  var style_compiler = $__require('./src/style_compiler');
  var template_parser = $__require('./src/template_parser/template_parser');
  var view_compiler = $__require('./src/view_compiler/view_compiler');
  var __compiler_private__;
  (function(__compiler_private__) {
    __compiler_private__.SelectorMatcher = selector.SelectorMatcher;
    __compiler_private__.CssSelector = selector.CssSelector;
    __compiler_private__.AssetUrl = path_util.AssetUrl;
    __compiler_private__.ImportGenerator = path_util.ImportGenerator;
    __compiler_private__.CompileMetadataResolver = metadata_resolver.CompileMetadataResolver;
    __compiler_private__.HtmlParser = html_parser.HtmlParser;
    __compiler_private__.InterpolationConfig = interpolation_config.InterpolationConfig;
    __compiler_private__.DirectiveNormalizer = directive_normalizer.DirectiveNormalizer;
    __compiler_private__.Lexer = lexer.Lexer;
    __compiler_private__.Parser = parser.Parser;
    __compiler_private__.ParseLocation = parse_util.ParseLocation;
    __compiler_private__.ParseError = parse_util.ParseError;
    __compiler_private__.ParseErrorLevel = parse_util.ParseErrorLevel;
    __compiler_private__.ParseSourceFile = parse_util.ParseSourceFile;
    __compiler_private__.ParseSourceSpan = parse_util.ParseSourceSpan;
    __compiler_private__.TemplateParser = template_parser.TemplateParser;
    __compiler_private__.DomElementSchemaRegistry = dom_element_schema_registry.DomElementSchemaRegistry;
    __compiler_private__.StyleCompiler = style_compiler.StyleCompiler;
    __compiler_private__.ViewCompiler = view_compiler.ViewCompiler;
    __compiler_private__.NgModuleCompiler = ng_module_compiler.NgModuleCompiler;
    __compiler_private__.TypeScriptEmitter = ts_emitter.TypeScriptEmitter;
  })(__compiler_private__ = exports.__compiler_private__ || (exports.__compiler_private__ = {}));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/compiler/index.js", ["./src/i18n/index", "./src/compiler", "./src/ml_parser/interpolation_config", "./src/schema/element_schema_registry", "./src/template_parser/template_ast", "./private_export"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  var i18n = $__require('./src/i18n/index');
  exports.i18n = i18n;
  var compiler_1 = $__require('./src/compiler');
  exports.COMPILER_PROVIDERS = compiler_1.COMPILER_PROVIDERS;
  exports.CompileDiDependencyMetadata = compiler_1.CompileDiDependencyMetadata;
  exports.CompileDirectiveMetadata = compiler_1.CompileDirectiveMetadata;
  exports.CompileFactoryMetadata = compiler_1.CompileFactoryMetadata;
  exports.CompileIdentifierMetadata = compiler_1.CompileIdentifierMetadata;
  exports.CompileMetadataWithIdentifier = compiler_1.CompileMetadataWithIdentifier;
  exports.CompilePipeMetadata = compiler_1.CompilePipeMetadata;
  exports.CompileProviderMetadata = compiler_1.CompileProviderMetadata;
  exports.CompileQueryMetadata = compiler_1.CompileQueryMetadata;
  exports.CompileTemplateMetadata = compiler_1.CompileTemplateMetadata;
  exports.CompileTokenMetadata = compiler_1.CompileTokenMetadata;
  exports.CompileTypeMetadata = compiler_1.CompileTypeMetadata;
  exports.CompilerConfig = compiler_1.CompilerConfig;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = compiler_1.DEFAULT_PACKAGE_URL_PROVIDER;
  exports.DirectiveResolver = compiler_1.DirectiveResolver;
  exports.NgModuleResolver = compiler_1.NgModuleResolver;
  exports.OfflineCompiler = compiler_1.OfflineCompiler;
  exports.PipeResolver = compiler_1.PipeResolver;
  exports.RenderTypes = compiler_1.RenderTypes;
  exports.RuntimeCompiler = compiler_1.RuntimeCompiler;
  exports.SourceModule = compiler_1.SourceModule;
  exports.TEMPLATE_TRANSFORMS = compiler_1.TEMPLATE_TRANSFORMS;
  exports.UrlResolver = compiler_1.UrlResolver;
  exports.XHR = compiler_1.XHR;
  exports.analyzeAppProvidersForDeprecatedConfiguration = compiler_1.analyzeAppProvidersForDeprecatedConfiguration;
  exports.createOfflineCompileUrlResolver = compiler_1.createOfflineCompileUrlResolver;
  exports.platformCoreDynamic = compiler_1.platformCoreDynamic;
  var interpolation_config_1 = $__require('./src/ml_parser/interpolation_config');
  exports.InterpolationConfig = interpolation_config_1.InterpolationConfig;
  var element_schema_registry_1 = $__require('./src/schema/element_schema_registry');
  exports.ElementSchemaRegistry = element_schema_registry_1.ElementSchemaRegistry;
  __export($__require('./src/template_parser/template_ast'));
  __export($__require('./private_export'));
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/util.js", ["./util/decorators"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var decorators_1 = $__require('./util/decorators');
  exports.Class = decorators_1.Class;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/zone.js", ["./zone/ng_zone"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ng_zone_1 = $__require('./zone/ng_zone');
  exports.NgZone = ng_zone_1.NgZone;
  exports.NgZoneError = ng_zone_1.NgZoneError;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/render.js", ["./render/api"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var api_1 = $__require('./render/api');
  exports.RenderComponentType = api_1.RenderComponentType;
  exports.Renderer = api_1.Renderer;
  exports.RootRenderer = api_1.RootRenderer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/ng_module_factory_loader.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var NgModuleFactoryLoader = (function() {
    function NgModuleFactoryLoader() {}
    return NgModuleFactoryLoader;
  }());
  exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/query_list.js", ["../facade/async", "../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var async_1 = $__require('../facade/async');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var QueryList = (function() {
    function QueryList() {
      this._dirty = true;
      this._results = [];
      this._emitter = new async_1.EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
      get: function() {
        return this._emitter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
      get: function() {
        return this._results.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
      get: function() {
        return this._results[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
      get: function() {
        return this._results[this.length - 1];
      },
      enumerable: true,
      configurable: true
    });
    QueryList.prototype.map = function(fn) {
      return this._results.map(fn);
    };
    QueryList.prototype.filter = function(fn) {
      return this._results.filter(fn);
    };
    QueryList.prototype.reduce = function(fn, init) {
      return this._results.reduce(fn, init);
    };
    QueryList.prototype.forEach = function(fn) {
      this._results.forEach(fn);
    };
    QueryList.prototype.some = function(fn) {
      return this._results.some(fn);
    };
    QueryList.prototype.toArray = function() {
      return this._results.slice();
    };
    QueryList.prototype[lang_1.getSymbolIterator()] = function() {
      return this._results[lang_1.getSymbolIterator()]();
    };
    QueryList.prototype.toString = function() {
      return this._results.toString();
    };
    QueryList.prototype.reset = function(res) {
      this._results = collection_1.ListWrapper.flatten(res);
      this._dirty = false;
    };
    QueryList.prototype.notifyOnChanges = function() {
      this._emitter.emit(this);
    };
    QueryList.prototype.setDirty = function() {
      this._dirty = true;
    };
    Object.defineProperty(QueryList.prototype, "dirty", {
      get: function() {
        return this._dirty;
      },
      enumerable: true,
      configurable: true
    });
    return QueryList;
  }());
  exports.QueryList = QueryList;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader.js", ["../di", "../facade/lang", "./compiler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var di_1 = $__require('../di');
  var lang_1 = $__require('../facade/lang');
  var compiler_1 = $__require('./compiler');
  var _SEPARATOR = '#';
  var FACTORY_MODULE_SUFFIX = '.ngfactory';
  var FACTORY_CLASS_SUFFIX = 'NgFactory';
  var SystemJsNgModuleLoader = (function() {
    function SystemJsNgModuleLoader(_compiler) {
      this._compiler = _compiler;
    }
    SystemJsNgModuleLoader.prototype.load = function(path) {
      var offlineMode = this._compiler instanceof compiler_1.Compiler;
      return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
    };
    SystemJsNgModuleLoader.prototype.loadAndCompile = function(path) {
      var _this = this;
      var _a = path.split(_SEPARATOR),
          module = _a[0],
          exportName = _a[1];
      if (exportName === undefined)
        exportName = 'default';
      return lang_1.global.System.import(module).then(function(module) {
        return module[exportName];
      }).then(function(type) {
        return checkNotEmpty(type, module, exportName);
      }).then(function(type) {
        return _this._compiler.compileModuleAsync(type);
      });
    };
    SystemJsNgModuleLoader.prototype.loadFactory = function(path) {
      var _a = path.split(_SEPARATOR),
          module = _a[0],
          exportName = _a[1];
      if (exportName === undefined)
        exportName = 'default';
      return lang_1.global.System.import(module + FACTORY_MODULE_SUFFIX).then(function(module) {
        return module[exportName + FACTORY_CLASS_SUFFIX];
      }).then(function(factory) {
        return checkNotEmpty(factory, module, exportName);
      });
    };
    SystemJsNgModuleLoader.decorators = [{type: di_1.Injectable}];
    SystemJsNgModuleLoader.ctorParameters = [{type: compiler_1.Compiler}];
    return SystemJsNgModuleLoader;
  }());
  exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
  function checkNotEmpty(value, modulePath, exportName) {
    if (!value) {
      throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
    }
    return value;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/systemjs_component_resolver.js", ["../console", "../di", "../facade/lang", "./component_resolver"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var console_1 = $__require('../console');
  var di_1 = $__require('../di');
  var lang_1 = $__require('../facade/lang');
  var component_resolver_1 = $__require('./component_resolver');
  var _SEPARATOR = '#';
  var SystemJsComponentResolver = (function() {
    function SystemJsComponentResolver(_resolver, _console) {
      this._resolver = _resolver;
      this._console = _console;
    }
    SystemJsComponentResolver.prototype.resolveComponent = function(componentType) {
      var _this = this;
      if (lang_1.isString(componentType)) {
        this._console.warn(component_resolver_1.ComponentResolver.LazyLoadingDeprecationMsg);
        var _a = componentType.split(_SEPARATOR),
            module = _a[0],
            component_1 = _a[1];
        if (component_1 === void(0)) {
          component_1 = 'default';
        }
        return lang_1.global.System.import(module).then(function(module) {
          return _this._resolver.resolveComponent(module[component_1]);
        });
      }
      return this._resolver.resolveComponent(componentType);
    };
    SystemJsComponentResolver.prototype.clearCache = function() {};
    SystemJsComponentResolver.decorators = [{type: di_1.Injectable}];
    SystemJsComponentResolver.ctorParameters = [{type: component_resolver_1.ComponentResolver}, {type: console_1.Console}];
    return SystemJsComponentResolver;
  }());
  exports.SystemJsComponentResolver = SystemJsComponentResolver;
  var FACTORY_MODULE_SUFFIX = '.ngfactory';
  var FACTORY_CLASS_SUFFIX = 'NgFactory';
  var SystemJsCmpFactoryResolver = (function() {
    function SystemJsCmpFactoryResolver(_console) {
      this._console = _console;
    }
    SystemJsCmpFactoryResolver.prototype.resolveComponent = function(componentType) {
      if (lang_1.isString(componentType)) {
        this._console.warn(component_resolver_1.ComponentResolver.LazyLoadingDeprecationMsg);
        var _a = componentType.split(_SEPARATOR),
            module = _a[0],
            factory_1 = _a[1];
        return lang_1.global.System.import(module + FACTORY_MODULE_SUFFIX).then(function(module) {
          return module[factory_1 + FACTORY_CLASS_SUFFIX];
        });
      }
      return Promise.resolve(null);
    };
    SystemJsCmpFactoryResolver.prototype.clearCache = function() {};
    SystemJsCmpFactoryResolver.decorators = [{type: di_1.Injectable}];
    SystemJsCmpFactoryResolver.ctorParameters = [{type: console_1.Console}];
    return SystemJsCmpFactoryResolver;
  }());
  exports.SystemJsCmpFactoryResolver = SystemJsCmpFactoryResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker.js", ["./linker/compiler", "./linker/component_factory", "./linker/component_factory_resolver", "./linker/component_resolver", "./linker/dynamic_component_loader", "./linker/element_ref", "./linker/exceptions", "./linker/ng_module_factory", "./linker/ng_module_factory_loader", "./linker/query_list", "./linker/system_js_ng_module_factory_loader", "./linker/systemjs_component_resolver", "./linker/template_ref", "./linker/view_container_ref", "./linker/view_ref"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var compiler_1 = $__require('./linker/compiler');
  exports.COMPILER_OPTIONS = compiler_1.COMPILER_OPTIONS;
  exports.Compiler = compiler_1.Compiler;
  exports.CompilerFactory = compiler_1.CompilerFactory;
  exports.ComponentStillLoadingError = compiler_1.ComponentStillLoadingError;
  exports.ModuleWithComponentFactories = compiler_1.ModuleWithComponentFactories;
  var component_factory_1 = $__require('./linker/component_factory');
  exports.ComponentFactory = component_factory_1.ComponentFactory;
  exports.ComponentRef = component_factory_1.ComponentRef;
  var component_factory_resolver_1 = $__require('./linker/component_factory_resolver');
  exports.ComponentFactoryResolver = component_factory_resolver_1.ComponentFactoryResolver;
  exports.NoComponentFactoryError = component_factory_resolver_1.NoComponentFactoryError;
  var component_resolver_1 = $__require('./linker/component_resolver');
  exports.ComponentResolver = component_resolver_1.ComponentResolver;
  var dynamic_component_loader_1 = $__require('./linker/dynamic_component_loader');
  exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
  var element_ref_1 = $__require('./linker/element_ref');
  exports.ElementRef = element_ref_1.ElementRef;
  var exceptions_1 = $__require('./linker/exceptions');
  exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
  var ng_module_factory_1 = $__require('./linker/ng_module_factory');
  exports.NgModuleFactory = ng_module_factory_1.NgModuleFactory;
  exports.NgModuleRef = ng_module_factory_1.NgModuleRef;
  var ng_module_factory_loader_1 = $__require('./linker/ng_module_factory_loader');
  exports.NgModuleFactoryLoader = ng_module_factory_loader_1.NgModuleFactoryLoader;
  var query_list_1 = $__require('./linker/query_list');
  exports.QueryList = query_list_1.QueryList;
  var system_js_ng_module_factory_loader_1 = $__require('./linker/system_js_ng_module_factory_loader');
  exports.SystemJsNgModuleLoader = system_js_ng_module_factory_loader_1.SystemJsNgModuleLoader;
  var systemjs_component_resolver_1 = $__require('./linker/systemjs_component_resolver');
  exports.SystemJsCmpFactoryResolver = systemjs_component_resolver_1.SystemJsCmpFactoryResolver;
  exports.SystemJsComponentResolver = systemjs_component_resolver_1.SystemJsComponentResolver;
  var template_ref_1 = $__require('./linker/template_ref');
  exports.TemplateRef = template_ref_1.TemplateRef;
  var view_container_ref_1 = $__require('./linker/view_container_ref');
  exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
  var view_ref_1 = $__require('./linker/view_ref');
  exports.EmbeddedViewRef = view_ref_1.EmbeddedViewRef;
  exports.ViewRef = view_ref_1.ViewRef;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection.js", ["./change_detection/change_detection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var change_detection_1 = $__require('./change_detection/change_detection');
  exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
  exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
  exports.CollectionChangeRecord = change_detection_1.CollectionChangeRecord;
  exports.DefaultIterableDiffer = change_detection_1.DefaultIterableDiffer;
  exports.IterableDiffers = change_detection_1.IterableDiffers;
  exports.KeyValueChangeRecord = change_detection_1.KeyValueChangeRecord;
  exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;
  exports.SimpleChange = change_detection_1.SimpleChange;
  exports.WrappedValue = change_detection_1.WrappedValue;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/platform_directives_and_pipes.js", ["./di"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var di_1 = $__require('./di');
  exports.PLATFORM_DIRECTIVES = new di_1.OpaqueToken('Platform Directives');
  exports.PLATFORM_PIPES = new di_1.OpaqueToken('Platform Pipes');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/platform_core_providers.js", ["./application_ref", "./console", "./reflection/reflection", "./reflection/reflector_reader", "./testability/testability"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var application_ref_1 = $__require('./application_ref');
  var console_1 = $__require('./console');
  var reflection_1 = $__require('./reflection/reflection');
  var reflector_reader_1 = $__require('./reflection/reflector_reader');
  var testability_1 = $__require('./testability/testability');
  function _reflector() {
    return reflection_1.reflector;
  }
  var _CORE_PLATFORM_PROVIDERS = [application_ref_1.PlatformRef_, {
    provide: application_ref_1.PlatformRef,
    useExisting: application_ref_1.PlatformRef_
  }, {
    provide: reflection_1.Reflector,
    useFactory: _reflector,
    deps: []
  }, {
    provide: reflector_reader_1.ReflectorReader,
    useExisting: reflection_1.Reflector
  }, testability_1.TestabilityRegistry, console_1.Console];
  exports.platformCore = application_ref_1.createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
  exports.PLATFORM_COMMON_PROVIDERS = _CORE_PLATFORM_PROVIDERS;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/application_init.js", ["../src/facade/lang", "./di"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../src/facade/lang');
  var di_1 = $__require('./di');
  exports.APP_INITIALIZER = new di_1.OpaqueToken('Application Initializer');
  var ApplicationInitStatus = (function() {
    function ApplicationInitStatus(appInits) {
      var _this = this;
      this._done = false;
      var asyncInitPromises = [];
      if (appInits) {
        for (var i = 0; i < appInits.length; i++) {
          var initResult = appInits[i]();
          if (lang_1.isPromise(initResult)) {
            asyncInitPromises.push(initResult);
          }
        }
      }
      this._donePromise = Promise.all(asyncInitPromises).then(function() {
        _this._done = true;
      });
      if (asyncInitPromises.length === 0) {
        this._done = true;
      }
    }
    Object.defineProperty(ApplicationInitStatus.prototype, "done", {
      get: function() {
        return this._done;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
      get: function() {
        return this._donePromise;
      },
      enumerable: true,
      configurable: true
    });
    ApplicationInitStatus.decorators = [{type: di_1.Injectable}];
    ApplicationInitStatus.ctorParameters = [{
      type: Array,
      decorators: [{
        type: di_1.Inject,
        args: [exports.APP_INITIALIZER]
      }, {type: di_1.Optional}]
    }];
    return ApplicationInitStatus;
  }());
  exports.ApplicationInitStatus = ApplicationInitStatus;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/component_factory.js", ["../facade/exceptions", "../facade/lang", "./view_utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var view_utils_1 = $__require('./view_utils');
  var ComponentRef = (function() {
    function ComponentRef() {}
    Object.defineProperty(ComponentRef.prototype, "location", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "injector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "instance", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "hostView", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "componentType", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return ComponentRef;
  }());
  exports.ComponentRef = ComponentRef;
  var ComponentRef_ = (function(_super) {
    __extends(ComponentRef_, _super);
    function ComponentRef_(_hostElement, _componentType) {
      _super.call(this);
      this._hostElement = _hostElement;
      this._componentType = _componentType;
    }
    Object.defineProperty(ComponentRef_.prototype, "location", {
      get: function() {
        return this._hostElement.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "injector", {
      get: function() {
        return this._hostElement.injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "instance", {
      get: function() {
        return this._hostElement.component;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "hostView", {
      get: function() {
        return this._hostElement.parentView.ref;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
      get: function() {
        return this._hostElement.parentView.ref;
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "componentType", {
      get: function() {
        return this._componentType;
      },
      enumerable: true,
      configurable: true
    });
    ComponentRef_.prototype.destroy = function() {
      this._hostElement.parentView.destroy();
    };
    ComponentRef_.prototype.onDestroy = function(callback) {
      this.hostView.onDestroy(callback);
    };
    return ComponentRef_;
  }(ComponentRef));
  exports.ComponentRef_ = ComponentRef_;
  var EMPTY_CONTEXT = new Object();
  var ComponentFactory = (function() {
    function ComponentFactory(selector, _viewFactory, _componentType) {
      this.selector = selector;
      this._viewFactory = _viewFactory;
      this._componentType = _componentType;
    }
    Object.defineProperty(ComponentFactory.prototype, "componentType", {
      get: function() {
        return this._componentType;
      },
      enumerable: true,
      configurable: true
    });
    ComponentFactory.prototype.create = function(injector, projectableNodes, rootSelectorOrNode) {
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      if (rootSelectorOrNode === void 0) {
        rootSelectorOrNode = null;
      }
      var vu = injector.get(view_utils_1.ViewUtils);
      if (lang_1.isBlank(projectableNodes)) {
        projectableNodes = [];
      }
      var hostView = this._viewFactory(vu, injector, null);
      var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
      return new ComponentRef_(hostElement, this._componentType);
    };
    return ComponentFactory;
  }());
  exports.ComponentFactory = ComponentFactory;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/testability/testability.js", ["../di/decorators", "../facade/collection", "../facade/exceptions", "../facade/lang", "../zone/ng_zone"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var decorators_1 = $__require('../di/decorators');
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var ng_zone_1 = $__require('../zone/ng_zone');
  var Testability = (function() {
    function Testability(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this._watchAngularEvents();
    }
    Testability.prototype._watchAngularEvents = function() {
      var _this = this;
      this._ngZone.onUnstable.subscribe({next: function() {
          _this._didWork = true;
          _this._isZoneStable = false;
        }});
      this._ngZone.runOutsideAngular(function() {
        _this._ngZone.onStable.subscribe({next: function() {
            ng_zone_1.NgZone.assertNotInAngularZone();
            lang_1.scheduleMicroTask(function() {
              _this._isZoneStable = true;
              _this._runCallbacksIfReady();
            });
          }});
      });
    };
    Testability.prototype.increasePendingRequestCount = function() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new exceptions_1.BaseException('pending async requests below zero');
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    };
    Testability.prototype.isStable = function() {
      return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
    };
    Testability.prototype._runCallbacksIfReady = function() {
      var _this = this;
      if (this.isStable()) {
        lang_1.scheduleMicroTask(function() {
          while (_this._callbacks.length !== 0) {
            (_this._callbacks.pop())(_this._didWork);
          }
          _this._didWork = false;
        });
      } else {
        this._didWork = true;
      }
    };
    Testability.prototype.whenStable = function(callback) {
      this._callbacks.push(callback);
      this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function() {
      return this._pendingCount;
    };
    Testability.prototype.findBindings = function(using, provider, exactMatch) {
      return [];
    };
    Testability.prototype.findProviders = function(using, provider, exactMatch) {
      return [];
    };
    Testability.decorators = [{type: decorators_1.Injectable}];
    Testability.ctorParameters = [{type: ng_zone_1.NgZone}];
    return Testability;
  }());
  exports.Testability = Testability;
  var TestabilityRegistry = (function() {
    function TestabilityRegistry() {
      this._applications = new collection_1.Map();
      _testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function(token, testability) {
      this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getTestability = function(elem) {
      return this._applications.get(elem);
    };
    TestabilityRegistry.prototype.getAllTestabilities = function() {
      return collection_1.MapWrapper.values(this._applications);
    };
    TestabilityRegistry.prototype.getAllRootElements = function() {
      return collection_1.MapWrapper.keys(this._applications);
    };
    TestabilityRegistry.prototype.findTestabilityInTree = function(elem, findInAncestors) {
      if (findInAncestors === void 0) {
        findInAncestors = true;
      }
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    };
    TestabilityRegistry.decorators = [{type: decorators_1.Injectable}];
    TestabilityRegistry.ctorParameters = [];
    return TestabilityRegistry;
  }());
  exports.TestabilityRegistry = TestabilityRegistry;
  var _NoopGetTestability = (function() {
    function _NoopGetTestability() {}
    _NoopGetTestability.prototype.addToWindow = function(registry) {};
    _NoopGetTestability.prototype.findTestabilityInTree = function(registry, elem, findInAncestors) {
      return null;
    };
    return _NoopGetTestability;
  }());
  function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
  }
  exports.setTestabilityGetter = setTestabilityGetter;
  var _testabilityGetter = new _NoopGetTestability();
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/zone/ng_zone_impl.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var NgZoneError = (function() {
    function NgZoneError(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
    }
    return NgZoneError;
  }());
  exports.NgZoneError = NgZoneError;
  var NgZoneImpl = (function() {
    function NgZoneImpl(_a) {
      var _this = this;
      var trace = _a.trace,
          onEnter = _a.onEnter,
          onLeave = _a.onLeave,
          setMicrotask = _a.setMicrotask,
          setMacrotask = _a.setMacrotask,
          onError = _a.onError;
      this.onEnter = onEnter;
      this.onLeave = onLeave;
      this.setMicrotask = setMicrotask;
      this.setMacrotask = setMacrotask;
      this.onError = onError;
      if (Zone) {
        this.outer = this.inner = Zone.current;
        if (Zone['wtfZoneSpec']) {
          this.inner = this.inner.fork(Zone['wtfZoneSpec']);
        }
        if (trace && Zone['longStackTraceZoneSpec']) {
          this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
        }
        this.inner = this.inner.fork({
          name: 'angular',
          properties: {'isAngularZone': true},
          onInvokeTask: function(delegate, current, target, task, applyThis, applyArgs) {
            try {
              _this.onEnter();
              return delegate.invokeTask(target, task, applyThis, applyArgs);
            } finally {
              _this.onLeave();
            }
          },
          onInvoke: function(delegate, current, target, callback, applyThis, applyArgs, source) {
            try {
              _this.onEnter();
              return delegate.invoke(target, callback, applyThis, applyArgs, source);
            } finally {
              _this.onLeave();
            }
          },
          onHasTask: function(delegate, current, target, hasTaskState) {
            delegate.hasTask(target, hasTaskState);
            if (current == target) {
              if (hasTaskState.change == 'microTask') {
                _this.setMicrotask(hasTaskState.microTask);
              } else if (hasTaskState.change == 'macroTask') {
                _this.setMacrotask(hasTaskState.macroTask);
              }
            }
          },
          onHandleError: function(delegate, current, target, error) {
            delegate.handleError(target, error);
            _this.onError(new NgZoneError(error, error.stack));
            return false;
          }
        });
      } else {
        throw new Error('Angular requires Zone.js polyfill.');
      }
    }
    NgZoneImpl.isInAngularZone = function() {
      return Zone.current.get('isAngularZone') === true;
    };
    NgZoneImpl.prototype.runInner = function(fn) {
      return this.inner.run(fn);
    };
    ;
    NgZoneImpl.prototype.runInnerGuarded = function(fn) {
      return this.inner.runGuarded(fn);
    };
    ;
    NgZoneImpl.prototype.runOuter = function(fn) {
      return this.outer.run(fn);
    };
    ;
    return NgZoneImpl;
  }());
  exports.NgZoneImpl = NgZoneImpl;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/zone/ng_zone.js", ["../facade/async", "../facade/exceptions", "./ng_zone_impl"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var async_1 = $__require('../facade/async');
  var exceptions_1 = $__require('../facade/exceptions');
  var ng_zone_impl_1 = $__require('./ng_zone_impl');
  var ng_zone_impl_2 = $__require('./ng_zone_impl');
  exports.NgZoneError = ng_zone_impl_2.NgZoneError;
  var NgZone = (function() {
    function NgZone(_a) {
      var _this = this;
      var _b = _a.enableLongStackTrace,
          enableLongStackTrace = _b === void 0 ? false : _b;
      this._hasPendingMicrotasks = false;
      this._hasPendingMacrotasks = false;
      this._isStable = true;
      this._nesting = 0;
      this._onUnstable = new async_1.EventEmitter(false);
      this._onMicrotaskEmpty = new async_1.EventEmitter(false);
      this._onStable = new async_1.EventEmitter(false);
      this._onErrorEvents = new async_1.EventEmitter(false);
      this._zoneImpl = new ng_zone_impl_1.NgZoneImpl({
        trace: enableLongStackTrace,
        onEnter: function() {
          _this._nesting++;
          if (_this._isStable) {
            _this._isStable = false;
            _this._onUnstable.emit(null);
          }
        },
        onLeave: function() {
          _this._nesting--;
          _this._checkStable();
        },
        setMicrotask: function(hasMicrotasks) {
          _this._hasPendingMicrotasks = hasMicrotasks;
          _this._checkStable();
        },
        setMacrotask: function(hasMacrotasks) {
          _this._hasPendingMacrotasks = hasMacrotasks;
        },
        onError: function(error) {
          return _this._onErrorEvents.emit(error);
        }
      });
    }
    NgZone.isInAngularZone = function() {
      return ng_zone_impl_1.NgZoneImpl.isInAngularZone();
    };
    NgZone.assertInAngularZone = function() {
      if (!ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
        throw new exceptions_1.BaseException('Expected to be in Angular Zone, but it is not!');
      }
    };
    NgZone.assertNotInAngularZone = function() {
      if (ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
        throw new exceptions_1.BaseException('Expected to not be in Angular Zone, but it is!');
      }
    };
    NgZone.prototype._checkStable = function() {
      var _this = this;
      if (this._nesting == 0) {
        if (!this._hasPendingMicrotasks && !this._isStable) {
          try {
            this._nesting++;
            this._onMicrotaskEmpty.emit(null);
          } finally {
            this._nesting--;
            if (!this._hasPendingMicrotasks) {
              try {
                this.runOutsideAngular(function() {
                  return _this._onStable.emit(null);
                });
              } finally {
                this._isStable = true;
              }
            }
          }
        }
      }
    };
    ;
    Object.defineProperty(NgZone.prototype, "onUnstable", {
      get: function() {
        return this._onUnstable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
      get: function() {
        return this._onMicrotaskEmpty;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onStable", {
      get: function() {
        return this._onStable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onError", {
      get: function() {
        return this._onErrorEvents;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "isStable", {
      get: function() {
        return this._isStable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
      get: function() {
        return this._hasPendingMicrotasks;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
      get: function() {
        return this._hasPendingMacrotasks;
      },
      enumerable: true,
      configurable: true
    });
    NgZone.prototype.run = function(fn) {
      return this._zoneImpl.runInner(fn);
    };
    NgZone.prototype.runGuarded = function(fn) {
      return this._zoneImpl.runInnerGuarded(fn);
    };
    NgZone.prototype.runOutsideAngular = function(fn) {
      return this._zoneImpl.runOuter(fn);
    };
    return NgZone;
  }());
  exports.NgZone = NgZone;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/application_ref.js", ["../src/facade/collection", "../src/facade/exceptions", "../src/facade/lang", "./application_init", "./application_tokens", "./console", "./di", "./linker/compiler", "./linker/component_factory", "./linker/component_factory_resolver", "./profile/profile", "./testability/testability", "./zone/ng_zone"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../src/facade/collection');
  var exceptions_1 = $__require('../src/facade/exceptions');
  var lang_1 = $__require('../src/facade/lang');
  var application_init_1 = $__require('./application_init');
  var application_tokens_1 = $__require('./application_tokens');
  var console_1 = $__require('./console');
  var di_1 = $__require('./di');
  var compiler_1 = $__require('./linker/compiler');
  var component_factory_1 = $__require('./linker/component_factory');
  var component_factory_resolver_1 = $__require('./linker/component_factory_resolver');
  var profile_1 = $__require('./profile/profile');
  var testability_1 = $__require('./testability/testability');
  var ng_zone_1 = $__require('./zone/ng_zone');
  var _devMode = true;
  var _runModeLocked = false;
  var _platform;
  function enableProdMode() {
    if (_runModeLocked) {
      throw new exceptions_1.BaseException('Cannot enable prod mode after platform setup.');
    }
    _devMode = false;
  }
  exports.enableProdMode = enableProdMode;
  function lockRunMode() {
    console.warn('lockRunMode() is deprecated and not needed any more.');
  }
  exports.lockRunMode = lockRunMode;
  function isDevMode() {
    _runModeLocked = true;
    return _devMode;
  }
  exports.isDevMode = isDevMode;
  function createPlatform(injector) {
    if (lang_1.isPresent(_platform) && !_platform.disposed) {
      throw new exceptions_1.BaseException('There can be only one platform. Destroy the previous one to create a new one.');
    }
    _platform = injector.get(PlatformRef);
    var inits = injector.get(application_tokens_1.PLATFORM_INITIALIZER, null);
    if (lang_1.isPresent(inits))
      inits.forEach(function(init) {
        return init();
      });
    return _platform;
  }
  exports.createPlatform = createPlatform;
  function createPlatformFactory(parentPlaformFactory, name, providers) {
    if (providers === void 0) {
      providers = [];
    }
    var marker = new di_1.OpaqueToken("Platform: " + name);
    return function(extraProviders) {
      if (extraProviders === void 0) {
        extraProviders = [];
      }
      if (!getPlatform()) {
        if (parentPlaformFactory) {
          parentPlaformFactory(providers.concat(extraProviders).concat({
            provide: marker,
            useValue: true
          }));
        } else {
          createPlatform(di_1.ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({
            provide: marker,
            useValue: true
          })));
        }
      }
      return assertPlatform(marker);
    };
  }
  exports.createPlatformFactory = createPlatformFactory;
  function assertPlatform(requiredToken) {
    var platform = getPlatform();
    if (lang_1.isBlank(platform)) {
      throw new exceptions_1.BaseException('No platform exists!');
    }
    if (lang_1.isPresent(platform) && lang_1.isBlank(platform.injector.get(requiredToken, null))) {
      throw new exceptions_1.BaseException('A platform with a different configuration has been created. Please destroy it first.');
    }
    return platform;
  }
  exports.assertPlatform = assertPlatform;
  function disposePlatform() {
    destroyPlatform();
  }
  exports.disposePlatform = disposePlatform;
  function destroyPlatform() {
    if (lang_1.isPresent(_platform) && !_platform.destroyed) {
      _platform.destroy();
    }
  }
  exports.destroyPlatform = destroyPlatform;
  function getPlatform() {
    return lang_1.isPresent(_platform) && !_platform.disposed ? _platform : null;
  }
  exports.getPlatform = getPlatform;
  function coreBootstrap(componentFactory, injector) {
    throw new exceptions_1.BaseException('coreBootstrap is deprecated. Use bootstrapModuleFactory instead.');
  }
  exports.coreBootstrap = coreBootstrap;
  function coreLoadAndBootstrap(componentType, injector) {
    throw new exceptions_1.BaseException('coreLoadAndBootstrap is deprecated. Use bootstrapModule instead.');
  }
  exports.coreLoadAndBootstrap = coreLoadAndBootstrap;
  var PlatformRef = (function() {
    function PlatformRef() {}
    PlatformRef.prototype.bootstrapModuleFactory = function(moduleFactory) {
      throw exceptions_1.unimplemented();
    };
    PlatformRef.prototype.bootstrapModule = function(moduleType, compilerOptions) {
      if (compilerOptions === void 0) {
        compilerOptions = [];
      }
      throw exceptions_1.unimplemented();
    };
    Object.defineProperty(PlatformRef.prototype, "injector", {
      get: function() {
        throw exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(PlatformRef.prototype, "disposed", {
      get: function() {
        throw exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformRef.prototype, "destroyed", {
      get: function() {
        throw exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return PlatformRef;
  }());
  exports.PlatformRef = PlatformRef;
  function _callAndReportToExceptionHandler(exceptionHandler, callback) {
    try {
      var result = callback();
      if (lang_1.isPromise(result)) {
        return result.catch(function(e) {
          exceptionHandler.call(e);
          throw e;
        });
      } else {
        return result;
      }
    } catch (e) {
      exceptionHandler.call(e);
      throw e;
    }
  }
  var PlatformRef_ = (function(_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector) {
      _super.call(this);
      this._injector = _injector;
      this._modules = [];
      this._destroyListeners = [];
      this._destroyed = false;
    }
    PlatformRef_.prototype.registerDisposeListener = function(dispose) {
      this.onDestroy(dispose);
    };
    PlatformRef_.prototype.onDestroy = function(callback) {
      this._destroyListeners.push(callback);
    };
    Object.defineProperty(PlatformRef_.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformRef_.prototype, "disposed", {
      get: function() {
        return this.destroyed;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PlatformRef_.prototype, "destroyed", {
      get: function() {
        return this._destroyed;
      },
      enumerable: true,
      configurable: true
    });
    PlatformRef_.prototype.destroy = function() {
      if (this._destroyed) {
        throw new exceptions_1.BaseException('The platform has already been destroyed!');
      }
      collection_1.ListWrapper.clone(this._modules).forEach(function(app) {
        return app.destroy();
      });
      this._destroyListeners.forEach(function(dispose) {
        return dispose();
      });
      this._destroyed = true;
    };
    PlatformRef_.prototype.dispose = function() {
      this.destroy();
    };
    PlatformRef_.prototype.bootstrapModuleFactory = function(moduleFactory) {
      return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
    };
    PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function(moduleFactory, ngZone) {
      var _this = this;
      if (!ngZone)
        ngZone = new ng_zone_1.NgZone({enableLongStackTrace: isDevMode()});
      return ngZone.run(function() {
        var ngZoneInjector = di_1.ReflectiveInjector.resolveAndCreate([{
          provide: ng_zone_1.NgZone,
          useValue: ngZone
        }], _this.injector);
        var moduleRef = moduleFactory.create(ngZoneInjector);
        var exceptionHandler = moduleRef.injector.get(exceptions_1.ExceptionHandler, null);
        if (!exceptionHandler) {
          throw new Error('No ExceptionHandler. Is platform module (BrowserModule) included?');
        }
        moduleRef.onDestroy(function() {
          return collection_1.ListWrapper.remove(_this._modules, moduleRef);
        });
        ngZone.onError.subscribe({next: function(error) {
            exceptionHandler.call(error.error, error.stackTrace);
          }});
        return _callAndReportToExceptionHandler(exceptionHandler, function() {
          var initStatus = moduleRef.injector.get(application_init_1.ApplicationInitStatus);
          return initStatus.donePromise.then(function() {
            _this._moduleDoBootstrap(moduleRef);
            return moduleRef;
          });
        });
      });
    };
    PlatformRef_.prototype.bootstrapModule = function(moduleType, compilerOptions) {
      if (compilerOptions === void 0) {
        compilerOptions = [];
      }
      return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
    };
    PlatformRef_.prototype._bootstrapModuleWithZone = function(moduleType, compilerOptions, ngZone) {
      var _this = this;
      if (compilerOptions === void 0) {
        compilerOptions = [];
      }
      var compilerFactory = this.injector.get(compiler_1.CompilerFactory);
      var compiler = compilerFactory.createCompiler(compilerOptions instanceof Array ? compilerOptions : [compilerOptions]);
      return compiler.compileModuleAsync(moduleType).then(function(moduleFactory) {
        return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone);
      });
    };
    PlatformRef_.prototype._moduleDoBootstrap = function(moduleRef) {
      var appRef = moduleRef.injector.get(ApplicationRef);
      if (moduleRef.bootstrapFactories.length > 0) {
        moduleRef.bootstrapFactories.forEach(function(compFactory) {
          return appRef.bootstrap(compFactory);
        });
      } else if (moduleRef.instance.ngDoBootstrap) {
        moduleRef.instance.ngDoBootstrap(appRef);
      } else {
        throw new exceptions_1.BaseException(("The module " + lang_1.stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") + "Please define one of these.");
      }
    };
    PlatformRef_.decorators = [{type: di_1.Injectable}];
    PlatformRef_.ctorParameters = [{type: di_1.Injector}];
    return PlatformRef_;
  }(PlatformRef));
  exports.PlatformRef_ = PlatformRef_;
  var ApplicationRef = (function() {
    function ApplicationRef() {}
    Object.defineProperty(ApplicationRef.prototype, "injector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "zone", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "components", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return ApplicationRef;
  }());
  exports.ApplicationRef = ApplicationRef;
  var ApplicationRef_ = (function(_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
      var _this = this;
      _super.call(this);
      this._zone = _zone;
      this._console = _console;
      this._injector = _injector;
      this._exceptionHandler = _exceptionHandler;
      this._componentFactoryResolver = _componentFactoryResolver;
      this._initStatus = _initStatus;
      this._testabilityRegistry = _testabilityRegistry;
      this._testability = _testability;
      this._bootstrapListeners = [];
      this._disposeListeners = [];
      this._rootComponents = [];
      this._rootComponentTypes = [];
      this._changeDetectorRefs = [];
      this._runningTick = false;
      this._enforceNoNewChanges = false;
      this._enforceNoNewChanges = isDevMode();
      this._zone.onMicrotaskEmpty.subscribe({next: function() {
          _this._zone.run(function() {
            _this.tick();
          });
        }});
    }
    ApplicationRef_.prototype.registerBootstrapListener = function(listener) {
      this._bootstrapListeners.push(listener);
    };
    ApplicationRef_.prototype.registerDisposeListener = function(dispose) {
      this._disposeListeners.push(dispose);
    };
    ApplicationRef_.prototype.registerChangeDetector = function(changeDetector) {
      this._changeDetectorRefs.push(changeDetector);
    };
    ApplicationRef_.prototype.unregisterChangeDetector = function(changeDetector) {
      collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);
    };
    ApplicationRef_.prototype.waitForAsyncInitializers = function() {
      return this._initStatus.donePromise;
    };
    ApplicationRef_.prototype.run = function(callback) {
      var _this = this;
      return this._zone.run(function() {
        return _callAndReportToExceptionHandler(_this._exceptionHandler, callback);
      });
    };
    ApplicationRef_.prototype.bootstrap = function(componentOrFactory) {
      var _this = this;
      if (!this._initStatus.done) {
        throw new exceptions_1.BaseException('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
      }
      var componentFactory;
      if (componentOrFactory instanceof component_factory_1.ComponentFactory) {
        componentFactory = componentOrFactory;
      } else {
        componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
      }
      this._rootComponentTypes.push(componentFactory.componentType);
      var compRef = componentFactory.create(this._injector, [], componentFactory.selector);
      compRef.onDestroy(function() {
        _this._unloadComponent(compRef);
      });
      var testability = compRef.injector.get(testability_1.Testability, null);
      if (lang_1.isPresent(testability)) {
        compRef.injector.get(testability_1.TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability);
      }
      this._loadComponent(compRef);
      if (isDevMode()) {
        this._console.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
      }
      return compRef;
    };
    ApplicationRef_.prototype._loadComponent = function(componentRef) {
      this._changeDetectorRefs.push(componentRef.changeDetectorRef);
      this.tick();
      this._rootComponents.push(componentRef);
      var listeners = this._injector.get(application_tokens_1.APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
      listeners.forEach(function(listener) {
        return listener(componentRef);
      });
    };
    ApplicationRef_.prototype._unloadComponent = function(componentRef) {
      if (!collection_1.ListWrapper.contains(this._rootComponents, componentRef)) {
        return;
      }
      this.unregisterChangeDetector(componentRef.changeDetectorRef);
      collection_1.ListWrapper.remove(this._rootComponents, componentRef);
    };
    Object.defineProperty(ApplicationRef_.prototype, "injector", {
      get: function() {
        return this._injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "zone", {
      get: function() {
        return this._zone;
      },
      enumerable: true,
      configurable: true
    });
    ApplicationRef_.prototype.tick = function() {
      if (this._runningTick) {
        throw new exceptions_1.BaseException('ApplicationRef.tick is called recursively');
      }
      var s = ApplicationRef_._tickScope();
      try {
        this._runningTick = true;
        this._changeDetectorRefs.forEach(function(detector) {
          return detector.detectChanges();
        });
        if (this._enforceNoNewChanges) {
          this._changeDetectorRefs.forEach(function(detector) {
            return detector.checkNoChanges();
          });
        }
      } finally {
        this._runningTick = false;
        profile_1.wtfLeave(s);
      }
    };
    ApplicationRef_.prototype.ngOnDestroy = function() {
      collection_1.ListWrapper.clone(this._rootComponents).forEach(function(ref) {
        return ref.destroy();
      });
      this._disposeListeners.forEach(function(dispose) {
        return dispose();
      });
    };
    ApplicationRef_.prototype.dispose = function() {
      this.ngOnDestroy();
    };
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
      get: function() {
        return this._rootComponentTypes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "components", {
      get: function() {
        return this._rootComponents;
      },
      enumerable: true,
      configurable: true
    });
    ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');
    ApplicationRef_.decorators = [{type: di_1.Injectable}];
    ApplicationRef_.ctorParameters = [{type: ng_zone_1.NgZone}, {type: console_1.Console}, {type: di_1.Injector}, {type: exceptions_1.ExceptionHandler}, {type: component_factory_resolver_1.ComponentFactoryResolver}, {type: application_init_1.ApplicationInitStatus}, {
      type: testability_1.TestabilityRegistry,
      decorators: [{type: di_1.Optional}]
    }, {
      type: testability_1.Testability,
      decorators: [{type: di_1.Optional}]
    }];
    return ApplicationRef_;
  }(ApplicationRef));
  exports.ApplicationRef_ = ApplicationRef_;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/component_resolver.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ComponentResolver = (function() {
    function ComponentResolver() {}
    ComponentResolver.DynamicCompilationDeprecationMsg = 'ComponentResolver is deprecated for dynamic compilation. Use ComponentFactoryResolver together with @NgModule/@Component.entryComponents or ANALYZE_FOR_ENTRY_COMPONENTS provider instead. For runtime compile only, you can also use Compiler.compileComponentSync/Async.';
    ComponentResolver.LazyLoadingDeprecationMsg = 'ComponentResolver is deprecated for lazy loading. Use NgModuleFactoryLoader instead.';
    return ComponentResolver;
  }());
  exports.ComponentResolver = ComponentResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/compiler.js", ["../di", "../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var di_1 = $__require('../di');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var ComponentStillLoadingError = (function(_super) {
    __extends(ComponentStillLoadingError, _super);
    function ComponentStillLoadingError(compType) {
      _super.call(this, "Can't compile synchronously as " + lang_1.stringify(compType) + " is still being loaded!");
      this.compType = compType;
    }
    return ComponentStillLoadingError;
  }(exceptions_1.BaseException));
  exports.ComponentStillLoadingError = ComponentStillLoadingError;
  var ModuleWithComponentFactories = (function() {
    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
      this.ngModuleFactory = ngModuleFactory;
      this.componentFactories = componentFactories;
    }
    return ModuleWithComponentFactories;
  }());
  exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
  function _throwError() {
    throw new exceptions_1.BaseException("Runtime compiler is not loaded");
  }
  var Compiler = (function() {
    function Compiler() {}
    Compiler.prototype.compileComponentAsync = function(component, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      throw _throwError();
    };
    Compiler.prototype.compileComponentSync = function(component, ngModule) {
      if (ngModule === void 0) {
        ngModule = null;
      }
      throw _throwError();
    };
    Compiler.prototype.compileModuleSync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAsync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAndAllComponentsSync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.compileModuleAndAllComponentsAsync = function(moduleType) {
      throw _throwError();
    };
    Compiler.prototype.clearCache = function() {};
    Compiler.prototype.clearCacheFor = function(type) {};
    return Compiler;
  }());
  exports.Compiler = Compiler;
  exports.COMPILER_OPTIONS = new di_1.OpaqueToken('compilerOptions');
  var CompilerFactory = (function() {
    function CompilerFactory() {}
    return CompilerFactory;
  }());
  exports.CompilerFactory = CompilerFactory;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/dynamic_component_loader.js", ["../di", "../facade/lang", "./compiler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var di_1 = $__require('../di');
  var lang_1 = $__require('../facade/lang');
  var compiler_1 = $__require('./compiler');
  var DynamicComponentLoader = (function() {
    function DynamicComponentLoader() {}
    return DynamicComponentLoader;
  }());
  exports.DynamicComponentLoader = DynamicComponentLoader;
  var DynamicComponentLoader_ = (function(_super) {
    __extends(DynamicComponentLoader_, _super);
    function DynamicComponentLoader_(_compiler) {
      _super.call(this);
      this._compiler = _compiler;
    }
    DynamicComponentLoader_.prototype.loadAsRoot = function(type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
      return this._compiler.compileComponentAsync(type).then(function(componentFactory) {
        var componentRef = componentFactory.create(injector, projectableNodes, lang_1.isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
        if (lang_1.isPresent(onDispose)) {
          componentRef.onDestroy(onDispose);
        }
        return componentRef;
      });
    };
    DynamicComponentLoader_.prototype.loadNextToLocation = function(type, location, providers, projectableNodes) {
      if (providers === void 0) {
        providers = null;
      }
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      return this._compiler.compileComponentAsync(type).then(function(componentFactory) {
        var contextInjector = location.parentInjector;
        var childInjector = lang_1.isPresent(providers) && providers.length > 0 ? di_1.ReflectiveInjector.fromResolvedProviders(providers, contextInjector) : contextInjector;
        return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
      });
    };
    DynamicComponentLoader_.decorators = [{type: di_1.Injectable}];
    DynamicComponentLoader_.ctorParameters = [{type: compiler_1.Compiler}];
    return DynamicComponentLoader_;
  }(DynamicComponentLoader));
  exports.DynamicComponentLoader_ = DynamicComponentLoader_;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata/di.js", ["../di/forward_ref", "../di/metadata", "../di/opaque_token", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var forward_ref_1 = $__require('../di/forward_ref');
  var metadata_1 = $__require('../di/metadata');
  var opaque_token_1 = $__require('../di/opaque_token');
  var lang_1 = $__require('../facade/lang');
  exports.ANALYZE_FOR_ENTRY_COMPONENTS = new opaque_token_1.OpaqueToken('AnalyzeForEntryComponents');
  var AttributeMetadata = (function(_super) {
    __extends(AttributeMetadata, _super);
    function AttributeMetadata(attributeName) {
      _super.call(this);
      this.attributeName = attributeName;
    }
    Object.defineProperty(AttributeMetadata.prototype, "token", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    AttributeMetadata.prototype.toString = function() {
      return "@Attribute(" + lang_1.stringify(this.attributeName) + ")";
    };
    return AttributeMetadata;
  }(metadata_1.DependencyMetadata));
  exports.AttributeMetadata = AttributeMetadata;
  var QueryMetadata = (function(_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.first,
          first = _d === void 0 ? false : _d,
          _e = _b.read,
          read = _e === void 0 ? null : _e;
      _super.call(this);
      this._selector = _selector;
      this.descendants = descendants;
      this.first = first;
      this.read = read;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
      get: function() {
        return false;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
      get: function() {
        return forward_ref_1.resolveForwardRef(this._selector);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
      get: function() {
        return lang_1.isString(this.selector);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
      get: function() {
        return lang_1.StringWrapper.split(this.selector, /\s*,\s*/g);
      },
      enumerable: true,
      configurable: true
    });
    QueryMetadata.prototype.toString = function() {
      return "@Query(" + lang_1.stringify(this.selector) + ")";
    };
    return QueryMetadata;
  }(metadata_1.DependencyMetadata));
  exports.QueryMetadata = QueryMetadata;
  var ContentChildrenMetadata = (function(_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.read,
          read = _d === void 0 ? null : _d;
      _super.call(this, _selector, {
        descendants: descendants,
        read: read
      });
    }
    return ContentChildrenMetadata;
  }(QueryMetadata));
  exports.ContentChildrenMetadata = ContentChildrenMetadata;
  var ContentChildMetadata = (function(_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        first: true,
        read: read
      });
    }
    return ContentChildMetadata;
  }(QueryMetadata));
  exports.ContentChildMetadata = ContentChildMetadata;
  var ViewQueryMetadata = (function(_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.descendants,
          descendants = _c === void 0 ? false : _c,
          _d = _b.first,
          first = _d === void 0 ? false : _d,
          _e = _b.read,
          read = _e === void 0 ? null : _e;
      _super.call(this, _selector, {
        descendants: descendants,
        first: first,
        read: read
      });
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
      get: function() {
        return true;
      },
      enumerable: true,
      configurable: true
    });
    ViewQueryMetadata.prototype.toString = function() {
      return "@ViewQuery(" + lang_1.stringify(this.selector) + ")";
    };
    return ViewQueryMetadata;
  }(QueryMetadata));
  exports.ViewQueryMetadata = ViewQueryMetadata;
  var ViewChildrenMetadata = (function(_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        read: read
      });
    }
    return ViewChildrenMetadata;
  }(ViewQueryMetadata));
  exports.ViewChildrenMetadata = ViewChildrenMetadata;
  var ViewChildMetadata = (function(_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector, _a) {
      var _b = (_a === void 0 ? {} : _a).read,
          read = _b === void 0 ? null : _b;
      _super.call(this, _selector, {
        descendants: true,
        first: true,
        read: read
      });
    }
    return ViewChildMetadata;
  }(ViewQueryMetadata));
  exports.ViewChildMetadata = ViewChildMetadata;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata/directives.js", ["../change_detection/constants", "../di/metadata", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var constants_1 = $__require('../change_detection/constants');
  var metadata_1 = $__require('../di/metadata');
  var lang_1 = $__require('../facade/lang');
  var DirectiveMetadata = (function(_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selector = _b.selector,
          inputs = _b.inputs,
          outputs = _b.outputs,
          properties = _b.properties,
          events = _b.events,
          host = _b.host,
          providers = _b.providers,
          exportAs = _b.exportAs,
          queries = _b.queries;
      _super.call(this);
      this.selector = selector;
      this._inputs = inputs;
      this._properties = properties;
      this._outputs = outputs;
      this._events = events;
      this.host = host;
      this.exportAs = exportAs;
      this.queries = queries;
      this._providers = providers;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
      get: function() {
        return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties : this._inputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
      get: function() {
        return this.inputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
      get: function() {
        return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "events", {
      get: function() {
        return this.outputs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
      get: function() {
        return this._providers;
      },
      enumerable: true,
      configurable: true
    });
    return DirectiveMetadata;
  }(metadata_1.InjectableMetadata));
  exports.DirectiveMetadata = DirectiveMetadata;
  var ComponentMetadata = (function(_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          selector = _b.selector,
          inputs = _b.inputs,
          outputs = _b.outputs,
          properties = _b.properties,
          events = _b.events,
          host = _b.host,
          exportAs = _b.exportAs,
          moduleId = _b.moduleId,
          providers = _b.providers,
          viewProviders = _b.viewProviders,
          _c = _b.changeDetection,
          changeDetection = _c === void 0 ? constants_1.ChangeDetectionStrategy.Default : _c,
          queries = _b.queries,
          templateUrl = _b.templateUrl,
          template = _b.template,
          styleUrls = _b.styleUrls,
          styles = _b.styles,
          animations = _b.animations,
          directives = _b.directives,
          pipes = _b.pipes,
          encapsulation = _b.encapsulation,
          interpolation = _b.interpolation,
          entryComponents = _b.entryComponents;
      _super.call(this, {
        selector: selector,
        inputs: inputs,
        outputs: outputs,
        properties: properties,
        events: events,
        host: host,
        exportAs: exportAs,
        providers: providers,
        queries: queries
      });
      this.changeDetection = changeDetection;
      this._viewProviders = viewProviders;
      this.templateUrl = templateUrl;
      this.template = template;
      this.styleUrls = styleUrls;
      this.styles = styles;
      this.directives = directives;
      this.pipes = pipes;
      this.encapsulation = encapsulation;
      this.moduleId = moduleId;
      this.animations = animations;
      this.interpolation = interpolation;
      this.entryComponents = entryComponents;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
      get: function() {
        return this._viewProviders;
      },
      enumerable: true,
      configurable: true
    });
    return ComponentMetadata;
  }(DirectiveMetadata));
  exports.ComponentMetadata = ComponentMetadata;
  var PipeMetadata = (function(_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
      var name = _a.name,
          pure = _a.pure;
      _super.call(this);
      this.name = name;
      this._pure = pure;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
      get: function() {
        return lang_1.isPresent(this._pure) ? this._pure : true;
      },
      enumerable: true,
      configurable: true
    });
    return PipeMetadata;
  }(metadata_1.InjectableMetadata));
  exports.PipeMetadata = PipeMetadata;
  var InputMetadata = (function() {
    function InputMetadata(bindingPropertyName) {
      this.bindingPropertyName = bindingPropertyName;
    }
    return InputMetadata;
  }());
  exports.InputMetadata = InputMetadata;
  var OutputMetadata = (function() {
    function OutputMetadata(bindingPropertyName) {
      this.bindingPropertyName = bindingPropertyName;
    }
    return OutputMetadata;
  }());
  exports.OutputMetadata = OutputMetadata;
  var HostBindingMetadata = (function() {
    function HostBindingMetadata(hostPropertyName) {
      this.hostPropertyName = hostPropertyName;
    }
    return HostBindingMetadata;
  }());
  exports.HostBindingMetadata = HostBindingMetadata;
  var HostListenerMetadata = (function() {
    function HostListenerMetadata(eventName, args) {
      this.eventName = eventName;
      this.args = args;
    }
    return HostListenerMetadata;
  }());
  exports.HostListenerMetadata = HostListenerMetadata;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata/ng_module.js", ["../di/metadata"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var metadata_1 = $__require('../di/metadata');
  exports.CUSTOM_ELEMENTS_SCHEMA = {name: 'custom-elements'};
  var NgModuleMetadata = (function(_super) {
    __extends(NgModuleMetadata, _super);
    function NgModuleMetadata(options) {
      if (options === void 0) {
        options = {};
      }
      _super.call(this);
      this._providers = options.providers;
      this.declarations = options.declarations;
      this.imports = options.imports;
      this.exports = options.exports;
      this.entryComponents = options.entryComponents;
      this.bootstrap = options.bootstrap;
      this.schemas = options.schemas;
    }
    Object.defineProperty(NgModuleMetadata.prototype, "providers", {
      get: function() {
        return this._providers;
      },
      enumerable: true,
      configurable: true
    });
    return NgModuleMetadata;
  }(metadata_1.InjectableMetadata));
  exports.NgModuleMetadata = NgModuleMetadata;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata.js", ["./metadata/di", "./metadata/directives", "./metadata/ng_module", "./util/decorators", "./metadata/lifecycle_hooks", "./metadata/view"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var di_1 = $__require('./metadata/di');
  var directives_1 = $__require('./metadata/directives');
  var ng_module_1 = $__require('./metadata/ng_module');
  var decorators_1 = $__require('./util/decorators');
  var di_2 = $__require('./metadata/di');
  exports.ANALYZE_FOR_ENTRY_COMPONENTS = di_2.ANALYZE_FOR_ENTRY_COMPONENTS;
  exports.AttributeMetadata = di_2.AttributeMetadata;
  exports.ContentChildMetadata = di_2.ContentChildMetadata;
  exports.ContentChildrenMetadata = di_2.ContentChildrenMetadata;
  exports.QueryMetadata = di_2.QueryMetadata;
  exports.ViewChildMetadata = di_2.ViewChildMetadata;
  exports.ViewChildrenMetadata = di_2.ViewChildrenMetadata;
  exports.ViewQueryMetadata = di_2.ViewQueryMetadata;
  var directives_2 = $__require('./metadata/directives');
  exports.ComponentMetadata = directives_2.ComponentMetadata;
  exports.DirectiveMetadata = directives_2.DirectiveMetadata;
  exports.HostBindingMetadata = directives_2.HostBindingMetadata;
  exports.HostListenerMetadata = directives_2.HostListenerMetadata;
  exports.InputMetadata = directives_2.InputMetadata;
  exports.OutputMetadata = directives_2.OutputMetadata;
  exports.PipeMetadata = directives_2.PipeMetadata;
  var lifecycle_hooks_1 = $__require('./metadata/lifecycle_hooks');
  exports.AfterContentChecked = lifecycle_hooks_1.AfterContentChecked;
  exports.AfterContentInit = lifecycle_hooks_1.AfterContentInit;
  exports.AfterViewChecked = lifecycle_hooks_1.AfterViewChecked;
  exports.AfterViewInit = lifecycle_hooks_1.AfterViewInit;
  exports.DoCheck = lifecycle_hooks_1.DoCheck;
  exports.OnChanges = lifecycle_hooks_1.OnChanges;
  exports.OnDestroy = lifecycle_hooks_1.OnDestroy;
  exports.OnInit = lifecycle_hooks_1.OnInit;
  var ng_module_2 = $__require('./metadata/ng_module');
  exports.CUSTOM_ELEMENTS_SCHEMA = ng_module_2.CUSTOM_ELEMENTS_SCHEMA;
  exports.NgModuleMetadata = ng_module_2.NgModuleMetadata;
  var view_1 = $__require('./metadata/view');
  exports.ViewEncapsulation = view_1.ViewEncapsulation;
  exports.ViewMetadata = view_1.ViewMetadata;
  exports.Component = decorators_1.makeDecorator(directives_1.ComponentMetadata);
  exports.Directive = decorators_1.makeDecorator(directives_1.DirectiveMetadata);
  exports.Attribute = decorators_1.makeParamDecorator(di_1.AttributeMetadata);
  exports.Query = decorators_1.makeParamDecorator(di_1.QueryMetadata);
  exports.ContentChildren = decorators_1.makePropDecorator(di_1.ContentChildrenMetadata);
  exports.ContentChild = decorators_1.makePropDecorator(di_1.ContentChildMetadata);
  exports.ViewChildren = decorators_1.makePropDecorator(di_1.ViewChildrenMetadata);
  exports.ViewChild = decorators_1.makePropDecorator(di_1.ViewChildMetadata);
  exports.ViewQuery = decorators_1.makeParamDecorator(di_1.ViewQueryMetadata);
  exports.Pipe = decorators_1.makeDecorator(directives_1.PipeMetadata);
  exports.Input = decorators_1.makePropDecorator(directives_1.InputMetadata);
  exports.Output = decorators_1.makePropDecorator(directives_1.OutputMetadata);
  exports.HostBinding = decorators_1.makePropDecorator(directives_1.HostBindingMetadata);
  exports.HostListener = decorators_1.makePropDecorator(directives_1.HostListenerMetadata);
  exports.NgModule = decorators_1.makeDecorator(ng_module_1.NgModuleMetadata);
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/application_module.js", ["./application_init", "./application_ref", "./application_tokens", "./change_detection/change_detection", "./linker/compiler", "./linker/component_resolver", "./linker/dynamic_component_loader", "./linker/view_utils", "./metadata"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var application_init_1 = $__require('./application_init');
  var application_ref_1 = $__require('./application_ref');
  var application_tokens_1 = $__require('./application_tokens');
  var change_detection_1 = $__require('./change_detection/change_detection');
  var compiler_1 = $__require('./linker/compiler');
  var component_resolver_1 = $__require('./linker/component_resolver');
  var dynamic_component_loader_1 = $__require('./linker/dynamic_component_loader');
  var view_utils_1 = $__require('./linker/view_utils');
  var metadata_1 = $__require('./metadata');
  function _iterableDiffersFactory() {
    return change_detection_1.defaultIterableDiffers;
  }
  exports._iterableDiffersFactory = _iterableDiffersFactory;
  function _keyValueDiffersFactory() {
    return change_detection_1.defaultKeyValueDiffers;
  }
  exports._keyValueDiffersFactory = _keyValueDiffersFactory;
  exports.APPLICATION_COMMON_PROVIDERS = [];
  var ApplicationModule = (function() {
    function ApplicationModule() {}
    ApplicationModule.decorators = [{
      type: metadata_1.NgModule,
      args: [{providers: [application_ref_1.ApplicationRef_, {
          provide: application_ref_1.ApplicationRef,
          useExisting: application_ref_1.ApplicationRef_
        }, application_init_1.ApplicationInitStatus, compiler_1.Compiler, {
          provide: component_resolver_1.ComponentResolver,
          useExisting: compiler_1.Compiler
        }, application_tokens_1.APP_ID_RANDOM_PROVIDER, view_utils_1.ViewUtils, {
          provide: change_detection_1.IterableDiffers,
          useFactory: _iterableDiffersFactory
        }, {
          provide: change_detection_1.KeyValueDiffers,
          useFactory: _keyValueDiffersFactory
        }, {
          provide: dynamic_component_loader_1.DynamicComponentLoader,
          useClass: dynamic_component_loader_1.DynamicComponentLoader_
        }]}]
    }];
    return ApplicationModule;
  }());
  exports.ApplicationModule = ApplicationModule;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/SubjectSubscription.js", ["./Subscription"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subscription_1 = $__require('./Subscription');
  var SubjectSubscription = (function(_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, observer) {
      _super.call(this);
      this.subject = subject;
      this.observer = observer;
      this.isUnsubscribed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function() {
      if (this.isUnsubscribed) {
        return;
      }
      this.isUnsubscribed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isUnsubscribed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.observer);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription;
  }(Subscription_1.Subscription));
  exports.SubjectSubscription = SubjectSubscription;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/throwError.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function throwError(e) {
    throw e;
  }
  exports.throwError = throwError;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/ObjectUnsubscribedError.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ObjectUnsubscribedError = (function(_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
      _super.call(this, 'object unsubscribed');
      this.name = 'ObjectUnsubscribedError';
    }
    return ObjectUnsubscribedError;
  }(Error));
  exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/Subject.js", ["./Observable", "./Subscriber", "./Subscription", "./SubjectSubscription", "./symbol/rxSubscriber", "./util/throwError", "./util/ObjectUnsubscribedError"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Observable_1 = $__require('./Observable');
  var Subscriber_1 = $__require('./Subscriber');
  var Subscription_1 = $__require('./Subscription');
  var SubjectSubscription_1 = $__require('./SubjectSubscription');
  var rxSubscriber_1 = $__require('./symbol/rxSubscriber');
  var throwError_1 = $__require('./util/throwError');
  var ObjectUnsubscribedError_1 = $__require('./util/ObjectUnsubscribedError');
  var Subject = (function(_super) {
    __extends(Subject, _super);
    function Subject(destination, source) {
      _super.call(this);
      this.destination = destination;
      this.source = source;
      this.observers = [];
      this.isUnsubscribed = false;
      this.isStopped = false;
      this.hasErrored = false;
      this.dispatching = false;
      this.hasCompleted = false;
      this.source = source;
    }
    Subject.prototype.lift = function(operator) {
      var subject = new Subject(this.destination || this, this);
      subject.operator = operator;
      return subject;
    };
    Subject.prototype.add = function(subscription) {
      return Subscription_1.Subscription.prototype.add.call(this, subscription);
    };
    Subject.prototype.remove = function(subscription) {
      Subscription_1.Subscription.prototype.remove.call(this, subscription);
    };
    Subject.prototype.unsubscribe = function() {
      Subscription_1.Subscription.prototype.unsubscribe.call(this);
    };
    Subject.prototype._subscribe = function(subscriber) {
      if (this.source) {
        return this.source.subscribe(subscriber);
      } else {
        if (subscriber.isUnsubscribed) {
          return;
        } else if (this.hasErrored) {
          return subscriber.error(this.errorValue);
        } else if (this.hasCompleted) {
          return subscriber.complete();
        }
        this.throwIfUnsubscribed();
        var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        this.observers.push(subscriber);
        return subscription;
      }
    };
    Subject.prototype._unsubscribe = function() {
      this.source = null;
      this.isStopped = true;
      this.observers = null;
      this.destination = null;
    };
    Subject.prototype.next = function(value) {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.dispatching = true;
      this._next(value);
      this.dispatching = false;
      if (this.hasErrored) {
        this._error(this.errorValue);
      } else if (this.hasCompleted) {
        this._complete();
      }
    };
    Subject.prototype.error = function(err) {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.isStopped = true;
      this.hasErrored = true;
      this.errorValue = err;
      if (this.dispatching) {
        return;
      }
      this._error(err);
    };
    Subject.prototype.complete = function() {
      this.throwIfUnsubscribed();
      if (this.isStopped) {
        return;
      }
      this.isStopped = true;
      this.hasCompleted = true;
      if (this.dispatching) {
        return;
      }
      this._complete();
    };
    Subject.prototype.asObservable = function() {
      var observable = new SubjectObservable(this);
      return observable;
    };
    Subject.prototype._next = function(value) {
      if (this.destination) {
        this.destination.next(value);
      } else {
        this._finalNext(value);
      }
    };
    Subject.prototype._finalNext = function(value) {
      var index = -1;
      var observers = this.observers.slice(0);
      var len = observers.length;
      while (++index < len) {
        observers[index].next(value);
      }
    };
    Subject.prototype._error = function(err) {
      if (this.destination) {
        this.destination.error(err);
      } else {
        this._finalError(err);
      }
    };
    Subject.prototype._finalError = function(err) {
      var index = -1;
      var observers = this.observers;
      this.observers = null;
      this.isUnsubscribed = true;
      if (observers) {
        var len = observers.length;
        while (++index < len) {
          observers[index].error(err);
        }
      }
      this.isUnsubscribed = false;
      this.unsubscribe();
    };
    Subject.prototype._complete = function() {
      if (this.destination) {
        this.destination.complete();
      } else {
        this._finalComplete();
      }
    };
    Subject.prototype._finalComplete = function() {
      var index = -1;
      var observers = this.observers;
      this.observers = null;
      this.isUnsubscribed = true;
      if (observers) {
        var len = observers.length;
        while (++index < len) {
          observers[index].complete();
        }
      }
      this.isUnsubscribed = false;
      this.unsubscribe();
    };
    Subject.prototype.throwIfUnsubscribed = function() {
      if (this.isUnsubscribed) {
        throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
      }
    };
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function() {
      return new Subscriber_1.Subscriber(this);
    };
    Subject.create = function(destination, source) {
      return new Subject(destination, source);
    };
    return Subject;
  }(Observable_1.Observable));
  exports.Subject = Subject;
  var SubjectObservable = (function(_super) {
    __extends(SubjectObservable, _super);
    function SubjectObservable(source) {
      _super.call(this);
      this.source = source;
    }
    return SubjectObservable;
  }(Observable_1.Observable));
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/symbol/observable.js", ["../util/root"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var root_1 = $__require('../util/root');
  var Symbol = root_1.root.Symbol;
  if (typeof Symbol === 'function') {
    if (Symbol.observable) {
      exports.$$observable = Symbol.observable;
    } else {
      if (typeof Symbol.for === 'function') {
        exports.$$observable = Symbol.for('observable');
      } else {
        exports.$$observable = Symbol('observable');
      }
      Symbol.observable = exports.$$observable;
    }
  } else {
    exports.$$observable = '@@observable';
  }
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/isArray.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.isArray = Array.isArray || (function(x) {
    return x && typeof x.length === 'number';
  });
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/isObject.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function isObject(x) {
    return x != null && typeof x === 'object';
  }
  exports.isObject = isObject;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/isFunction.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function isFunction(x) {
    return typeof x === 'function';
  }
  exports.isFunction = isFunction;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/tryCatch.js", ["./errorObject"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var errorObject_1 = $__require('./errorObject');
  var tryCatchTarget;
  function tryCatcher() {
    try {
      return tryCatchTarget.apply(this, arguments);
    } catch (e) {
      errorObject_1.errorObject.e = e;
      return errorObject_1.errorObject;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  exports.tryCatch = tryCatch;
  ;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/errorObject.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.errorObject = {e: {}};
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/UnsubscriptionError.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var UnsubscriptionError = (function(_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
      _super.call(this);
      this.errors = errors;
      this.name = 'UnsubscriptionError';
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return ((i + 1) + ") " + err.toString());
      }).join('\n') : '';
    }
    return UnsubscriptionError;
  }(Error));
  exports.UnsubscriptionError = UnsubscriptionError;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/Subscription.js", ["./util/isArray", "./util/isObject", "./util/isFunction", "./util/tryCatch", "./util/errorObject", "./util/UnsubscriptionError"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var isArray_1 = $__require('./util/isArray');
  var isObject_1 = $__require('./util/isObject');
  var isFunction_1 = $__require('./util/isFunction');
  var tryCatch_1 = $__require('./util/tryCatch');
  var errorObject_1 = $__require('./util/errorObject');
  var UnsubscriptionError_1 = $__require('./util/UnsubscriptionError');
  var Subscription = (function() {
    function Subscription(unsubscribe) {
      this.isUnsubscribed = false;
      if (unsubscribe) {
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription.prototype.unsubscribe = function() {
      var hasErrors = false;
      var errors;
      if (this.isUnsubscribed) {
        return;
      }
      this.isUnsubscribed = true;
      var _a = this,
          _unsubscribe = _a._unsubscribe,
          _subscriptions = _a._subscriptions;
      this._subscriptions = null;
      if (isFunction_1.isFunction(_unsubscribe)) {
        var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
        if (trial === errorObject_1.errorObject) {
          hasErrors = true;
          (errors = errors || []).push(errorObject_1.errorObject.e);
        }
      }
      if (isArray_1.isArray(_subscriptions)) {
        var index = -1;
        var len = _subscriptions.length;
        while (++index < len) {
          var sub = _subscriptions[index];
          if (isObject_1.isObject(sub)) {
            var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
            if (trial === errorObject_1.errorObject) {
              hasErrors = true;
              errors = errors || [];
              var err = errorObject_1.errorObject.e;
              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.concat(err.errors);
              } else {
                errors.push(err);
              }
            }
          }
        }
      }
      if (hasErrors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
      }
    };
    Subscription.prototype.add = function(teardown) {
      if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
        return;
      }
      var sub = teardown;
      switch (typeof teardown) {
        case 'function':
          sub = new Subscription(teardown);
        case 'object':
          if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
            break;
          } else if (this.isUnsubscribed) {
            sub.unsubscribe();
          } else {
            (this._subscriptions || (this._subscriptions = [])).push(sub);
          }
          break;
        default:
          throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
      }
      return sub;
    };
    Subscription.prototype.remove = function(subscription) {
      if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
        return;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription.EMPTY = (function(empty) {
      empty.isUnsubscribed = true;
      return empty;
    }(new Subscription()));
    return Subscription;
  }());
  exports.Subscription = Subscription;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/Observer.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.empty = {
    isUnsubscribed: true,
    next: function(value) {},
    error: function(err) {
      throw err;
    },
    complete: function() {}
  };
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/Subscriber.js", ["./util/isFunction", "./Subscription", "./symbol/rxSubscriber", "./Observer"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var isFunction_1 = $__require('./util/isFunction');
  var Subscription_1 = $__require('./Subscription');
  var rxSubscriber_1 = $__require('./symbol/rxSubscriber');
  var Observer_1 = $__require('./Observer');
  var Subscriber = (function(_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
      _super.call(this);
      this.syncErrorValue = null;
      this.syncErrorThrown = false;
      this.syncErrorThrowable = false;
      this.isStopped = false;
      switch (arguments.length) {
        case 0:
          this.destination = Observer_1.empty;
          break;
        case 1:
          if (!destinationOrNext) {
            this.destination = Observer_1.empty;
            break;
          }
          if (typeof destinationOrNext === 'object') {
            if (destinationOrNext instanceof Subscriber) {
              this.destination = destinationOrNext;
              this.destination.add(this);
            } else {
              this.syncErrorThrowable = true;
              this.destination = new SafeSubscriber(this, destinationOrNext);
            }
            break;
          }
        default:
          this.syncErrorThrowable = true;
          this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
          break;
      }
    }
    Subscriber.create = function(next, error, complete) {
      var subscriber = new Subscriber(next, error, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber.prototype.next = function(value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    Subscriber.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber.prototype.unsubscribe = function() {
      if (this.isUnsubscribed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function() {
      return this;
    };
    return Subscriber;
  }(Subscription_1.Subscription));
  exports.Subscriber = Subscriber;
  var SafeSubscriber = (function(_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
      _super.call(this);
      this._parent = _parent;
      var next;
      var context = this;
      if (isFunction_1.isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        context = observerOrNext;
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
        if (isFunction_1.isFunction(context.unsubscribe)) {
          this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = this.unsubscribe.bind(this);
      }
      this._context = context;
      this._next = next;
      this._error = error;
      this._complete = complete;
    }
    SafeSubscriber.prototype.next = function(value) {
      if (!this.isStopped && this._next) {
        var _parent = this._parent;
        if (!_parent.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value);
        } else if (this.__tryOrSetError(_parent, this._next, value)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parent = this._parent;
        if (this._error) {
          if (!_parent.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parent, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parent.syncErrorThrowable) {
          this.unsubscribe();
          throw err;
        } else {
          _parent.syncErrorValue = err;
          _parent.syncErrorThrown = true;
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.complete = function() {
      if (!this.isStopped) {
        var _parent = this._parent;
        if (this._complete) {
          if (!_parent.syncErrorThrowable) {
            this.__tryOrUnsub(this._complete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parent, this._complete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        this.unsubscribe();
        throw err;
      }
    };
    SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      }
      return false;
    };
    SafeSubscriber.prototype._unsubscribe = function() {
      var _parent = this._parent;
      this._context = null;
      this._parent = null;
      _parent.unsubscribe();
    };
    return SafeSubscriber;
  }(Subscriber));
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/root.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };
  exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
  }
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/symbol/rxSubscriber.js", ["../util/root"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var root_1 = $__require('../util/root');
  var Symbol = root_1.root.Symbol;
  exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/util/toSubscriber.js", ["../Subscriber", "../symbol/rxSubscriber"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var Subscriber_1 = $__require('../Subscriber');
  var rxSubscriber_1 = $__require('../symbol/rxSubscriber');
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver === 'object') {
      if (nextOrObserver instanceof Subscriber_1.Subscriber) {
        return nextOrObserver;
      } else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
        return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
      }
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
  }
  exports.toSubscriber = toSubscriber;
  return module.exports;
});

System.registerDynamic("node_modules/rxjs/Observable.js", ["./util/root", "./symbol/observable", "./util/toSubscriber"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var root_1 = $__require('./util/root');
  var observable_1 = $__require('./symbol/observable');
  var toSubscriber_1 = $__require('./util/toSubscriber');
  var Observable = (function() {
    function Observable(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable.prototype.lift = function(operator) {
      var observable = new Observable();
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable.prototype.subscribe = function(observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
      sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
      return sink;
    };
    Observable.prototype.forEach = function(next, PromiseCtor) {
      var _this = this;
      if (!PromiseCtor) {
        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
          PromiseCtor = root_1.root.Rx.config.Promise;
        } else if (root_1.root.Promise) {
          PromiseCtor = root_1.root.Promise;
        }
      }
      if (!PromiseCtor) {
        throw new Error('no Promise impl found');
      }
      return new PromiseCtor(function(resolve, reject) {
        var subscription = _this.subscribe(function(value) {
          if (subscription) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscription.unsubscribe();
            }
          } else {
            next(value);
          }
        }, reject, resolve);
      });
    };
    Observable.prototype._subscribe = function(subscriber) {
      return this.source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.$$observable] = function() {
      return this;
    };
    Observable.create = function(subscribe) {
      return new Observable(subscribe);
    };
    return Observable;
  }());
  exports.Observable = Observable;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/async.js", ["rxjs/Subject", "rxjs/Observable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var Subject_1 = $__require('rxjs/Subject');
  var Observable_1 = $__require('rxjs/Observable');
  exports.Observable = Observable_1.Observable;
  var Subject_2 = $__require('rxjs/Subject');
  exports.Subject = Subject_2.Subject;
  var EventEmitter = (function(_super) {
    __extends(EventEmitter, _super);
    function EventEmitter(isAsync) {
      if (isAsync === void 0) {
        isAsync = false;
      }
      _super.call(this);
      this.__isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.next = function(value) {
      _super.prototype.next.call(this, value);
    };
    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
      var schedulerFn;
      var errorFn = function(err) {
        return null;
      };
      var completeFn = function() {
        return null;
      };
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext.next(value);
          });
        } : function(value) {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return generatorOrNext.error(err);
            });
          } : function(err) {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return generatorOrNext.complete();
            });
          } : function() {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this.__isAsync ? function(value) {
          setTimeout(function() {
            return generatorOrNext(value);
          });
        } : function(value) {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this.__isAsync ? function(err) {
            setTimeout(function() {
              return error(err);
            });
          } : function(err) {
            error(err);
          };
        }
        if (complete) {
          completeFn = this.__isAsync ? function() {
            setTimeout(function() {
              return complete();
            });
          } : function() {
            complete();
          };
        }
      }
      return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
  }(Subject_1.Subject));
  exports.EventEmitter = EventEmitter;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_keyframe.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var AnimationKeyframe = (function() {
    function AnimationKeyframe(offset, styles) {
      this.offset = offset;
      this.styles = styles;
    }
    return AnimationKeyframe;
  }());
  exports.AnimationKeyframe = AnimationKeyframe;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_sequence_player.js", ["../facade/lang", "./animation_player"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var animation_player_1 = $__require('./animation_player');
  var AnimationSequencePlayer = (function() {
    function AnimationSequencePlayer(_players) {
      var _this = this;
      this._players = _players;
      this._currentIndex = 0;
      this._subscriptions = [];
      this._finished = false;
      this._started = false;
      this.parentPlayer = null;
      this._players.forEach(function(player) {
        player.parentPlayer = _this;
      });
      this._onNext(false);
    }
    AnimationSequencePlayer.prototype._onNext = function(start) {
      var _this = this;
      if (this._finished)
        return;
      if (this._players.length == 0) {
        this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
        lang_1.scheduleMicroTask(function() {
          return _this._onFinish();
        });
      } else if (this._currentIndex >= this._players.length) {
        this._activePlayer = new animation_player_1.NoOpAnimationPlayer();
        this._onFinish();
      } else {
        var player = this._players[this._currentIndex++];
        player.onDone(function() {
          return _this._onNext(true);
        });
        this._activePlayer = player;
        if (start) {
          player.play();
        }
      }
    };
    AnimationSequencePlayer.prototype._onFinish = function() {
      if (!this._finished) {
        this._finished = true;
        if (!lang_1.isPresent(this.parentPlayer)) {
          this.destroy();
        }
        this._subscriptions.forEach(function(subscription) {
          return subscription();
        });
        this._subscriptions = [];
      }
    };
    AnimationSequencePlayer.prototype.init = function() {
      this._players.forEach(function(player) {
        return player.init();
      });
    };
    AnimationSequencePlayer.prototype.onDone = function(fn) {
      this._subscriptions.push(fn);
    };
    AnimationSequencePlayer.prototype.hasStarted = function() {
      return this._started;
    };
    AnimationSequencePlayer.prototype.play = function() {
      if (!lang_1.isPresent(this.parentPlayer)) {
        this.init();
      }
      this._started = true;
      this._activePlayer.play();
    };
    AnimationSequencePlayer.prototype.pause = function() {
      this._activePlayer.pause();
    };
    AnimationSequencePlayer.prototype.restart = function() {
      if (this._players.length > 0) {
        this.reset();
        this._players[0].restart();
      }
    };
    AnimationSequencePlayer.prototype.reset = function() {
      this._players.forEach(function(player) {
        return player.reset();
      });
    };
    AnimationSequencePlayer.prototype.finish = function() {
      this._onFinish();
      this._players.forEach(function(player) {
        return player.finish();
      });
    };
    AnimationSequencePlayer.prototype.destroy = function() {
      this._onFinish();
      this._players.forEach(function(player) {
        return player.destroy();
      });
    };
    AnimationSequencePlayer.prototype.setPosition = function(p) {
      this._players[0].setPosition(p);
    };
    AnimationSequencePlayer.prototype.getPosition = function() {
      return this._players[0].getPosition();
    };
    return AnimationSequencePlayer;
  }());
  exports.AnimationSequencePlayer = AnimationSequencePlayer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_constants.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  exports.FILL_STYLE_FLAG = 'true';
  exports.ANY_STATE = '*';
  exports.DEFAULT_STATE = '*';
  exports.EMPTY_STATE = 'void';
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_style_util.js", ["../facade/collection", "../facade/lang", "./animation_constants", "./metadata"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var animation_constants_1 = $__require('./animation_constants');
  var metadata_1 = $__require('./metadata');
  function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
    if (nullValue === void 0) {
      nullValue = null;
    }
    var finalStyles = {};
    collection_1.StringMapWrapper.forEach(newStyles, function(value, prop) {
      finalStyles[prop] = value == metadata_1.AUTO_STYLE ? nullValue : value.toString();
    });
    collection_1.StringMapWrapper.forEach(previousStyles, function(value, prop) {
      if (!lang_1.isPresent(finalStyles[prop])) {
        finalStyles[prop] = nullValue;
      }
    });
    return finalStyles;
  }
  exports.prepareFinalAnimationStyles = prepareFinalAnimationStyles;
  function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
    var limit = keyframes.length - 1;
    var firstKeyframe = keyframes[0];
    var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
    var extraFirstKeyframeStyles = {};
    var hasExtraFirstStyles = false;
    collection_1.StringMapWrapper.forEach(collectedStyles, function(value, prop) {
      if (!flatenedFirstKeyframeStyles[prop]) {
        flatenedFirstKeyframeStyles[prop] = value;
        extraFirstKeyframeStyles[prop] = value;
        hasExtraFirstStyles = true;
      }
    });
    var keyframeCollectedStyles = collection_1.StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
    var finalKeyframe = keyframes[limit];
    collection_1.ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
    var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
    var extraFinalKeyframeStyles = {};
    var hasExtraFinalStyles = false;
    collection_1.StringMapWrapper.forEach(keyframeCollectedStyles, function(value, prop) {
      if (!lang_1.isPresent(flatenedFinalKeyframeStyles[prop])) {
        extraFinalKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
        hasExtraFinalStyles = true;
      }
    });
    if (hasExtraFinalStyles) {
      finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
    }
    collection_1.StringMapWrapper.forEach(flatenedFinalKeyframeStyles, function(value, prop) {
      if (!lang_1.isPresent(flatenedFirstKeyframeStyles[prop])) {
        extraFirstKeyframeStyles[prop] = metadata_1.AUTO_STYLE;
        hasExtraFirstStyles = true;
      }
    });
    if (hasExtraFirstStyles) {
      firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
    }
    return keyframes;
  }
  exports.balanceAnimationKeyframes = balanceAnimationKeyframes;
  function clearStyles(styles) {
    var finalStyles = {};
    collection_1.StringMapWrapper.keys(styles).forEach(function(key) {
      finalStyles[key] = null;
    });
    return finalStyles;
  }
  exports.clearStyles = clearStyles;
  function collectAndResolveStyles(collection, styles) {
    return styles.map(function(entry) {
      var stylesObj = {};
      collection_1.StringMapWrapper.forEach(entry, function(value, prop) {
        if (value == animation_constants_1.FILL_STYLE_FLAG) {
          value = collection[prop];
          if (!lang_1.isPresent(value)) {
            value = metadata_1.AUTO_STYLE;
          }
        }
        collection[prop] = value;
        stylesObj[prop] = value;
      });
      return stylesObj;
    });
  }
  exports.collectAndResolveStyles = collectAndResolveStyles;
  function renderStyles(element, renderer, styles) {
    collection_1.StringMapWrapper.forEach(styles, function(value, prop) {
      renderer.setElementStyle(element, prop, value);
    });
  }
  exports.renderStyles = renderStyles;
  function flattenStyles(styles) {
    var finalStyles = {};
    styles.forEach(function(entry) {
      collection_1.StringMapWrapper.forEach(entry, function(value, prop) {
        finalStyles[prop] = value;
      });
    });
    return finalStyles;
  }
  exports.flattenStyles = flattenStyles;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_styles.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var AnimationStyles = (function() {
    function AnimationStyles(styles) {
      this.styles = styles;
    }
    return AnimationStyles;
  }());
  exports.AnimationStyles = AnimationStyles;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/console.js", ["./di/decorators", "./facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var decorators_1 = $__require('./di/decorators');
  var lang_1 = $__require('./facade/lang');
  var Console = (function() {
    function Console() {}
    Console.prototype.log = function(message) {
      lang_1.print(message);
    };
    Console.prototype.warn = function(message) {
      lang_1.warn(message);
    };
    Console.decorators = [{type: decorators_1.Injectable}];
    return Console;
  }());
  exports.Console = Console;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/debug/debug_node.js", ["../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var EventListener = (function() {
    function EventListener(name, callback) {
      this.name = name;
      this.callback = callback;
    }
    ;
    return EventListener;
  }());
  exports.EventListener = EventListener;
  var DebugNode = (function() {
    function DebugNode(nativeNode, parent, _debugInfo) {
      this._debugInfo = _debugInfo;
      this.nativeNode = nativeNode;
      if (lang_1.isPresent(parent) && parent instanceof DebugElement) {
        parent.addChild(this);
      } else {
        this.parent = null;
      }
      this.listeners = [];
    }
    Object.defineProperty(DebugNode.prototype, "injector", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.injector : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "componentInstance", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.component : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "context", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.context : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "references", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.references : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "providerTokens", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "source", {
      get: function() {
        return lang_1.isPresent(this._debugInfo) ? this._debugInfo.source : null;
      },
      enumerable: true,
      configurable: true
    });
    DebugNode.prototype.inject = function(token) {
      return this.injector.get(token);
    };
    return DebugNode;
  }());
  exports.DebugNode = DebugNode;
  var DebugElement = (function(_super) {
    __extends(DebugElement, _super);
    function DebugElement(nativeNode, parent, _debugInfo) {
      _super.call(this, nativeNode, parent, _debugInfo);
      this.properties = {};
      this.attributes = {};
      this.classes = {};
      this.styles = {};
      this.childNodes = [];
      this.nativeElement = nativeNode;
    }
    DebugElement.prototype.addChild = function(child) {
      if (lang_1.isPresent(child)) {
        this.childNodes.push(child);
        child.parent = this;
      }
    };
    DebugElement.prototype.removeChild = function(child) {
      var childIndex = this.childNodes.indexOf(child);
      if (childIndex !== -1) {
        child.parent = null;
        this.childNodes.splice(childIndex, 1);
      }
    };
    DebugElement.prototype.insertChildrenAfter = function(child, newChildren) {
      var siblingIndex = this.childNodes.indexOf(child);
      if (siblingIndex !== -1) {
        var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
        var nextChildren = this.childNodes.slice(siblingIndex + 1);
        this.childNodes = collection_1.ListWrapper.concat(collection_1.ListWrapper.concat(previousChildren, newChildren), nextChildren);
        for (var i = 0; i < newChildren.length; ++i) {
          var newChild = newChildren[i];
          if (lang_1.isPresent(newChild.parent)) {
            newChild.parent.removeChild(newChild);
          }
          newChild.parent = this;
        }
      }
    };
    DebugElement.prototype.query = function(predicate) {
      var results = this.queryAll(predicate);
      return results.length > 0 ? results[0] : null;
    };
    DebugElement.prototype.queryAll = function(predicate) {
      var matches = [];
      _queryElementChildren(this, predicate, matches);
      return matches;
    };
    DebugElement.prototype.queryAllNodes = function(predicate) {
      var matches = [];
      _queryNodeChildren(this, predicate, matches);
      return matches;
    };
    Object.defineProperty(DebugElement.prototype, "children", {
      get: function() {
        var children = [];
        this.childNodes.forEach(function(node) {
          if (node instanceof DebugElement) {
            children.push(node);
          }
        });
        return children;
      },
      enumerable: true,
      configurable: true
    });
    DebugElement.prototype.triggerEventHandler = function(eventName, eventObj) {
      this.listeners.forEach(function(listener) {
        if (listener.name == eventName) {
          listener.callback(eventObj);
        }
      });
    };
    return DebugElement;
  }(DebugNode));
  exports.DebugElement = DebugElement;
  function asNativeElements(debugEls) {
    return debugEls.map(function(el) {
      return el.nativeElement;
    });
  }
  exports.asNativeElements = asNativeElements;
  function _queryElementChildren(element, predicate, matches) {
    element.childNodes.forEach(function(node) {
      if (node instanceof DebugElement) {
        if (predicate(node)) {
          matches.push(node);
        }
        _queryElementChildren(node, predicate, matches);
      }
    });
  }
  function _queryNodeChildren(parentNode, predicate, matches) {
    if (parentNode instanceof DebugElement) {
      parentNode.childNodes.forEach(function(node) {
        if (predicate(node)) {
          matches.push(node);
        }
        if (node instanceof DebugElement) {
          _queryNodeChildren(node, predicate, matches);
        }
      });
    }
  }
  var _nativeNodeToDebugNode = new Map();
  function getDebugNode(nativeNode) {
    return _nativeNodeToDebugNode.get(nativeNode);
  }
  exports.getDebugNode = getDebugNode;
  function getAllDebugNodes() {
    return collection_1.MapWrapper.values(_nativeNodeToDebugNode);
  }
  exports.getAllDebugNodes = getAllDebugNodes;
  function indexDebugNode(node) {
    _nativeNodeToDebugNode.set(node.nativeNode, node);
  }
  exports.indexDebugNode = indexDebugNode;
  function removeDebugNodeFromIndex(node) {
    _nativeNodeToDebugNode.delete(node.nativeNode);
  }
  exports.removeDebugNodeFromIndex = removeDebugNodeFromIndex;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/debug/debug_renderer.js", ["../facade/lang", "./debug_node"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var debug_node_1 = $__require('./debug_node');
  var DebugDomRootRenderer = (function() {
    function DebugDomRootRenderer(_delegate) {
      this._delegate = _delegate;
    }
    DebugDomRootRenderer.prototype.renderComponent = function(componentProto) {
      return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
    };
    return DebugDomRootRenderer;
  }());
  exports.DebugDomRootRenderer = DebugDomRootRenderer;
  var DebugDomRenderer = (function() {
    function DebugDomRenderer(_delegate) {
      this._delegate = _delegate;
    }
    DebugDomRenderer.prototype.selectRootElement = function(selectorOrNode, debugInfo) {
      var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
      var debugEl = new debug_node_1.DebugElement(nativeEl, null, debugInfo);
      debug_node_1.indexDebugNode(debugEl);
      return nativeEl;
    };
    DebugDomRenderer.prototype.createElement = function(parentElement, name, debugInfo) {
      var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
      var debugEl = new debug_node_1.DebugElement(nativeEl, debug_node_1.getDebugNode(parentElement), debugInfo);
      debugEl.name = name;
      debug_node_1.indexDebugNode(debugEl);
      return nativeEl;
    };
    DebugDomRenderer.prototype.createViewRoot = function(hostElement) {
      return this._delegate.createViewRoot(hostElement);
    };
    DebugDomRenderer.prototype.createTemplateAnchor = function(parentElement, debugInfo) {
      var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
      var debugEl = new debug_node_1.DebugNode(comment, debug_node_1.getDebugNode(parentElement), debugInfo);
      debug_node_1.indexDebugNode(debugEl);
      return comment;
    };
    DebugDomRenderer.prototype.createText = function(parentElement, value, debugInfo) {
      var text = this._delegate.createText(parentElement, value, debugInfo);
      var debugEl = new debug_node_1.DebugNode(text, debug_node_1.getDebugNode(parentElement), debugInfo);
      debug_node_1.indexDebugNode(debugEl);
      return text;
    };
    DebugDomRenderer.prototype.projectNodes = function(parentElement, nodes) {
      var debugParent = debug_node_1.getDebugNode(parentElement);
      if (lang_1.isPresent(debugParent) && debugParent instanceof debug_node_1.DebugElement) {
        var debugElement_1 = debugParent;
        nodes.forEach(function(node) {
          debugElement_1.addChild(debug_node_1.getDebugNode(node));
        });
      }
      this._delegate.projectNodes(parentElement, nodes);
    };
    DebugDomRenderer.prototype.attachViewAfter = function(node, viewRootNodes) {
      var debugNode = debug_node_1.getDebugNode(node);
      if (lang_1.isPresent(debugNode)) {
        var debugParent = debugNode.parent;
        if (viewRootNodes.length > 0 && lang_1.isPresent(debugParent)) {
          var debugViewRootNodes = [];
          viewRootNodes.forEach(function(rootNode) {
            return debugViewRootNodes.push(debug_node_1.getDebugNode(rootNode));
          });
          debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
        }
      }
      this._delegate.attachViewAfter(node, viewRootNodes);
    };
    DebugDomRenderer.prototype.detachView = function(viewRootNodes) {
      viewRootNodes.forEach(function(node) {
        var debugNode = debug_node_1.getDebugNode(node);
        if (lang_1.isPresent(debugNode) && lang_1.isPresent(debugNode.parent)) {
          debugNode.parent.removeChild(debugNode);
        }
      });
      this._delegate.detachView(viewRootNodes);
    };
    DebugDomRenderer.prototype.destroyView = function(hostElement, viewAllNodes) {
      viewAllNodes.forEach(function(node) {
        debug_node_1.removeDebugNodeFromIndex(debug_node_1.getDebugNode(node));
      });
      this._delegate.destroyView(hostElement, viewAllNodes);
    };
    DebugDomRenderer.prototype.listen = function(renderElement, name, callback) {
      var debugEl = debug_node_1.getDebugNode(renderElement);
      if (lang_1.isPresent(debugEl)) {
        debugEl.listeners.push(new debug_node_1.EventListener(name, callback));
      }
      return this._delegate.listen(renderElement, name, callback);
    };
    DebugDomRenderer.prototype.listenGlobal = function(target, name, callback) {
      return this._delegate.listenGlobal(target, name, callback);
    };
    DebugDomRenderer.prototype.setElementProperty = function(renderElement, propertyName, propertyValue) {
      var debugEl = debug_node_1.getDebugNode(renderElement);
      if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
        debugEl.properties[propertyName] = propertyValue;
      }
      this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementAttribute = function(renderElement, attributeName, attributeValue) {
      var debugEl = debug_node_1.getDebugNode(renderElement);
      if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
        debugEl.attributes[attributeName] = attributeValue;
      }
      this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
    };
    DebugDomRenderer.prototype.setBindingDebugInfo = function(renderElement, propertyName, propertyValue) {
      this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementClass = function(renderElement, className, isAdd) {
      var debugEl = debug_node_1.getDebugNode(renderElement);
      if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
        debugEl.classes[className] = isAdd;
      }
      this._delegate.setElementClass(renderElement, className, isAdd);
    };
    DebugDomRenderer.prototype.setElementStyle = function(renderElement, styleName, styleValue) {
      var debugEl = debug_node_1.getDebugNode(renderElement);
      if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
        debugEl.styles[styleName] = styleValue;
      }
      this._delegate.setElementStyle(renderElement, styleName, styleValue);
    };
    DebugDomRenderer.prototype.invokeElementMethod = function(renderElement, methodName, args) {
      this._delegate.invokeElementMethod(renderElement, methodName, args);
    };
    DebugDomRenderer.prototype.setText = function(renderNode, text) {
      this._delegate.setText(renderNode, text);
    };
    DebugDomRenderer.prototype.animate = function(element, startingStyles, keyframes, duration, delay, easing) {
      return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
    };
    return DebugDomRenderer;
  }());
  exports.DebugDomRenderer = DebugDomRenderer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/component_factory_resolver.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var NoComponentFactoryError = (function(_super) {
    __extends(NoComponentFactoryError, _super);
    function NoComponentFactoryError(component) {
      _super.call(this, "No component factory found for " + lang_1.stringify(component));
      this.component = component;
    }
    return NoComponentFactoryError;
  }(exceptions_1.BaseException));
  exports.NoComponentFactoryError = NoComponentFactoryError;
  var _NullComponentFactoryResolver = (function() {
    function _NullComponentFactoryResolver() {}
    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
      throw new NoComponentFactoryError(component);
    };
    return _NullComponentFactoryResolver;
  }());
  var ComponentFactoryResolver = (function() {
    function ComponentFactoryResolver() {}
    ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
    return ComponentFactoryResolver;
  }());
  exports.ComponentFactoryResolver = ComponentFactoryResolver;
  var CodegenComponentFactoryResolver = (function() {
    function CodegenComponentFactoryResolver(factories, _parent) {
      this._parent = _parent;
      this._factories = new Map();
      for (var i = 0; i < factories.length; i++) {
        var factory = factories[i];
        this._factories.set(factory.componentType, factory);
      }
    }
    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function(component) {
      var result = this._factories.get(component);
      if (!result) {
        result = this._parent.resolveComponentFactory(component);
      }
      return result;
    };
    return CodegenComponentFactoryResolver;
  }());
  exports.CodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/ng_module_factory.js", ["../di/injector", "../facade/exceptions", "../facade/lang", "./component_factory_resolver"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var injector_1 = $__require('../di/injector');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var component_factory_resolver_1 = $__require('./component_factory_resolver');
  var NgModuleRef = (function() {
    function NgModuleRef() {}
    Object.defineProperty(NgModuleRef.prototype, "injector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModuleRef.prototype, "instance", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return NgModuleRef;
  }());
  exports.NgModuleRef = NgModuleRef;
  var NgModuleFactory = (function() {
    function NgModuleFactory(_injectorClass, _moduleype) {
      this._injectorClass = _injectorClass;
      this._moduleype = _moduleype;
    }
    Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
      get: function() {
        return this._moduleype;
      },
      enumerable: true,
      configurable: true
    });
    NgModuleFactory.prototype.create = function(parentInjector) {
      if (!parentInjector) {
        parentInjector = injector_1.Injector.NULL;
      }
      var instance = new this._injectorClass(parentInjector);
      instance.create();
      return instance;
    };
    return NgModuleFactory;
  }());
  exports.NgModuleFactory = NgModuleFactory;
  var _UNDEFINED = new Object();
  var NgModuleInjector = (function(_super) {
    __extends(NgModuleInjector, _super);
    function NgModuleInjector(parent, factories, bootstrapFactories) {
      _super.call(this, factories, parent.get(component_factory_resolver_1.ComponentFactoryResolver, component_factory_resolver_1.ComponentFactoryResolver.NULL));
      this.parent = parent;
      this.bootstrapFactories = bootstrapFactories;
      this._destroyListeners = [];
      this._destroyed = false;
    }
    NgModuleInjector.prototype.create = function() {
      this.instance = this.createInternal();
    };
    NgModuleInjector.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = injector_1.THROW_IF_NOT_FOUND;
      }
      if (token === injector_1.Injector || token === component_factory_resolver_1.ComponentFactoryResolver) {
        return this;
      }
      var result = this.getInternal(token, _UNDEFINED);
      return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
    };
    Object.defineProperty(NgModuleInjector.prototype, "injector", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    NgModuleInjector.prototype.destroy = function() {
      if (this._destroyed) {
        throw new exceptions_1.BaseException("The ng module " + lang_1.stringify(this.instance.constructor) + " has already been destroyed.");
      }
      this._destroyed = true;
      this.destroyInternal();
      this._destroyListeners.forEach(function(listener) {
        return listener();
      });
    };
    NgModuleInjector.prototype.onDestroy = function(callback) {
      this._destroyListeners.push(callback);
    };
    return NgModuleInjector;
  }(component_factory_resolver_1.CodegenComponentFactoryResolver));
  exports.NgModuleInjector = NgModuleInjector;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/template_ref.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var TemplateRef = (function() {
    function TemplateRef() {}
    Object.defineProperty(TemplateRef.prototype, "elementRef", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return TemplateRef;
  }());
  exports.TemplateRef = TemplateRef;
  var TemplateRef_ = (function(_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(_appElement, _viewFactory) {
      _super.call(this);
      this._appElement = _appElement;
      this._viewFactory = _viewFactory;
    }
    TemplateRef_.prototype.createEmbeddedView = function(context) {
      var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
      view.create(context || {}, null, null);
      return view.ref;
    };
    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
      get: function() {
        return this._appElement.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    return TemplateRef_;
  }(TemplateRef));
  exports.TemplateRef_ = TemplateRef_;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/math.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Math = lang_1.global.Math;
  exports.NaN = typeof exports.NaN;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_group_player.js", ["../facade/lang", "../facade/math"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var math_1 = $__require('../facade/math');
  var AnimationGroupPlayer = (function() {
    function AnimationGroupPlayer(_players) {
      var _this = this;
      this._players = _players;
      this._subscriptions = [];
      this._finished = false;
      this._started = false;
      this.parentPlayer = null;
      var count = 0;
      var total = this._players.length;
      if (total == 0) {
        lang_1.scheduleMicroTask(function() {
          return _this._onFinish();
        });
      } else {
        this._players.forEach(function(player) {
          player.parentPlayer = _this;
          player.onDone(function() {
            if (++count >= total) {
              _this._onFinish();
            }
          });
        });
      }
    }
    AnimationGroupPlayer.prototype._onFinish = function() {
      if (!this._finished) {
        this._finished = true;
        if (!lang_1.isPresent(this.parentPlayer)) {
          this.destroy();
        }
        this._subscriptions.forEach(function(subscription) {
          return subscription();
        });
        this._subscriptions = [];
      }
    };
    AnimationGroupPlayer.prototype.init = function() {
      this._players.forEach(function(player) {
        return player.init();
      });
    };
    AnimationGroupPlayer.prototype.onDone = function(fn) {
      this._subscriptions.push(fn);
    };
    AnimationGroupPlayer.prototype.hasStarted = function() {
      return this._started;
    };
    AnimationGroupPlayer.prototype.play = function() {
      if (!lang_1.isPresent(this.parentPlayer)) {
        this.init();
      }
      this._started = true;
      this._players.forEach(function(player) {
        return player.play();
      });
    };
    AnimationGroupPlayer.prototype.pause = function() {
      this._players.forEach(function(player) {
        return player.pause();
      });
    };
    AnimationGroupPlayer.prototype.restart = function() {
      this._players.forEach(function(player) {
        return player.restart();
      });
    };
    AnimationGroupPlayer.prototype.finish = function() {
      this._onFinish();
      this._players.forEach(function(player) {
        return player.finish();
      });
    };
    AnimationGroupPlayer.prototype.destroy = function() {
      this._onFinish();
      this._players.forEach(function(player) {
        return player.destroy();
      });
    };
    AnimationGroupPlayer.prototype.reset = function() {
      this._players.forEach(function(player) {
        return player.reset();
      });
    };
    AnimationGroupPlayer.prototype.setPosition = function(p) {
      this._players.forEach(function(player) {
        player.setPosition(p);
      });
    };
    AnimationGroupPlayer.prototype.getPosition = function() {
      var min = 0;
      this._players.forEach(function(player) {
        var p = player.getPosition();
        min = math_1.Math.min(p, min);
      });
      return min;
    };
    return AnimationGroupPlayer;
  }());
  exports.AnimationGroupPlayer = AnimationGroupPlayer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/view_animation_map.js", ["../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var ViewAnimationMap = (function() {
    function ViewAnimationMap() {
      this._map = new collection_1.Map();
      this._allPlayers = [];
    }
    Object.defineProperty(ViewAnimationMap.prototype, "length", {
      get: function() {
        return this.getAllPlayers().length;
      },
      enumerable: true,
      configurable: true
    });
    ViewAnimationMap.prototype.find = function(element, animationName) {
      var playersByAnimation = this._map.get(element);
      if (lang_1.isPresent(playersByAnimation)) {
        return playersByAnimation[animationName];
      }
    };
    ViewAnimationMap.prototype.findAllPlayersByElement = function(element) {
      var el = this._map.get(element);
      return el ? collection_1.StringMapWrapper.values(el) : [];
    };
    ViewAnimationMap.prototype.set = function(element, animationName, player) {
      var playersByAnimation = this._map.get(element);
      if (!lang_1.isPresent(playersByAnimation)) {
        playersByAnimation = {};
      }
      var existingEntry = playersByAnimation[animationName];
      if (lang_1.isPresent(existingEntry)) {
        this.remove(element, animationName);
      }
      playersByAnimation[animationName] = player;
      this._allPlayers.push(player);
      this._map.set(element, playersByAnimation);
    };
    ViewAnimationMap.prototype.getAllPlayers = function() {
      return this._allPlayers;
    };
    ViewAnimationMap.prototype.remove = function(element, animationName) {
      var playersByAnimation = this._map.get(element);
      if (lang_1.isPresent(playersByAnimation)) {
        var player = playersByAnimation[animationName];
        delete playersByAnimation[animationName];
        var index = this._allPlayers.indexOf(player);
        collection_1.ListWrapper.removeAt(this._allPlayers, index);
        if (collection_1.StringMapWrapper.isEmpty(playersByAnimation)) {
          this._map.delete(element);
        }
      }
    };
    return ViewAnimationMap;
  }());
  exports.ViewAnimationMap = ViewAnimationMap;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/debug_context.js", ["../facade/collection", "../facade/lang", "./view_type"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var view_type_1 = $__require('./view_type');
  var StaticNodeDebugInfo = (function() {
    function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
      this.providerTokens = providerTokens;
      this.componentToken = componentToken;
      this.refTokens = refTokens;
    }
    return StaticNodeDebugInfo;
  }());
  exports.StaticNodeDebugInfo = StaticNodeDebugInfo;
  var DebugContext = (function() {
    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
      this._view = _view;
      this._nodeIndex = _nodeIndex;
      this._tplRow = _tplRow;
      this._tplCol = _tplCol;
    }
    Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
      get: function() {
        return lang_1.isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "context", {
      get: function() {
        return this._view.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "component", {
      get: function() {
        var staticNodeInfo = this._staticNodeInfo;
        if (lang_1.isPresent(staticNodeInfo) && lang_1.isPresent(staticNodeInfo.componentToken)) {
          return this.injector.get(staticNodeInfo.componentToken);
        }
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
      get: function() {
        var componentView = this._view;
        while (lang_1.isPresent(componentView.declarationAppElement) && componentView.type !== view_type_1.ViewType.COMPONENT) {
          componentView = componentView.declarationAppElement.parentView;
        }
        return lang_1.isPresent(componentView.declarationAppElement) ? componentView.declarationAppElement.nativeElement : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "injector", {
      get: function() {
        return this._view.injector(this._nodeIndex);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "renderNode", {
      get: function() {
        if (lang_1.isPresent(this._nodeIndex) && this._view.allNodes) {
          return this._view.allNodes[this._nodeIndex];
        } else {
          return null;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "providerTokens", {
      get: function() {
        var staticNodeInfo = this._staticNodeInfo;
        return lang_1.isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "source", {
      get: function() {
        return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "references", {
      get: function() {
        var _this = this;
        var varValues = {};
        var staticNodeInfo = this._staticNodeInfo;
        if (lang_1.isPresent(staticNodeInfo)) {
          var refs = staticNodeInfo.refTokens;
          collection_1.StringMapWrapper.forEach(refs, function(refToken, refName) {
            var varValue;
            if (lang_1.isBlank(refToken)) {
              varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
            } else {
              varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
            }
            varValues[refName] = varValue;
          });
        }
        return varValues;
      },
      enumerable: true,
      configurable: true
    });
    return DebugContext;
  }());
  exports.DebugContext = DebugContext;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/element_injector.js", ["../di/injector"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var injector_1 = $__require('../di/injector');
  var _UNDEFINED = new Object();
  var ElementInjector = (function(_super) {
    __extends(ElementInjector, _super);
    function ElementInjector(_view, _nodeIndex) {
      _super.call(this);
      this._view = _view;
      this._nodeIndex = _nodeIndex;
    }
    ElementInjector.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = injector_1.THROW_IF_NOT_FOUND;
      }
      var result = _UNDEFINED;
      if (result === _UNDEFINED) {
        result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
      }
      if (result === _UNDEFINED) {
        result = this._view.parentInjector.get(token, notFoundValue);
      }
      return result;
    };
    return ElementInjector;
  }(injector_1.Injector));
  exports.ElementInjector = ElementInjector;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/view_ref.js", ["../change_detection/constants", "../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var constants_1 = $__require('../change_detection/constants');
  var exceptions_1 = $__require('../facade/exceptions');
  var ViewRef = (function() {
    function ViewRef() {}
    Object.defineProperty(ViewRef.prototype, "destroyed", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return ViewRef;
  }());
  exports.ViewRef = ViewRef;
  var EmbeddedViewRef = (function(_super) {
    __extends(EmbeddedViewRef, _super);
    function EmbeddedViewRef() {
      _super.apply(this, arguments);
    }
    Object.defineProperty(EmbeddedViewRef.prototype, "context", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return EmbeddedViewRef;
  }(ViewRef));
  exports.EmbeddedViewRef = EmbeddedViewRef;
  var ViewRef_ = (function() {
    function ViewRef_(_view) {
      this._view = _view;
      this._view = _view;
      this._originalMode = this._view.cdMode;
    }
    Object.defineProperty(ViewRef_.prototype, "internalView", {
      get: function() {
        return this._view;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
      get: function() {
        return this._view.flatRootNodes;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "context", {
      get: function() {
        return this._view.context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "destroyed", {
      get: function() {
        return this._view.destroyed;
      },
      enumerable: true,
      configurable: true
    });
    ViewRef_.prototype.markForCheck = function() {
      this._view.markPathToRootAsCheckOnce();
    };
    ViewRef_.prototype.detach = function() {
      this._view.cdMode = constants_1.ChangeDetectorStatus.Detached;
    };
    ViewRef_.prototype.detectChanges = function() {
      this._view.detectChanges(false);
    };
    ViewRef_.prototype.checkNoChanges = function() {
      this._view.detectChanges(true);
    };
    ViewRef_.prototype.reattach = function() {
      this._view.cdMode = this._originalMode;
      this.markForCheck();
    };
    ViewRef_.prototype.onDestroy = function(callback) {
      this._view.disposables.push(callback);
    };
    ViewRef_.prototype.destroy = function() {
      this._view.destroy();
    };
    return ViewRef_;
  }());
  exports.ViewRef_ = ViewRef_;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/view.js", ["../animation/animation_group_player", "../animation/view_animation_map", "../change_detection/change_detection", "../facade/collection", "../facade/lang", "../profile/profile", "./debug_context", "./element", "./element_injector", "./exceptions", "./view_ref", "./view_type", "./view_utils"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var animation_group_player_1 = $__require('../animation/animation_group_player');
  var view_animation_map_1 = $__require('../animation/view_animation_map');
  var change_detection_1 = $__require('../change_detection/change_detection');
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var profile_1 = $__require('../profile/profile');
  var debug_context_1 = $__require('./debug_context');
  var element_1 = $__require('./element');
  var element_injector_1 = $__require('./element_injector');
  var exceptions_1 = $__require('./exceptions');
  var view_ref_1 = $__require('./view_ref');
  var view_type_1 = $__require('./view_type');
  var view_utils_1 = $__require('./view_utils');
  var _scope_check = profile_1.wtfCreateScope("AppView#check(ascii id)");
  var AppView = (function() {
    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
      this.clazz = clazz;
      this.componentType = componentType;
      this.type = type;
      this.viewUtils = viewUtils;
      this.parentInjector = parentInjector;
      this.declarationAppElement = declarationAppElement;
      this.cdMode = cdMode;
      this.contentChildren = [];
      this.viewChildren = [];
      this.viewContainerElement = null;
      this.numberOfChecks = 0;
      this.animationPlayers = new view_animation_map_1.ViewAnimationMap();
      this.ref = new view_ref_1.ViewRef_(this);
      if (type === view_type_1.ViewType.COMPONENT || type === view_type_1.ViewType.HOST) {
        this.renderer = viewUtils.renderComponent(componentType);
      } else {
        this.renderer = declarationAppElement.parentView.renderer;
      }
    }
    Object.defineProperty(AppView.prototype, "destroyed", {
      get: function() {
        return this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed;
      },
      enumerable: true,
      configurable: true
    });
    AppView.prototype.cancelActiveAnimation = function(element, animationName, removeAllAnimations) {
      if (removeAllAnimations === void 0) {
        removeAllAnimations = false;
      }
      if (removeAllAnimations) {
        this.animationPlayers.findAllPlayersByElement(element).forEach(function(player) {
          return player.destroy();
        });
      } else {
        var player = this.animationPlayers.find(element, animationName);
        if (lang_1.isPresent(player)) {
          player.destroy();
        }
      }
    };
    AppView.prototype.queueAnimation = function(element, animationName, player) {
      var _this = this;
      this.animationPlayers.set(element, animationName, player);
      player.onDone(function() {
        _this.animationPlayers.remove(element, animationName);
      });
    };
    AppView.prototype.triggerQueuedAnimations = function() {
      this.animationPlayers.getAllPlayers().forEach(function(player) {
        if (!player.hasStarted()) {
          player.play();
        }
      });
    };
    AppView.prototype.create = function(context, givenProjectableNodes, rootSelectorOrNode) {
      this.context = context;
      var projectableNodes;
      switch (this.type) {
        case view_type_1.ViewType.COMPONENT:
          projectableNodes = view_utils_1.ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
          break;
        case view_type_1.ViewType.EMBEDDED:
          projectableNodes = this.declarationAppElement.parentView.projectableNodes;
          break;
        case view_type_1.ViewType.HOST:
          projectableNodes = givenProjectableNodes;
          break;
      }
      this._hasExternalHostElement = lang_1.isPresent(rootSelectorOrNode);
      this.projectableNodes = projectableNodes;
      return this.createInternal(rootSelectorOrNode);
    };
    AppView.prototype.createInternal = function(rootSelectorOrNode) {
      return null;
    };
    AppView.prototype.init = function(rootNodesOrAppElements, allNodes, disposables, subscriptions) {
      this.rootNodesOrAppElements = rootNodesOrAppElements;
      this.allNodes = allNodes;
      this.disposables = disposables;
      this.subscriptions = subscriptions;
      if (this.type === view_type_1.ViewType.COMPONENT) {
        this.declarationAppElement.parentView.viewChildren.push(this);
        this.dirtyParentQueriesInternal();
      }
    };
    AppView.prototype.selectOrCreateHostElement = function(elementName, rootSelectorOrNode, debugInfo) {
      var hostElement;
      if (lang_1.isPresent(rootSelectorOrNode)) {
        hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
      } else {
        hostElement = this.renderer.createElement(null, elementName, debugInfo);
      }
      return hostElement;
    };
    AppView.prototype.injectorGet = function(token, nodeIndex, notFoundResult) {
      return this.injectorGetInternal(token, nodeIndex, notFoundResult);
    };
    AppView.prototype.injectorGetInternal = function(token, nodeIndex, notFoundResult) {
      return notFoundResult;
    };
    AppView.prototype.injector = function(nodeIndex) {
      if (lang_1.isPresent(nodeIndex)) {
        return new element_injector_1.ElementInjector(this, nodeIndex);
      } else {
        return this.parentInjector;
      }
    };
    AppView.prototype.destroy = function() {
      if (this._hasExternalHostElement) {
        this.renderer.detachView(this.flatRootNodes);
      } else if (lang_1.isPresent(this.viewContainerElement)) {
        this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
      }
      this._destroyRecurse();
    };
    AppView.prototype._destroyRecurse = function() {
      if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
        return;
      }
      var children = this.contentChildren;
      for (var i = 0; i < children.length; i++) {
        children[i]._destroyRecurse();
      }
      children = this.viewChildren;
      for (var i = 0; i < children.length; i++) {
        children[i]._destroyRecurse();
      }
      this.destroyLocal();
      this.cdMode = change_detection_1.ChangeDetectorStatus.Destroyed;
    };
    AppView.prototype.destroyLocal = function() {
      var _this = this;
      var hostElement = this.type === view_type_1.ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
      for (var i = 0; i < this.disposables.length; i++) {
        this.disposables[i]();
      }
      for (var i = 0; i < this.subscriptions.length; i++) {
        this.subscriptions[i].unsubscribe();
      }
      this.destroyInternal();
      this.dirtyParentQueriesInternal();
      if (this.animationPlayers.length == 0) {
        this.renderer.destroyView(hostElement, this.allNodes);
      } else {
        var player = new animation_group_player_1.AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
        player.onDone(function() {
          _this.renderer.destroyView(hostElement, _this.allNodes);
        });
      }
    };
    AppView.prototype.destroyInternal = function() {};
    AppView.prototype.detachInternal = function() {};
    AppView.prototype.detach = function() {
      var _this = this;
      this.detachInternal();
      if (this.animationPlayers.length == 0) {
        this.renderer.detachView(this.flatRootNodes);
      } else {
        var player = new animation_group_player_1.AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
        player.onDone(function() {
          _this.renderer.detachView(_this.flatRootNodes);
        });
      }
    };
    Object.defineProperty(AppView.prototype, "changeDetectorRef", {
      get: function() {
        return this.ref;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "parent", {
      get: function() {
        return lang_1.isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "flatRootNodes", {
      get: function() {
        return view_utils_1.flattenNestedViewRenderNodes(this.rootNodesOrAppElements);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppView.prototype, "lastRootNode", {
      get: function() {
        var lastNode = this.rootNodesOrAppElements.length > 0 ? this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] : null;
        return _findLastRenderNode(lastNode);
      },
      enumerable: true,
      configurable: true
    });
    AppView.prototype.dirtyParentQueriesInternal = function() {};
    AppView.prototype.detectChanges = function(throwOnChange) {
      var s = _scope_check(this.clazz);
      if (this.cdMode === change_detection_1.ChangeDetectorStatus.Checked || this.cdMode === change_detection_1.ChangeDetectorStatus.Errored)
        return;
      if (this.cdMode === change_detection_1.ChangeDetectorStatus.Destroyed) {
        this.throwDestroyedError('detectChanges');
      }
      this.detectChangesInternal(throwOnChange);
      if (this.cdMode === change_detection_1.ChangeDetectorStatus.CheckOnce)
        this.cdMode = change_detection_1.ChangeDetectorStatus.Checked;
      this.numberOfChecks++;
      profile_1.wtfLeave(s);
    };
    AppView.prototype.detectChangesInternal = function(throwOnChange) {
      this.detectContentChildrenChanges(throwOnChange);
      this.detectViewChildrenChanges(throwOnChange);
    };
    AppView.prototype.detectContentChildrenChanges = function(throwOnChange) {
      for (var i = 0; i < this.contentChildren.length; ++i) {
        var child = this.contentChildren[i];
        if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
          continue;
        child.detectChanges(throwOnChange);
      }
    };
    AppView.prototype.detectViewChildrenChanges = function(throwOnChange) {
      for (var i = 0; i < this.viewChildren.length; ++i) {
        var child = this.viewChildren[i];
        if (child.cdMode === change_detection_1.ChangeDetectorStatus.Detached)
          continue;
        child.detectChanges(throwOnChange);
      }
    };
    AppView.prototype.markContentChildAsMoved = function(renderAppElement) {
      this.dirtyParentQueriesInternal();
    };
    AppView.prototype.addToContentChildren = function(renderAppElement) {
      renderAppElement.parentView.contentChildren.push(this);
      this.viewContainerElement = renderAppElement;
      this.dirtyParentQueriesInternal();
    };
    AppView.prototype.removeFromContentChildren = function(renderAppElement) {
      collection_1.ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
      this.dirtyParentQueriesInternal();
      this.viewContainerElement = null;
    };
    AppView.prototype.markAsCheckOnce = function() {
      this.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce;
    };
    AppView.prototype.markPathToRootAsCheckOnce = function() {
      var c = this;
      while (lang_1.isPresent(c) && c.cdMode !== change_detection_1.ChangeDetectorStatus.Detached) {
        if (c.cdMode === change_detection_1.ChangeDetectorStatus.Checked) {
          c.cdMode = change_detection_1.ChangeDetectorStatus.CheckOnce;
        }
        var parentEl = c.type === view_type_1.ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
        c = lang_1.isPresent(parentEl) ? parentEl.parentView : null;
      }
    };
    AppView.prototype.eventHandler = function(cb) {
      return cb;
    };
    AppView.prototype.throwDestroyedError = function(details) {
      throw new exceptions_1.ViewDestroyedException(details);
    };
    return AppView;
  }());
  exports.AppView = AppView;
  var DebugAppView = (function(_super) {
    __extends(DebugAppView, _super);
    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
      _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
      this.staticNodeDebugInfos = staticNodeDebugInfos;
      this._currentDebugContext = null;
    }
    DebugAppView.prototype.create = function(context, givenProjectableNodes, rootSelectorOrNode) {
      this._resetDebug();
      try {
        return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.injectorGet = function(token, nodeIndex, notFoundResult) {
      this._resetDebug();
      try {
        return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.detach = function() {
      this._resetDebug();
      try {
        _super.prototype.detach.call(this);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.destroyLocal = function() {
      this._resetDebug();
      try {
        _super.prototype.destroyLocal.call(this);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype.detectChanges = function(throwOnChange) {
      this._resetDebug();
      try {
        _super.prototype.detectChanges.call(this, throwOnChange);
      } catch (e) {
        this._rethrowWithContext(e, e.stack);
        throw e;
      }
    };
    DebugAppView.prototype._resetDebug = function() {
      this._currentDebugContext = null;
    };
    DebugAppView.prototype.debug = function(nodeIndex, rowNum, colNum) {
      return this._currentDebugContext = new debug_context_1.DebugContext(this, nodeIndex, rowNum, colNum);
    };
    DebugAppView.prototype._rethrowWithContext = function(e, stack) {
      if (!(e instanceof exceptions_1.ViewWrappedException)) {
        if (!(e instanceof exceptions_1.ExpressionChangedAfterItHasBeenCheckedException)) {
          this.cdMode = change_detection_1.ChangeDetectorStatus.Errored;
        }
        if (lang_1.isPresent(this._currentDebugContext)) {
          throw new exceptions_1.ViewWrappedException(e, stack, this._currentDebugContext);
        }
      }
    };
    DebugAppView.prototype.eventHandler = function(cb) {
      var _this = this;
      var superHandler = _super.prototype.eventHandler.call(this, cb);
      return function(event) {
        _this._resetDebug();
        try {
          return superHandler(event);
        } catch (e) {
          _this._rethrowWithContext(e, e.stack);
          throw e;
        }
      };
    };
    return DebugAppView;
  }(AppView));
  exports.DebugAppView = DebugAppView;
  function _findLastRenderNode(node) {
    var lastNode;
    if (node instanceof element_1.AppElement) {
      var appEl = node;
      lastNode = appEl.nativeElement;
      if (lang_1.isPresent(appEl.nestedViews)) {
        for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
          var nestedView = appEl.nestedViews[i];
          if (nestedView.rootNodesOrAppElements.length > 0) {
            lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
          }
        }
      }
    } else {
      lastNode = node;
    }
    return lastNode;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/application_tokens.js", ["../src/facade/lang", "./di"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../src/facade/lang');
  var di_1 = $__require('./di');
  exports.APP_ID = new di_1.OpaqueToken('AppId');
  function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
  }
  exports._appIdRandomProviderFactory = _appIdRandomProviderFactory;
  exports.APP_ID_RANDOM_PROVIDER = {
    provide: exports.APP_ID,
    useFactory: _appIdRandomProviderFactory,
    deps: []
  };
  function _randomChar() {
    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
  }
  exports.PLATFORM_INITIALIZER = new di_1.OpaqueToken('Platform Initializer');
  exports.APP_BOOTSTRAP_LISTENER = new di_1.OpaqueToken('appBootstrapListener');
  exports.PACKAGE_ROOT_URL = new di_1.OpaqueToken('Application Packages Root URL');
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/differs/default_iterable_differ.js", ["../../facade/collection", "../../facade/exceptions", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var DefaultIterableDifferFactory = (function() {
    function DefaultIterableDifferFactory() {}
    DefaultIterableDifferFactory.prototype.supports = function(obj) {
      return collection_1.isListLikeIterable(obj);
    };
    DefaultIterableDifferFactory.prototype.create = function(cdRef, trackByFn) {
      return new DefaultIterableDiffer(trackByFn);
    };
    return DefaultIterableDifferFactory;
  }());
  exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
  var trackByIdentity = function(index, item) {
    return item;
  };
  var DefaultIterableDiffer = (function() {
    function DefaultIterableDiffer(_trackByFn) {
      this._trackByFn = _trackByFn;
      this._length = null;
      this._collection = null;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = lang_1.isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
      get: function() {
        return this._collection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachOperation = function(fn) {
      var nextIt = this._itHead;
      var nextRemove = this._removalsHead;
      var addRemoveOffset = 0;
      var moveOffsets = null;
      while (nextIt || nextRemove) {
        var record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
        var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
        var currentIndex = record.currentIndex;
        if (record === nextRemove) {
          addRemoveOffset--;
          nextRemove = nextRemove._nextRemoved;
        } else {
          nextIt = nextIt._next;
          if (record.previousIndex == null) {
            addRemoveOffset++;
          } else {
            if (!moveOffsets)
              moveOffsets = [];
            var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
            var localCurrentIndex = currentIndex - addRemoveOffset;
            if (localMovePreviousIndex != localCurrentIndex) {
              for (var i = 0; i < localMovePreviousIndex; i++) {
                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                var index = offset + i;
                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                  moveOffsets[i] = offset + 1;
                }
              }
              var previousIndex = record.previousIndex;
              moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
            }
          }
        }
        if (adjPreviousIndex !== currentIndex) {
          fn(record, adjPreviousIndex, currentIndex);
        }
      }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function(fn) {
      var record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.forEachIdentityChange = function(fn) {
      var record;
      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
        fn(record);
      }
    };
    DefaultIterableDiffer.prototype.diff = function(collection) {
      if (lang_1.isBlank(collection))
        collection = [];
      if (!collection_1.isListLikeIterable(collection)) {
        throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    };
    DefaultIterableDiffer.prototype.onDestroy = function() {};
    DefaultIterableDiffer.prototype.check = function(collection) {
      var _this = this;
      this._reset();
      var record = this._itHead;
      var mayBeDirty = false;
      var index;
      var item;
      var itemTrackBy;
      if (lang_1.isArray(collection)) {
        var list = collection;
        this._length = collection.length;
        for (index = 0; index < this._length; index++) {
          item = list[index];
          itemTrackBy = this._trackByFn(index, item);
          if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index);
            }
            if (!lang_1.looseIdentical(record.item, item))
              this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        collection_1.iterateListLike(collection, function(item) {
          itemTrackBy = _this._trackByFn(index, item);
          if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
            record = _this._mismatch(record, item, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = _this._verifyReinsertion(record, item, itemTrackBy, index);
            }
            if (!lang_1.looseIdentical(record.item, item))
              _this._addIdentityChange(record, item);
          }
          record = record._next;
          index++;
        });
        this._length = index;
      }
      this._truncate(record);
      this._collection = collection;
      return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultIterableDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record;
        var nextRecord;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = nextRecord) {
          record.previousIndex = record.currentIndex;
          nextRecord = record._nextMoved;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    };
    DefaultIterableDiffer.prototype._mismatch = function(record, item, itemTrackBy, index) {
      var previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!lang_1.looseIdentical(record.item, item))
          this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
        if (record !== null) {
          if (!lang_1.looseIdentical(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    };
    DefaultIterableDiffer.prototype._verifyReinsertion = function(record, item, itemTrackBy, index) {
      var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, record._prev, index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    };
    DefaultIterableDiffer.prototype._truncate = function(record) {
      while (record !== null) {
        var nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    };
    DefaultIterableDiffer.prototype._reinsertAfter = function(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      var prev = record._prevRemoved;
      var next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._moveAfter = function(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    };
    DefaultIterableDiffer.prototype._addAfter = function(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._insertAfter = function(record, prevRecord, index) {
      var next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    };
    DefaultIterableDiffer.prototype._remove = function(record) {
      return this._addToRemovals(this._unlink(record));
    };
    DefaultIterableDiffer.prototype._unlink = function(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      var prev = record._prev;
      var next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToMoves = function(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addToRemovals = function(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype._addIdentityChange = function(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    };
    DefaultIterableDiffer.prototype.toString = function() {
      var list = [];
      this.forEachItem(function(record) {
        return list.push(record);
      });
      var previous = [];
      this.forEachPreviousItem(function(record) {
        return previous.push(record);
      });
      var additions = [];
      this.forEachAddedItem(function(record) {
        return additions.push(record);
      });
      var moves = [];
      this.forEachMovedItem(function(record) {
        return moves.push(record);
      });
      var removals = [];
      this.forEachRemovedItem(function(record) {
        return removals.push(record);
      });
      var identityChanges = [];
      this.forEachIdentityChange(function(record) {
        return identityChanges.push(record);
      });
      return 'collection: ' + list.join(', ') + '\n' + 'previous: ' + previous.join(', ') + '\n' + 'additions: ' + additions.join(', ') + '\n' + 'moves: ' + moves.join(', ') + '\n' + 'removals: ' + removals.join(', ') + '\n' + 'identityChanges: ' + identityChanges.join(', ') + '\n';
    };
    return DefaultIterableDiffer;
  }());
  exports.DefaultIterableDiffer = DefaultIterableDiffer;
  var CollectionChangeRecord = (function() {
    function CollectionChangeRecord(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
    CollectionChangeRecord.prototype.toString = function() {
      return this.previousIndex === this.currentIndex ? lang_1.stringify(this.item) : lang_1.stringify(this.item) + '[' + lang_1.stringify(this.previousIndex) + '->' + lang_1.stringify(this.currentIndex) + ']';
    };
    return CollectionChangeRecord;
  }());
  exports.CollectionChangeRecord = CollectionChangeRecord;
  var _DuplicateItemRecordList = (function() {
    function _DuplicateItemRecordList() {
      this._head = null;
      this._tail = null;
    }
    _DuplicateItemRecordList.prototype.add = function(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        this._tail._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    };
    _DuplicateItemRecordList.prototype.get = function(trackById, afterIndex) {
      var record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((afterIndex === null || afterIndex < record.currentIndex) && lang_1.looseIdentical(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    };
    _DuplicateItemRecordList.prototype.remove = function(record) {
      var prev = record._prevDup;
      var next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    };
    return _DuplicateItemRecordList;
  }());
  var _DuplicateMap = (function() {
    function _DuplicateMap() {
      this.map = new Map();
    }
    _DuplicateMap.prototype.put = function(record) {
      var key = lang_1.getMapKey(record.trackById);
      var duplicates = this.map.get(key);
      if (!lang_1.isPresent(duplicates)) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    };
    _DuplicateMap.prototype.get = function(trackById, afterIndex) {
      if (afterIndex === void 0) {
        afterIndex = null;
      }
      var key = lang_1.getMapKey(trackById);
      var recordList = this.map.get(key);
      return lang_1.isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
    };
    _DuplicateMap.prototype.remove = function(record) {
      var key = lang_1.getMapKey(record.trackById);
      var recordList = this.map.get(key);
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
      get: function() {
        return this.map.size === 0;
      },
      enumerable: true,
      configurable: true
    });
    _DuplicateMap.prototype.clear = function() {
      this.map.clear();
    };
    _DuplicateMap.prototype.toString = function() {
      return '_DuplicateMap(' + lang_1.stringify(this.map) + ')';
    };
    return _DuplicateMap;
  }());
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    var previousIndex = item.previousIndex;
    if (previousIndex === null)
      return previousIndex;
    var moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
      moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ.js", ["../../facade/collection", "../../facade/exceptions", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var DefaultKeyValueDifferFactory = (function() {
    function DefaultKeyValueDifferFactory() {}
    DefaultKeyValueDifferFactory.prototype.supports = function(obj) {
      return obj instanceof Map || lang_1.isJsObject(obj);
    };
    DefaultKeyValueDifferFactory.prototype.create = function(cdRef) {
      return new DefaultKeyValueDiffer();
    };
    return DefaultKeyValueDifferFactory;
  }());
  exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
  var DefaultKeyValueDiffer = (function() {
    function DefaultKeyValueDiffer() {
      this._records = new Map();
      this._mapHead = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
      get: function() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      },
      enumerable: true,
      configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function(fn) {
      var record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function(fn) {
      var record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function(fn) {
      var record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function(fn) {
      var record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function(fn) {
      var record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    };
    DefaultKeyValueDiffer.prototype.diff = function(map) {
      if (!map) {
        map = new Map();
      } else if (!(map instanceof Map || lang_1.isJsObject(map))) {
        throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
      }
      return this.check(map) ? this : null;
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function() {};
    DefaultKeyValueDiffer.prototype.check = function(map) {
      var _this = this;
      this._reset();
      var records = this._records;
      var oldSeqRecord = this._mapHead;
      var lastOldSeqRecord = null;
      var lastNewSeqRecord = null;
      var seqChanged = false;
      this._forEach(map, function(value, key) {
        var newSeqRecord;
        if (oldSeqRecord && key === oldSeqRecord.key) {
          newSeqRecord = oldSeqRecord;
          _this._maybeAddToChanges(newSeqRecord, value);
        } else {
          seqChanged = true;
          if (oldSeqRecord !== null) {
            _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
            _this._addToRemovals(oldSeqRecord);
          }
          if (records.has(key)) {
            newSeqRecord = records.get(key);
            _this._maybeAddToChanges(newSeqRecord, value);
          } else {
            newSeqRecord = new KeyValueChangeRecord(key);
            records.set(key, newSeqRecord);
            newSeqRecord.currentValue = value;
            _this._addToAdditions(newSeqRecord);
          }
        }
        if (seqChanged) {
          if (_this._isInRemovals(newSeqRecord)) {
            _this._removeFromRemovals(newSeqRecord);
          }
          if (lastNewSeqRecord == null) {
            _this._mapHead = newSeqRecord;
          } else {
            lastNewSeqRecord._next = newSeqRecord;
          }
        }
        lastOldSeqRecord = oldSeqRecord;
        lastNewSeqRecord = newSeqRecord;
        oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
      });
      this._truncate(lastOldSeqRecord, oldSeqRecord);
      return this.isDirty;
    };
    DefaultKeyValueDiffer.prototype._reset = function() {
      if (this.isDirty) {
        var record = void 0;
        for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = this._removalsTail = null;
      }
    };
    DefaultKeyValueDiffer.prototype._truncate = function(lastRecord, record) {
      while (record !== null) {
        if (lastRecord === null) {
          this._mapHead = null;
        } else {
          lastRecord._next = null;
        }
        var nextRecord = record._next;
        this._addToRemovals(record);
        lastRecord = record;
        record = nextRecord;
      }
      for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
        rec.previousValue = rec.currentValue;
        rec.currentValue = null;
        this._records.delete(rec.key);
      }
    };
    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function(record, newValue) {
      if (!lang_1.looseIdentical(newValue, record.currentValue)) {
        record.previousValue = record.currentValue;
        record.currentValue = newValue;
        this._addToChanges(record);
      }
    };
    DefaultKeyValueDiffer.prototype._isInRemovals = function(record) {
      return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
    };
    DefaultKeyValueDiffer.prototype._addToRemovals = function(record) {
      if (this._removalsHead === null) {
        this._removalsHead = this._removalsTail = record;
      } else {
        this._removalsTail._nextRemoved = record;
        record._prevRemoved = this._removalsTail;
        this._removalsTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._removeFromSeq = function(prev, record) {
      var next = record._next;
      if (prev === null) {
        this._mapHead = next;
      } else {
        prev._next = next;
      }
      record._next = null;
    };
    DefaultKeyValueDiffer.prototype._removeFromRemovals = function(record) {
      var prev = record._prevRemoved;
      var next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      record._prevRemoved = record._nextRemoved = null;
    };
    DefaultKeyValueDiffer.prototype._addToAdditions = function(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        this._additionsTail._nextAdded = record;
        this._additionsTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype._addToChanges = function(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        this._changesTail._nextChanged = record;
        this._changesTail = record;
      }
    };
    DefaultKeyValueDiffer.prototype.toString = function() {
      var items = [];
      var previous = [];
      var changes = [];
      var additions = [];
      var removals = [];
      var record;
      for (record = this._mapHead; record !== null; record = record._next) {
        items.push(lang_1.stringify(record));
      }
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        previous.push(lang_1.stringify(record));
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        changes.push(lang_1.stringify(record));
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        additions.push(lang_1.stringify(record));
      }
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        removals.push(lang_1.stringify(record));
      }
      return 'map: ' + items.join(', ') + '\n' + 'previous: ' + previous.join(', ') + '\n' + 'additions: ' + additions.join(', ') + '\n' + 'changes: ' + changes.join(', ') + '\n' + 'removals: ' + removals.join(', ') + '\n';
    };
    DefaultKeyValueDiffer.prototype._forEach = function(obj, fn) {
      if (obj instanceof Map) {
        obj.forEach(fn);
      } else {
        collection_1.StringMapWrapper.forEach(obj, fn);
      }
    };
    return DefaultKeyValueDiffer;
  }());
  exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
  var KeyValueChangeRecord = (function() {
    function KeyValueChangeRecord(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._prevRemoved = null;
      this._nextChanged = null;
    }
    KeyValueChangeRecord.prototype.toString = function() {
      return lang_1.looseIdentical(this.previousValue, this.currentValue) ? lang_1.stringify(this.key) : (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' + lang_1.stringify(this.currentValue) + ']');
    };
    return KeyValueChangeRecord;
  }());
  exports.KeyValueChangeRecord = KeyValueChangeRecord;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/differs/iterable_differs.js", ["../../di", "../../facade/collection", "../../facade/exceptions", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var di_1 = $__require('../../di');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var IterableDiffers = (function() {
    function IterableDiffers(factories) {
      this.factories = factories;
    }
    IterableDiffers.create = function(factories, parent) {
      if (lang_1.isPresent(parent)) {
        var copied = collection_1.ListWrapper.clone(parent.factories);
        factories = factories.concat(copied);
        return new IterableDiffers(factories);
      } else {
        return new IterableDiffers(factories);
      }
    };
    IterableDiffers.extend = function(factories) {
      return new di_1.Provider(IterableDiffers, {
        useFactory: function(parent) {
          if (lang_1.isBlank(parent)) {
            throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
          }
          return IterableDiffers.create(factories, parent);
        },
        deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
      });
    };
    IterableDiffers.prototype.find = function(iterable) {
      var factory = this.factories.find(function(f) {
        return f.supports(iterable);
      });
      if (lang_1.isPresent(factory)) {
        return factory;
      } else {
        throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "' of type '" + lang_1.getTypeNameForDebugging(iterable) + "'");
      }
    };
    return IterableDiffers;
  }());
  exports.IterableDiffers = IterableDiffers;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/injector.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var _THROW_IF_NOT_FOUND = new Object();
  exports.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var _NullInjector = (function() {
    function _NullInjector() {}
    _NullInjector.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = _THROW_IF_NOT_FOUND;
      }
      if (notFoundValue === _THROW_IF_NOT_FOUND) {
        throw new exceptions_1.BaseException("No provider for " + lang_1.stringify(token) + "!");
      }
      return notFoundValue;
    };
    return _NullInjector;
  }());
  var Injector = (function() {
    function Injector() {}
    Injector.prototype.get = function(token, notFoundValue) {
      return exceptions_1.unimplemented();
    };
    Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    Injector.NULL = new _NullInjector();
    return Injector;
  }());
  exports.Injector = Injector;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/reflective_injector.js", ["../facade/collection", "../facade/exceptions", "./injector", "./metadata", "./reflective_exceptions", "./reflective_key", "./reflective_provider"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var injector_1 = $__require('./injector');
  var metadata_1 = $__require('./metadata');
  var reflective_exceptions_1 = $__require('./reflective_exceptions');
  var reflective_key_1 = $__require('./reflective_key');
  var reflective_provider_1 = $__require('./reflective_provider');
  var __unused;
  var _MAX_CONSTRUCTION_COUNTER = 10;
  var UNDEFINED = new Object();
  var ReflectiveProtoInjectorInlineStrategy = (function() {
    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
      this.provider0 = null;
      this.provider1 = null;
      this.provider2 = null;
      this.provider3 = null;
      this.provider4 = null;
      this.provider5 = null;
      this.provider6 = null;
      this.provider7 = null;
      this.provider8 = null;
      this.provider9 = null;
      this.keyId0 = null;
      this.keyId1 = null;
      this.keyId2 = null;
      this.keyId3 = null;
      this.keyId4 = null;
      this.keyId5 = null;
      this.keyId6 = null;
      this.keyId7 = null;
      this.keyId8 = null;
      this.keyId9 = null;
      var length = providers.length;
      if (length > 0) {
        this.provider0 = providers[0];
        this.keyId0 = providers[0].key.id;
      }
      if (length > 1) {
        this.provider1 = providers[1];
        this.keyId1 = providers[1].key.id;
      }
      if (length > 2) {
        this.provider2 = providers[2];
        this.keyId2 = providers[2].key.id;
      }
      if (length > 3) {
        this.provider3 = providers[3];
        this.keyId3 = providers[3].key.id;
      }
      if (length > 4) {
        this.provider4 = providers[4];
        this.keyId4 = providers[4].key.id;
      }
      if (length > 5) {
        this.provider5 = providers[5];
        this.keyId5 = providers[5].key.id;
      }
      if (length > 6) {
        this.provider6 = providers[6];
        this.keyId6 = providers[6].key.id;
      }
      if (length > 7) {
        this.provider7 = providers[7];
        this.keyId7 = providers[7].key.id;
      }
      if (length > 8) {
        this.provider8 = providers[8];
        this.keyId8 = providers[8].key.id;
      }
      if (length > 9) {
        this.provider9 = providers[9];
        this.keyId9 = providers[9].key.id;
      }
    }
    ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function(index) {
      if (index == 0)
        return this.provider0;
      if (index == 1)
        return this.provider1;
      if (index == 2)
        return this.provider2;
      if (index == 3)
        return this.provider3;
      if (index == 4)
        return this.provider4;
      if (index == 5)
        return this.provider5;
      if (index == 6)
        return this.provider6;
      if (index == 7)
        return this.provider7;
      if (index == 8)
        return this.provider8;
      if (index == 9)
        return this.provider9;
      throw new reflective_exceptions_1.OutOfBoundsError(index);
    };
    ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function(injector) {
      return new ReflectiveInjectorInlineStrategy(injector, this);
    };
    return ReflectiveProtoInjectorInlineStrategy;
  }());
  exports.ReflectiveProtoInjectorInlineStrategy = ReflectiveProtoInjectorInlineStrategy;
  var ReflectiveProtoInjectorDynamicStrategy = (function() {
    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
      this.providers = providers;
      var len = providers.length;
      this.keyIds = collection_1.ListWrapper.createFixedSize(len);
      for (var i = 0; i < len; i++) {
        this.keyIds[i] = providers[i].key.id;
      }
    }
    ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function(index) {
      if (index < 0 || index >= this.providers.length) {
        throw new reflective_exceptions_1.OutOfBoundsError(index);
      }
      return this.providers[index];
    };
    ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function(ei) {
      return new ReflectiveInjectorDynamicStrategy(this, ei);
    };
    return ReflectiveProtoInjectorDynamicStrategy;
  }());
  exports.ReflectiveProtoInjectorDynamicStrategy = ReflectiveProtoInjectorDynamicStrategy;
  var ReflectiveProtoInjector = (function() {
    function ReflectiveProtoInjector(providers) {
      this.numberOfProviders = providers.length;
      this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ? new ReflectiveProtoInjectorDynamicStrategy(this, providers) : new ReflectiveProtoInjectorInlineStrategy(this, providers);
    }
    ReflectiveProtoInjector.fromResolvedProviders = function(providers) {
      return new ReflectiveProtoInjector(providers);
    };
    ReflectiveProtoInjector.prototype.getProviderAtIndex = function(index) {
      return this._strategy.getProviderAtIndex(index);
    };
    return ReflectiveProtoInjector;
  }());
  exports.ReflectiveProtoInjector = ReflectiveProtoInjector;
  var ReflectiveInjectorInlineStrategy = (function() {
    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
      this.injector = injector;
      this.protoStrategy = protoStrategy;
      this.obj0 = UNDEFINED;
      this.obj1 = UNDEFINED;
      this.obj2 = UNDEFINED;
      this.obj3 = UNDEFINED;
      this.obj4 = UNDEFINED;
      this.obj5 = UNDEFINED;
      this.obj6 = UNDEFINED;
      this.obj7 = UNDEFINED;
      this.obj8 = UNDEFINED;
      this.obj9 = UNDEFINED;
    }
    ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function() {
      this.injector._constructionCounter = 0;
    };
    ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function(provider) {
      return this.injector._new(provider);
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function(keyId) {
      var p = this.protoStrategy;
      var inj = this.injector;
      if (p.keyId0 === keyId) {
        if (this.obj0 === UNDEFINED) {
          this.obj0 = inj._new(p.provider0);
        }
        return this.obj0;
      }
      if (p.keyId1 === keyId) {
        if (this.obj1 === UNDEFINED) {
          this.obj1 = inj._new(p.provider1);
        }
        return this.obj1;
      }
      if (p.keyId2 === keyId) {
        if (this.obj2 === UNDEFINED) {
          this.obj2 = inj._new(p.provider2);
        }
        return this.obj2;
      }
      if (p.keyId3 === keyId) {
        if (this.obj3 === UNDEFINED) {
          this.obj3 = inj._new(p.provider3);
        }
        return this.obj3;
      }
      if (p.keyId4 === keyId) {
        if (this.obj4 === UNDEFINED) {
          this.obj4 = inj._new(p.provider4);
        }
        return this.obj4;
      }
      if (p.keyId5 === keyId) {
        if (this.obj5 === UNDEFINED) {
          this.obj5 = inj._new(p.provider5);
        }
        return this.obj5;
      }
      if (p.keyId6 === keyId) {
        if (this.obj6 === UNDEFINED) {
          this.obj6 = inj._new(p.provider6);
        }
        return this.obj6;
      }
      if (p.keyId7 === keyId) {
        if (this.obj7 === UNDEFINED) {
          this.obj7 = inj._new(p.provider7);
        }
        return this.obj7;
      }
      if (p.keyId8 === keyId) {
        if (this.obj8 === UNDEFINED) {
          this.obj8 = inj._new(p.provider8);
        }
        return this.obj8;
      }
      if (p.keyId9 === keyId) {
        if (this.obj9 === UNDEFINED) {
          this.obj9 = inj._new(p.provider9);
        }
        return this.obj9;
      }
      return UNDEFINED;
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function(index) {
      if (index == 0)
        return this.obj0;
      if (index == 1)
        return this.obj1;
      if (index == 2)
        return this.obj2;
      if (index == 3)
        return this.obj3;
      if (index == 4)
        return this.obj4;
      if (index == 5)
        return this.obj5;
      if (index == 6)
        return this.obj6;
      if (index == 7)
        return this.obj7;
      if (index == 8)
        return this.obj8;
      if (index == 9)
        return this.obj9;
      throw new reflective_exceptions_1.OutOfBoundsError(index);
    };
    ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function() {
      return _MAX_CONSTRUCTION_COUNTER;
    };
    return ReflectiveInjectorInlineStrategy;
  }());
  exports.ReflectiveInjectorInlineStrategy = ReflectiveInjectorInlineStrategy;
  var ReflectiveInjectorDynamicStrategy = (function() {
    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
      this.protoStrategy = protoStrategy;
      this.injector = injector;
      this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
      collection_1.ListWrapper.fill(this.objs, UNDEFINED);
    }
    ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function() {
      this.injector._constructionCounter = 0;
    };
    ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function(provider) {
      return this.injector._new(provider);
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function(keyId) {
      var p = this.protoStrategy;
      for (var i = 0; i < p.keyIds.length; i++) {
        if (p.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this.injector._new(p.providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function(index) {
      if (index < 0 || index >= this.objs.length) {
        throw new reflective_exceptions_1.OutOfBoundsError(index);
      }
      return this.objs[index];
    };
    ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function() {
      return this.objs.length;
    };
    return ReflectiveInjectorDynamicStrategy;
  }());
  exports.ReflectiveInjectorDynamicStrategy = ReflectiveInjectorDynamicStrategy;
  var ReflectiveInjector = (function() {
    function ReflectiveInjector() {}
    ReflectiveInjector.resolve = function(providers) {
      return reflective_provider_1.resolveReflectiveProviders(providers);
    };
    ReflectiveInjector.resolveAndCreate = function(providers, parent) {
      if (parent === void 0) {
        parent = null;
      }
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    };
    ReflectiveInjector.fromResolvedProviders = function(providers, parent) {
      if (parent === void 0) {
        parent = null;
      }
      return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
    };
    ReflectiveInjector.fromResolvedBindings = function(providers) {
      return ReflectiveInjector.fromResolvedProviders(providers);
    };
    Object.defineProperty(ReflectiveInjector.prototype, "parent", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector.prototype.debugContext = function() {
      return null;
    };
    ReflectiveInjector.prototype.resolveAndCreateChild = function(providers) {
      return exceptions_1.unimplemented();
    };
    ReflectiveInjector.prototype.createChildFromResolved = function(providers) {
      return exceptions_1.unimplemented();
    };
    ReflectiveInjector.prototype.resolveAndInstantiate = function(provider) {
      return exceptions_1.unimplemented();
    };
    ReflectiveInjector.prototype.instantiateResolved = function(provider) {
      return exceptions_1.unimplemented();
    };
    return ReflectiveInjector;
  }());
  exports.ReflectiveInjector = ReflectiveInjector;
  var ReflectiveInjector_ = (function() {
    function ReflectiveInjector_(_proto, _parent, _debugContext) {
      if (_parent === void 0) {
        _parent = null;
      }
      if (_debugContext === void 0) {
        _debugContext = null;
      }
      this._debugContext = _debugContext;
      this._constructionCounter = 0;
      this._proto = _proto;
      this._parent = _parent;
      this._strategy = _proto._strategy.createInjectorStrategy(this);
    }
    ReflectiveInjector_.prototype.debugContext = function() {
      return this._debugContext();
    };
    ReflectiveInjector_.prototype.get = function(token, notFoundValue) {
      if (notFoundValue === void 0) {
        notFoundValue = injector_1.THROW_IF_NOT_FOUND;
      }
      return this._getByKey(reflective_key_1.ReflectiveKey.get(token), null, null, notFoundValue);
    };
    ReflectiveInjector_.prototype.getAt = function(index) {
      return this._strategy.getObjAtIndex(index);
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
      get: function() {
        return this._parent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
      get: function() {
        return this._strategy;
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.resolveAndCreateChild = function(providers) {
      var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    };
    ReflectiveInjector_.prototype.createChildFromResolved = function(providers) {
      var proto = new ReflectiveProtoInjector(providers);
      var inj = new ReflectiveInjector_(proto);
      inj._parent = this;
      return inj;
    };
    ReflectiveInjector_.prototype.resolveAndInstantiate = function(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    };
    ReflectiveInjector_.prototype.instantiateResolved = function(provider) {
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._new = function(provider) {
      if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
        throw new reflective_exceptions_1.CyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._instantiateProvider = function(provider) {
      if (provider.multiProvider) {
        var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
        for (var i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    };
    ReflectiveInjector_.prototype._instantiate = function(provider, ResolvedReflectiveFactory) {
      var factory = ResolvedReflectiveFactory.factory;
      var deps = ResolvedReflectiveFactory.dependencies;
      var length = deps.length;
      var d0;
      var d1;
      var d2;
      var d3;
      var d4;
      var d5;
      var d6;
      var d7;
      var d8;
      var d9;
      var d10;
      var d11;
      var d12;
      var d13;
      var d14;
      var d15;
      var d16;
      var d17;
      var d18;
      var d19;
      try {
        d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
        d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
        d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
        d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
        d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
        d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
        d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
        d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
        d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
        d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
        d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
        d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
        d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
        d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
        d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
        d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
        d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
        d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
        d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
        d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
      } catch (e) {
        if (e instanceof reflective_exceptions_1.AbstractProviderError || e instanceof reflective_exceptions_1.InstantiationError) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      var obj;
      try {
        switch (length) {
          case 0:
            obj = factory();
            break;
          case 1:
            obj = factory(d0);
            break;
          case 2:
            obj = factory(d0, d1);
            break;
          case 3:
            obj = factory(d0, d1, d2);
            break;
          case 4:
            obj = factory(d0, d1, d2, d3);
            break;
          case 5:
            obj = factory(d0, d1, d2, d3, d4);
            break;
          case 6:
            obj = factory(d0, d1, d2, d3, d4, d5);
            break;
          case 7:
            obj = factory(d0, d1, d2, d3, d4, d5, d6);
            break;
          case 8:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
            break;
          case 9:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
            break;
          case 10:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
            break;
          case 11:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
            break;
          case 12:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
            break;
          case 13:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
            break;
          case 14:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
            break;
          case 15:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
            break;
          case 16:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
            break;
          case 17:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
            break;
          case 18:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
            break;
          case 19:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
            break;
          case 20:
            obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
            break;
          default:
            throw new exceptions_1.BaseException("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
        }
      } catch (e) {
        throw new reflective_exceptions_1.InstantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    };
    ReflectiveInjector_.prototype._getByReflectiveDependency = function(provider, dep) {
      return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : injector_1.THROW_IF_NOT_FOUND);
    };
    ReflectiveInjector_.prototype._getByKey = function(key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
      if (key === INJECTOR_KEY) {
        return this;
      }
      if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
      }
    };
    ReflectiveInjector_.prototype._throwOrNull = function(key, notFoundValue) {
      if (notFoundValue !== injector_1.THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw new reflective_exceptions_1.NoProviderError(this, key);
      }
    };
    ReflectiveInjector_.prototype._getByKeySelf = function(key, notFoundValue) {
      var obj = this._strategy.getObjByKeyId(key.id);
      return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
    };
    ReflectiveInjector_.prototype._getByKeyDefault = function(key, notFoundValue, lowerBoundVisibility) {
      var inj;
      if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
        inj = this._parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        var inj_ = inj;
        var obj = inj_._strategy.getObjByKeyId(key.id);
        if (obj !== UNDEFINED)
          return obj;
        inj = inj_._parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
      get: function() {
        var providers = _mapProviders(this, function(b) {
          return ' "' + b.key.displayName + '" ';
        }).join(', ');
        return "ReflectiveInjector(providers: [" + providers + "])";
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveInjector_.prototype.toString = function() {
      return this.displayName;
    };
    return ReflectiveInjector_;
  }());
  exports.ReflectiveInjector_ = ReflectiveInjector_;
  var INJECTOR_KEY = reflective_key_1.ReflectiveKey.get(injector_1.Injector);
  function _mapProviders(injector, fn) {
    var res = new Array(injector._proto.numberOfProviders);
    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
      res[i] = fn(injector._proto.getProviderAtIndex(i));
    }
    return res;
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/provider.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var Provider = (function() {
    function Provider(token, _a) {
      var useClass = _a.useClass,
          useValue = _a.useValue,
          useExisting = _a.useExisting,
          useFactory = _a.useFactory,
          deps = _a.deps,
          multi = _a.multi;
      this.token = token;
      this.useClass = useClass;
      this.useValue = useValue;
      this.useExisting = useExisting;
      this.useFactory = useFactory;
      this.dependencies = deps;
      this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
      get: function() {
        return lang_1.normalizeBool(this._multi);
      },
      enumerable: true,
      configurable: true
    });
    return Provider;
  }());
  exports.Provider = Provider;
  var Binding = (function(_super) {
    __extends(Binding, _super);
    function Binding(token, _a) {
      var toClass = _a.toClass,
          toValue = _a.toValue,
          toAlias = _a.toAlias,
          toFactory = _a.toFactory,
          deps = _a.deps,
          multi = _a.multi;
      _super.call(this, token, {
        useClass: toClass,
        useValue: toValue,
        useExisting: toAlias,
        useFactory: toFactory,
        deps: deps,
        multi: multi
      });
    }
    Object.defineProperty(Binding.prototype, "toClass", {
      get: function() {
        return this.useClass;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toAlias", {
      get: function() {
        return this.useExisting;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toFactory", {
      get: function() {
        return this.useFactory;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Binding.prototype, "toValue", {
      get: function() {
        return this.useValue;
      },
      enumerable: true,
      configurable: true
    });
    return Binding;
  }(Provider));
  exports.Binding = Binding;
  function bind(token) {
    return new ProviderBuilder(token);
  }
  exports.bind = bind;
  var ProviderBuilder = (function() {
    function ProviderBuilder(token) {
      this.token = token;
    }
    ProviderBuilder.prototype.toClass = function(type) {
      if (!lang_1.isType(type)) {
        throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
      }
      return new Provider(this.token, {useClass: type});
    };
    ProviderBuilder.prototype.toValue = function(value) {
      return new Provider(this.token, {useValue: value});
    };
    ProviderBuilder.prototype.toAlias = function(aliasToken) {
      if (lang_1.isBlank(aliasToken)) {
        throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
      }
      return new Provider(this.token, {useExisting: aliasToken});
    };
    ProviderBuilder.prototype.toFactory = function(factory, dependencies) {
      if (!lang_1.isFunction(factory)) {
        throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
      }
      return new Provider(this.token, {
        useFactory: factory,
        deps: dependencies
      });
    };
    return ProviderBuilder;
  }());
  exports.ProviderBuilder = ProviderBuilder;
  function provide(token, _a) {
    var useClass = _a.useClass,
        useValue = _a.useValue,
        useExisting = _a.useExisting,
        useFactory = _a.useFactory,
        deps = _a.deps,
        multi = _a.multi;
    return new Provider(token, {
      useClass: useClass,
      useValue: useValue,
      useExisting: useExisting,
      useFactory: useFactory,
      deps: deps,
      multi: multi
    });
  }
  exports.provide = provide;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/provider_util.js", ["./provider"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var provider_1 = $__require('./provider');
  function isProviderLiteral(obj) {
    return obj && typeof obj == 'object' && obj.provide;
  }
  exports.isProviderLiteral = isProviderLiteral;
  function createProvider(obj) {
    return new provider_1.Provider(obj.provide, obj);
  }
  exports.createProvider = createProvider;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/reflective_provider.js", ["../facade/collection", "../facade/lang", "../reflection/reflection", "./forward_ref", "./metadata", "./provider", "./provider_util", "./reflective_exceptions", "./reflective_key"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var reflection_1 = $__require('../reflection/reflection');
  var forward_ref_1 = $__require('./forward_ref');
  var metadata_1 = $__require('./metadata');
  var provider_1 = $__require('./provider');
  var provider_util_1 = $__require('./provider_util');
  var reflective_exceptions_1 = $__require('./reflective_exceptions');
  var reflective_key_1 = $__require('./reflective_key');
  var ReflectiveDependency = (function() {
    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
      this.key = key;
      this.optional = optional;
      this.lowerBoundVisibility = lowerBoundVisibility;
      this.upperBoundVisibility = upperBoundVisibility;
      this.properties = properties;
    }
    ReflectiveDependency.fromKey = function(key) {
      return new ReflectiveDependency(key, false, null, null, []);
    };
    return ReflectiveDependency;
  }());
  exports.ReflectiveDependency = ReflectiveDependency;
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = (function() {
    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
      get: function() {
        return this.resolvedFactories[0];
      },
      enumerable: true,
      configurable: true
    });
    return ResolvedReflectiveProvider_;
  }());
  exports.ResolvedReflectiveProvider_ = ResolvedReflectiveProvider_;
  var ResolvedReflectiveFactory = (function() {
    function ResolvedReflectiveFactory(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
    return ResolvedReflectiveFactory;
  }());
  exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
  function resolveReflectiveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (lang_1.isPresent(provider.useClass)) {
      var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
      factoryFn = reflection_1.reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (lang_1.isPresent(provider.useExisting)) {
      factoryFn = function(aliasInstance) {
        return aliasInstance;
      };
      resolvedDeps = [ReflectiveDependency.fromKey(reflective_key_1.ReflectiveKey.get(provider.useExisting))];
    } else if (lang_1.isPresent(provider.useFactory)) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
    } else {
      factoryFn = function() {
        return provider.useValue;
      };
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  exports.resolveReflectiveFactory = resolveReflectiveFactory;
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(reflective_key_1.ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
  }
  exports.resolveReflectiveProvider = resolveReflectiveProvider;
  function resolveReflectiveProviders(providers) {
    var normalized = _normalizeProviders(providers, []);
    var resolved = normalized.map(resolveReflectiveProvider);
    return collection_1.MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
  }
  exports.resolveReflectiveProviders = resolveReflectiveProviders;
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (var i = 0; i < providers.length; i++) {
      var provider = providers[i];
      var existing = normalizedProvidersMap.get(provider.key.id);
      if (lang_1.isPresent(existing)) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw new reflective_exceptions_1.MixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (var j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        var resolvedProvider;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(provider.key, collection_1.ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  exports.mergeResolvedReflectiveProviders = mergeResolvedReflectiveProviders;
  function _normalizeProviders(providers, res) {
    providers.forEach(function(b) {
      if (b instanceof lang_1.Type) {
        res.push(provider_1.provide(b, {useClass: b}));
      } else if (b instanceof provider_1.Provider) {
        res.push(b);
      } else if (provider_util_1.isProviderLiteral(b)) {
        res.push(provider_util_1.createProvider(b));
      } else if (b instanceof Array) {
        _normalizeProviders(b, res);
      } else if (b instanceof provider_1.ProviderBuilder) {
        throw new reflective_exceptions_1.InvalidProviderError(b.token);
      } else {
        throw new reflective_exceptions_1.InvalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (lang_1.isBlank(dependencies)) {
      return _dependenciesFor(typeOrFunc);
    } else {
      var params = dependencies.map(function(t) {
        return [t];
      });
      return dependencies.map(function(t) {
        return _extractToken(typeOrFunc, t, params);
      });
    }
  }
  exports.constructDependencies = constructDependencies;
  function _dependenciesFor(typeOrFunc) {
    var params = reflection_1.reflector.parameters(typeOrFunc);
    if (lang_1.isBlank(params))
      return [];
    if (params.some(lang_1.isBlank)) {
      throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
    }
    return params.map(function(p) {
      return _extractToken(typeOrFunc, p, params);
    });
  }
  function _extractToken(typeOrFunc, metadata, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!lang_1.isArray(metadata)) {
      if (metadata instanceof metadata_1.InjectMetadata) {
        return _createDependency(metadata.token, optional, null, null, depProps);
      } else {
        return _createDependency(metadata, optional, null, null, depProps);
      }
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
      var paramMetadata = metadata[i];
      if (paramMetadata instanceof lang_1.Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof metadata_1.InjectMetadata) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
        optional = true;
      } else if (paramMetadata instanceof metadata_1.SelfMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof metadata_1.HostMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
        lowerBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
        if (lang_1.isPresent(paramMetadata.token)) {
          token = paramMetadata.token;
        }
        depProps.push(paramMetadata);
      }
    }
    token = forward_ref_1.resolveForwardRef(token);
    if (lang_1.isPresent(token)) {
      return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    } else {
      throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new ReflectiveDependency(reflective_key_1.ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/forward_ref.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return lang_1.stringify(this());
    };
    return forwardRefFn;
  }
  exports.forwardRef = forwardRef;
  function resolveForwardRef(type) {
    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
      return type();
    } else {
      return type;
    }
  }
  exports.resolveForwardRef = resolveForwardRef;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/reflective_key.js", ["../facade/exceptions", "../facade/lang", "./forward_ref"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var forward_ref_1 = $__require('./forward_ref');
  var ReflectiveKey = (function() {
    function ReflectiveKey(token, id) {
      this.token = token;
      this.id = id;
      if (lang_1.isBlank(token)) {
        throw new exceptions_1.BaseException('Token must be defined!');
      }
    }
    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
      get: function() {
        return lang_1.stringify(this.token);
      },
      enumerable: true,
      configurable: true
    });
    ReflectiveKey.get = function(token) {
      return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token));
    };
    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
      get: function() {
        return _globalKeyRegistry.numberOfKeys;
      },
      enumerable: true,
      configurable: true
    });
    return ReflectiveKey;
  }());
  exports.ReflectiveKey = ReflectiveKey;
  var KeyRegistry = (function() {
    function KeyRegistry() {
      this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function(token) {
      if (token instanceof ReflectiveKey)
        return token;
      if (this._allKeys.has(token)) {
        return this._allKeys.get(token);
      }
      var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
      get: function() {
        return this._allKeys.size;
      },
      enumerable: true,
      configurable: true
    });
    return KeyRegistry;
  }());
  exports.KeyRegistry = KeyRegistry;
  var _globalKeyRegistry = new KeyRegistry();
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/reflective_exceptions.js", ["../facade/collection", "../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (collection_1.ListWrapper.contains(res, keys[i])) {
        res.push(keys[i]);
        return res;
      }
      res.push(keys[i]);
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
      var tokenStrs = reversed.map(function(k) {
        return lang_1.stringify(k.token);
      });
      return ' (' + tokenStrs.join(' -> ') + ')';
    }
    return '';
  }
  var AbstractProviderError = (function(_super) {
    __extends(AbstractProviderError, _super);
    function AbstractProviderError(injector, key, constructResolvingMessage) {
      _super.call(this, 'DI Exception');
      this.keys = [key];
      this.injectors = [injector];
      this.constructResolvingMessage = constructResolvingMessage;
      this.message = this.constructResolvingMessage(this.keys);
    }
    AbstractProviderError.prototype.addKey = function(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key);
      this.message = this.constructResolvingMessage(this.keys);
    };
    Object.defineProperty(AbstractProviderError.prototype, "context", {
      get: function() {
        return this.injectors[this.injectors.length - 1].debugContext();
      },
      enumerable: true,
      configurable: true
    });
    return AbstractProviderError;
  }(exceptions_1.BaseException));
  exports.AbstractProviderError = AbstractProviderError;
  var NoProviderError = (function(_super) {
    __extends(NoProviderError, _super);
    function NoProviderError(injector, key) {
      _super.call(this, injector, key, function(keys) {
        var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
        return "No provider for " + first + "!" + constructResolvingPath(keys);
      });
    }
    return NoProviderError;
  }(AbstractProviderError));
  exports.NoProviderError = NoProviderError;
  var CyclicDependencyError = (function(_super) {
    __extends(CyclicDependencyError, _super);
    function CyclicDependencyError(injector, key) {
      _super.call(this, injector, key, function(keys) {
        return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
      });
    }
    return CyclicDependencyError;
  }(AbstractProviderError));
  exports.CyclicDependencyError = CyclicDependencyError;
  var InstantiationError = (function(_super) {
    __extends(InstantiationError, _super);
    function InstantiationError(injector, originalException, originalStack, key) {
      _super.call(this, 'DI Exception', originalException, originalStack, null);
      this.keys = [key];
      this.injectors = [injector];
    }
    InstantiationError.prototype.addKey = function(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key);
    };
    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
      get: function() {
        var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
        return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "causeKey", {
      get: function() {
        return this.keys[0];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "context", {
      get: function() {
        return this.injectors[this.injectors.length - 1].debugContext();
      },
      enumerable: true,
      configurable: true
    });
    return InstantiationError;
  }(exceptions_1.WrappedException));
  exports.InstantiationError = InstantiationError;
  var InvalidProviderError = (function(_super) {
    __extends(InvalidProviderError, _super);
    function InvalidProviderError(provider) {
      _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
    }
    return InvalidProviderError;
  }(exceptions_1.BaseException));
  exports.InvalidProviderError = InvalidProviderError;
  var NoAnnotationError = (function(_super) {
    __extends(NoAnnotationError, _super);
    function NoAnnotationError(typeOrFunc, params) {
      _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
    }
    NoAnnotationError._genMessage = function(typeOrFunc, params) {
      var signature = [];
      for (var i = 0,
          ii = params.length; i < ii; i++) {
        var parameter = params[i];
        if (lang_1.isBlank(parameter) || parameter.length == 0) {
          signature.push('?');
        } else {
          signature.push(parameter.map(lang_1.stringify).join(' '));
        }
      }
      return 'Cannot resolve all parameters for \'' + lang_1.stringify(typeOrFunc) + '\'(' + signature.join(', ') + '). ' + 'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' + lang_1.stringify(typeOrFunc) + '\' is decorated with Injectable.';
    };
    return NoAnnotationError;
  }(exceptions_1.BaseException));
  exports.NoAnnotationError = NoAnnotationError;
  var OutOfBoundsError = (function(_super) {
    __extends(OutOfBoundsError, _super);
    function OutOfBoundsError(index) {
      _super.call(this, "Index " + index + " is out-of-bounds.");
    }
    return OutOfBoundsError;
  }(exceptions_1.BaseException));
  exports.OutOfBoundsError = OutOfBoundsError;
  var MixingMultiProvidersWithRegularProvidersError = (function(_super) {
    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
      _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' + provider2.toString());
    }
    return MixingMultiProvidersWithRegularProvidersError;
  }(exceptions_1.BaseException));
  exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/opaque_token.js", ["./decorators"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var decorators_1 = $__require('./decorators');
  var OpaqueToken = (function() {
    function OpaqueToken(_desc) {
      this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function() {
      return "Token " + this._desc;
    };
    OpaqueToken.decorators = [{type: decorators_1.Injectable}];
    OpaqueToken.ctorParameters = [null];
    return OpaqueToken;
  }());
  exports.OpaqueToken = OpaqueToken;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di.js", ["./di/metadata", "./di/decorators", "./di/forward_ref", "./di/injector", "./di/reflective_injector", "./di/provider", "./di/reflective_provider", "./di/reflective_key", "./di/reflective_exceptions", "./di/opaque_token"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  var metadata_1 = $__require('./di/metadata');
  exports.HostMetadata = metadata_1.HostMetadata;
  exports.InjectMetadata = metadata_1.InjectMetadata;
  exports.InjectableMetadata = metadata_1.InjectableMetadata;
  exports.OptionalMetadata = metadata_1.OptionalMetadata;
  exports.SelfMetadata = metadata_1.SelfMetadata;
  exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
  __export($__require('./di/decorators'));
  var forward_ref_1 = $__require('./di/forward_ref');
  exports.forwardRef = forward_ref_1.forwardRef;
  exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
  var injector_1 = $__require('./di/injector');
  exports.Injector = injector_1.Injector;
  var reflective_injector_1 = $__require('./di/reflective_injector');
  exports.ReflectiveInjector = reflective_injector_1.ReflectiveInjector;
  var provider_1 = $__require('./di/provider');
  exports.Binding = provider_1.Binding;
  exports.ProviderBuilder = provider_1.ProviderBuilder;
  exports.bind = provider_1.bind;
  exports.Provider = provider_1.Provider;
  exports.provide = provider_1.provide;
  var reflective_provider_1 = $__require('./di/reflective_provider');
  exports.ResolvedReflectiveFactory = reflective_provider_1.ResolvedReflectiveFactory;
  var reflective_key_1 = $__require('./di/reflective_key');
  exports.ReflectiveKey = reflective_key_1.ReflectiveKey;
  var reflective_exceptions_1 = $__require('./di/reflective_exceptions');
  exports.NoProviderError = reflective_exceptions_1.NoProviderError;
  exports.AbstractProviderError = reflective_exceptions_1.AbstractProviderError;
  exports.CyclicDependencyError = reflective_exceptions_1.CyclicDependencyError;
  exports.InstantiationError = reflective_exceptions_1.InstantiationError;
  exports.InvalidProviderError = reflective_exceptions_1.InvalidProviderError;
  exports.NoAnnotationError = reflective_exceptions_1.NoAnnotationError;
  exports.OutOfBoundsError = reflective_exceptions_1.OutOfBoundsError;
  var opaque_token_1 = $__require('./di/opaque_token');
  exports.OpaqueToken = opaque_token_1.OpaqueToken;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/differs/keyvalue_differs.js", ["../../di", "../../facade/collection", "../../facade/exceptions", "../../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var di_1 = $__require('../../di');
  var collection_1 = $__require('../../facade/collection');
  var exceptions_1 = $__require('../../facade/exceptions');
  var lang_1 = $__require('../../facade/lang');
  var KeyValueDiffers = (function() {
    function KeyValueDiffers(factories) {
      this.factories = factories;
    }
    KeyValueDiffers.create = function(factories, parent) {
      if (lang_1.isPresent(parent)) {
        var copied = collection_1.ListWrapper.clone(parent.factories);
        factories = factories.concat(copied);
        return new KeyValueDiffers(factories);
      } else {
        return new KeyValueDiffers(factories);
      }
    };
    KeyValueDiffers.extend = function(factories) {
      return new di_1.Provider(KeyValueDiffers, {
        useFactory: function(parent) {
          if (lang_1.isBlank(parent)) {
            throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
          }
          return KeyValueDiffers.create(factories, parent);
        },
        deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
      });
    };
    KeyValueDiffers.prototype.find = function(kv) {
      var factory = this.factories.find(function(f) {
        return f.supports(kv);
      });
      if (lang_1.isPresent(factory)) {
        return factory;
      } else {
        throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
      }
    };
    return KeyValueDiffers;
  }());
  exports.KeyValueDiffers = KeyValueDiffers;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/change_detector_ref.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ChangeDetectorRef = (function() {
    function ChangeDetectorRef() {}
    return ChangeDetectorRef;
  }());
  exports.ChangeDetectorRef = ChangeDetectorRef;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/constants.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  (function(ChangeDetectionStrategy) {
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
  })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
  var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
  (function(ChangeDetectorStatus) {
    ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
    ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
    ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
    ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
    ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
    ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
  })(exports.ChangeDetectorStatus || (exports.ChangeDetectorStatus = {}));
  var ChangeDetectorStatus = exports.ChangeDetectorStatus;
  exports.CHANGE_DETECTION_STRATEGY_VALUES = [ChangeDetectionStrategy.OnPush, ChangeDetectionStrategy.Default];
  exports.CHANGE_DETECTOR_STATUS_VALUES = [ChangeDetectorStatus.CheckOnce, ChangeDetectorStatus.Checked, ChangeDetectorStatus.CheckAlways, ChangeDetectorStatus.Detached, ChangeDetectorStatus.Errored, ChangeDetectorStatus.Destroyed];
  function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return lang_1.isBlank(changeDetectionStrategy) || changeDetectionStrategy === ChangeDetectionStrategy.Default;
  }
  exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/change_detection.js", ["./differs/default_iterable_differ", "./differs/default_keyvalue_differ", "./differs/iterable_differs", "./differs/keyvalue_differs", "./change_detection_util", "./change_detector_ref", "./constants"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var default_iterable_differ_1 = $__require('./differs/default_iterable_differ');
  var default_keyvalue_differ_1 = $__require('./differs/default_keyvalue_differ');
  var iterable_differs_1 = $__require('./differs/iterable_differs');
  var keyvalue_differs_1 = $__require('./differs/keyvalue_differs');
  var change_detection_util_1 = $__require('./change_detection_util');
  exports.SimpleChange = change_detection_util_1.SimpleChange;
  exports.UNINITIALIZED = change_detection_util_1.UNINITIALIZED;
  exports.ValueUnwrapper = change_detection_util_1.ValueUnwrapper;
  exports.WrappedValue = change_detection_util_1.WrappedValue;
  exports.devModeEqual = change_detection_util_1.devModeEqual;
  exports.looseIdentical = change_detection_util_1.looseIdentical;
  var change_detector_ref_1 = $__require('./change_detector_ref');
  exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
  var constants_1 = $__require('./constants');
  exports.CHANGE_DETECTION_STRATEGY_VALUES = constants_1.CHANGE_DETECTION_STRATEGY_VALUES;
  exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
  exports.ChangeDetectorStatus = constants_1.ChangeDetectorStatus;
  exports.isDefaultChangeDetectionStrategy = constants_1.isDefaultChangeDetectionStrategy;
  var default_iterable_differ_2 = $__require('./differs/default_iterable_differ');
  exports.CollectionChangeRecord = default_iterable_differ_2.CollectionChangeRecord;
  exports.DefaultIterableDifferFactory = default_iterable_differ_2.DefaultIterableDifferFactory;
  var default_iterable_differ_3 = $__require('./differs/default_iterable_differ');
  exports.DefaultIterableDiffer = default_iterable_differ_3.DefaultIterableDiffer;
  var default_keyvalue_differ_2 = $__require('./differs/default_keyvalue_differ');
  exports.DefaultKeyValueDifferFactory = default_keyvalue_differ_2.DefaultKeyValueDifferFactory;
  exports.KeyValueChangeRecord = default_keyvalue_differ_2.KeyValueChangeRecord;
  var iterable_differs_2 = $__require('./differs/iterable_differs');
  exports.IterableDiffers = iterable_differs_2.IterableDiffers;
  var keyvalue_differs_2 = $__require('./differs/keyvalue_differs');
  exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
  exports.keyValDiff = [new default_keyvalue_differ_1.DefaultKeyValueDifferFactory()];
  exports.iterableDiff = [new default_iterable_differ_1.DefaultIterableDifferFactory()];
  exports.defaultIterableDiffers = new iterable_differs_1.IterableDiffers(exports.iterableDiff);
  exports.defaultKeyValueDiffers = new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff);
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/metadata.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var InjectMetadata = (function() {
    function InjectMetadata(token) {
      this.token = token;
    }
    InjectMetadata.prototype.toString = function() {
      return "@Inject(" + lang_1.stringify(this.token) + ")";
    };
    return InjectMetadata;
  }());
  exports.InjectMetadata = InjectMetadata;
  var OptionalMetadata = (function() {
    function OptionalMetadata() {}
    OptionalMetadata.prototype.toString = function() {
      return "@Optional()";
    };
    return OptionalMetadata;
  }());
  exports.OptionalMetadata = OptionalMetadata;
  var DependencyMetadata = (function() {
    function DependencyMetadata() {}
    Object.defineProperty(DependencyMetadata.prototype, "token", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    return DependencyMetadata;
  }());
  exports.DependencyMetadata = DependencyMetadata;
  var InjectableMetadata = (function() {
    function InjectableMetadata() {}
    return InjectableMetadata;
  }());
  exports.InjectableMetadata = InjectableMetadata;
  var SelfMetadata = (function() {
    function SelfMetadata() {}
    SelfMetadata.prototype.toString = function() {
      return "@Self()";
    };
    return SelfMetadata;
  }());
  exports.SelfMetadata = SelfMetadata;
  var SkipSelfMetadata = (function() {
    function SkipSelfMetadata() {}
    SkipSelfMetadata.prototype.toString = function() {
      return "@SkipSelf()";
    };
    return SkipSelfMetadata;
  }());
  exports.SkipSelfMetadata = SkipSelfMetadata;
  var HostMetadata = (function() {
    function HostMetadata() {}
    HostMetadata.prototype.toString = function() {
      return "@Host()";
    };
    return HostMetadata;
  }());
  exports.HostMetadata = HostMetadata;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/di/decorators.js", ["../util/decorators", "./metadata"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var decorators_1 = $__require('../util/decorators');
  var metadata_1 = $__require('./metadata');
  exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
  exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
  exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
  exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
  exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
  exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/element_ref.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ElementRef = (function() {
    function ElementRef(nativeElement) {
      this.nativeElement = nativeElement;
    }
    return ElementRef;
  }());
  exports.ElementRef = ElementRef;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/profile/wtf_impl.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var trace;
  var events;
  function detectWTF() {
    var wtf = lang_1.global['wtf'];
    if (wtf) {
      trace = wtf['trace'];
      if (trace) {
        events = trace['events'];
        return true;
      }
    }
    return false;
  }
  exports.detectWTF = detectWTF;
  function createScope(signature, flags) {
    if (flags === void 0) {
      flags = null;
    }
    return events.createScope(signature, flags);
  }
  exports.createScope = createScope;
  function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
  }
  exports.leave = leave;
  function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
  }
  exports.startTimeRange = startTimeRange;
  function endTimeRange(range) {
    trace.endTimeRange(range);
  }
  exports.endTimeRange = endTimeRange;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/profile/profile.js", ["./wtf_impl"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var wtf_impl_1 = $__require('./wtf_impl');
  exports.wtfEnabled = wtf_impl_1.detectWTF();
  function noopScope(arg0, arg1) {
    return null;
  }
  exports.wtfCreateScope = exports.wtfEnabled ? wtf_impl_1.createScope : function(signature, flags) {
    return noopScope;
  };
  exports.wtfLeave = exports.wtfEnabled ? wtf_impl_1.leave : function(s, r) {
    return r;
  };
  exports.wtfStartTimeRange = exports.wtfEnabled ? wtf_impl_1.startTimeRange : function(rangeType, action) {
    return null;
  };
  exports.wtfEndTimeRange = exports.wtfEnabled ? wtf_impl_1.endTimeRange : function(r) {
    return null;
  };
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/view_container_ref.js", ["../facade/collection", "../facade/exceptions", "../facade/lang", "../profile/profile"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var profile_1 = $__require('../profile/profile');
  var ViewContainerRef = (function() {
    function ViewContainerRef() {}
    Object.defineProperty(ViewContainerRef.prototype, "element", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "injector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "length", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    ;
    return ViewContainerRef;
  }());
  exports.ViewContainerRef = ViewContainerRef;
  var ViewContainerRef_ = (function() {
    function ViewContainerRef_(_element) {
      this._element = _element;
      this._createComponentInContainerScope = profile_1.wtfCreateScope('ViewContainerRef#createComponent()');
      this._insertScope = profile_1.wtfCreateScope('ViewContainerRef#insert()');
      this._removeScope = profile_1.wtfCreateScope('ViewContainerRef#remove()');
      this._detachScope = profile_1.wtfCreateScope('ViewContainerRef#detach()');
    }
    ViewContainerRef_.prototype.get = function(index) {
      return this._element.nestedViews[index].ref;
    };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
      get: function() {
        var views = this._element.nestedViews;
        return lang_1.isPresent(views) ? views.length : 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "element", {
      get: function() {
        return this._element.elementRef;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
      get: function() {
        return this._element.injector;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
      get: function() {
        return this._element.parentInjector;
      },
      enumerable: true,
      configurable: true
    });
    ViewContainerRef_.prototype.createEmbeddedView = function(templateRef, context, index) {
      if (context === void 0) {
        context = null;
      }
      if (index === void 0) {
        index = -1;
      }
      var viewRef = templateRef.createEmbeddedView(context);
      this.insert(viewRef, index);
      return viewRef;
    };
    ViewContainerRef_.prototype.createComponent = function(componentFactory, index, injector, projectableNodes) {
      if (index === void 0) {
        index = -1;
      }
      if (injector === void 0) {
        injector = null;
      }
      if (projectableNodes === void 0) {
        projectableNodes = null;
      }
      var s = this._createComponentInContainerScope();
      var contextInjector = lang_1.isPresent(injector) ? injector : this._element.parentInjector;
      var componentRef = componentFactory.create(contextInjector, projectableNodes);
      this.insert(componentRef.hostView, index);
      return profile_1.wtfLeave(s, componentRef);
    };
    ViewContainerRef_.prototype.insert = function(viewRef, index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._insertScope();
      if (index == -1)
        index = this.length;
      var viewRef_ = viewRef;
      this._element.attachView(viewRef_.internalView, index);
      return profile_1.wtfLeave(s, viewRef_);
    };
    ViewContainerRef_.prototype.move = function(viewRef, currentIndex) {
      var s = this._insertScope();
      if (currentIndex == -1)
        return;
      var viewRef_ = viewRef;
      this._element.moveView(viewRef_.internalView, currentIndex);
      return profile_1.wtfLeave(s, viewRef_);
    };
    ViewContainerRef_.prototype.indexOf = function(viewRef) {
      return collection_1.ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
    };
    ViewContainerRef_.prototype.remove = function(index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._removeScope();
      if (index == -1)
        index = this.length - 1;
      var view = this._element.detachView(index);
      view.destroy();
      profile_1.wtfLeave(s);
    };
    ViewContainerRef_.prototype.detach = function(index) {
      if (index === void 0) {
        index = -1;
      }
      var s = this._detachScope();
      if (index == -1)
        index = this.length - 1;
      var view = this._element.detachView(index);
      return profile_1.wtfLeave(s, view.ref);
    };
    ViewContainerRef_.prototype.clear = function() {
      for (var i = this.length - 1; i >= 0; i--) {
        this.remove(i);
      }
    };
    return ViewContainerRef_;
  }());
  exports.ViewContainerRef_ = ViewContainerRef_;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/view_type.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(ViewType) {
    ViewType[ViewType["HOST"] = 0] = "HOST";
    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
  })(exports.ViewType || (exports.ViewType = {}));
  var ViewType = exports.ViewType;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/element.js", ["../facade/collection", "../facade/exceptions", "../facade/lang", "./element_ref", "./view_container_ref", "./view_type"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var element_ref_1 = $__require('./element_ref');
  var view_container_ref_1 = $__require('./view_container_ref');
  var view_type_1 = $__require('./view_type');
  var AppElement = (function() {
    function AppElement(index, parentIndex, parentView, nativeElement) {
      this.index = index;
      this.parentIndex = parentIndex;
      this.parentView = parentView;
      this.nativeElement = nativeElement;
      this.nestedViews = null;
      this.componentView = null;
    }
    Object.defineProperty(AppElement.prototype, "elementRef", {
      get: function() {
        return new element_ref_1.ElementRef(this.nativeElement);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppElement.prototype, "vcRef", {
      get: function() {
        return new view_container_ref_1.ViewContainerRef_(this);
      },
      enumerable: true,
      configurable: true
    });
    AppElement.prototype.initComponent = function(component, componentConstructorViewQueries, view) {
      this.component = component;
      this.componentConstructorViewQueries = componentConstructorViewQueries;
      this.componentView = view;
    };
    Object.defineProperty(AppElement.prototype, "parentInjector", {
      get: function() {
        return this.parentView.injector(this.parentIndex);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AppElement.prototype, "injector", {
      get: function() {
        return this.parentView.injector(this.index);
      },
      enumerable: true,
      configurable: true
    });
    AppElement.prototype.mapNestedViews = function(nestedViewClass, callback) {
      var result = [];
      if (lang_1.isPresent(this.nestedViews)) {
        this.nestedViews.forEach(function(nestedView) {
          if (nestedView.clazz === nestedViewClass) {
            result.push(callback(nestedView));
          }
        });
      }
      return result;
    };
    AppElement.prototype.moveView = function(view, currentIndex) {
      var previousIndex = this.nestedViews.indexOf(view);
      if (view.type === view_type_1.ViewType.COMPONENT) {
        throw new exceptions_1.BaseException("Component views can't be moved!");
      }
      var nestedViews = this.nestedViews;
      if (nestedViews == null) {
        nestedViews = [];
        this.nestedViews = nestedViews;
      }
      collection_1.ListWrapper.removeAt(nestedViews, previousIndex);
      collection_1.ListWrapper.insert(nestedViews, currentIndex, view);
      var refRenderNode;
      if (currentIndex > 0) {
        var prevView = nestedViews[currentIndex - 1];
        refRenderNode = prevView.lastRootNode;
      } else {
        refRenderNode = this.nativeElement;
      }
      if (lang_1.isPresent(refRenderNode)) {
        view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
      }
      view.markContentChildAsMoved(this);
    };
    AppElement.prototype.attachView = function(view, viewIndex) {
      if (view.type === view_type_1.ViewType.COMPONENT) {
        throw new exceptions_1.BaseException("Component views can't be moved!");
      }
      var nestedViews = this.nestedViews;
      if (nestedViews == null) {
        nestedViews = [];
        this.nestedViews = nestedViews;
      }
      collection_1.ListWrapper.insert(nestedViews, viewIndex, view);
      var refRenderNode;
      if (viewIndex > 0) {
        var prevView = nestedViews[viewIndex - 1];
        refRenderNode = prevView.lastRootNode;
      } else {
        refRenderNode = this.nativeElement;
      }
      if (lang_1.isPresent(refRenderNode)) {
        view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
      }
      view.addToContentChildren(this);
    };
    AppElement.prototype.detachView = function(viewIndex) {
      var view = collection_1.ListWrapper.removeAt(this.nestedViews, viewIndex);
      if (view.type === view_type_1.ViewType.COMPONENT) {
        throw new exceptions_1.BaseException("Component views can't be moved!");
      }
      view.detach();
      view.removeFromContentChildren(this);
      return view;
    };
    return AppElement;
  }());
  exports.AppElement = AppElement;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/change_detection/change_detection_util.js", ["../facade/collection", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var collection_1 = $__require('../facade/collection');
  var lang_1 = $__require('../facade/lang');
  var lang_2 = $__require('../facade/lang');
  exports.looseIdentical = lang_2.looseIdentical;
  exports.UNINITIALIZED = {toString: function() {
      return 'CD_INIT_VALUE';
    }};
  function devModeEqual(a, b) {
    if (collection_1.isListLikeIterable(a) && collection_1.isListLikeIterable(b)) {
      return collection_1.areIterablesEqual(a, b, devModeEqual);
    } else if (!collection_1.isListLikeIterable(a) && !lang_1.isPrimitive(a) && !collection_1.isListLikeIterable(b) && !lang_1.isPrimitive(b)) {
      return true;
    } else {
      return lang_1.looseIdentical(a, b);
    }
  }
  exports.devModeEqual = devModeEqual;
  var WrappedValue = (function() {
    function WrappedValue(wrapped) {
      this.wrapped = wrapped;
    }
    WrappedValue.wrap = function(value) {
      return new WrappedValue(value);
    };
    return WrappedValue;
  }());
  exports.WrappedValue = WrappedValue;
  var ValueUnwrapper = (function() {
    function ValueUnwrapper() {
      this.hasWrappedValue = false;
    }
    ValueUnwrapper.prototype.unwrap = function(value) {
      if (value instanceof WrappedValue) {
        this.hasWrappedValue = true;
        return value.wrapped;
      }
      return value;
    };
    ValueUnwrapper.prototype.reset = function() {
      this.hasWrappedValue = false;
    };
    return ValueUnwrapper;
  }());
  exports.ValueUnwrapper = ValueUnwrapper;
  var SimpleChange = (function() {
    function SimpleChange(previousValue, currentValue) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
    }
    SimpleChange.prototype.isFirstChange = function() {
      return this.previousValue === exports.UNINITIALIZED;
    };
    return SimpleChange;
  }());
  exports.SimpleChange = SimpleChange;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/exceptions.js", ["../change_detection/change_detection_util", "../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var change_detection_util_1 = $__require('../change_detection/change_detection_util');
  var exceptions_1 = $__require('../facade/exceptions');
  var ExpressionChangedAfterItHasBeenCheckedException = (function(_super) {
    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
      var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
      if (oldValue === change_detection_util_1.UNINITIALIZED) {
        msg += " It seems like the view has been created after its parent and its children have been dirty checked." + " Has it been created in a change detection hook ?";
      }
      _super.call(this, msg);
    }
    return ExpressionChangedAfterItHasBeenCheckedException;
  }(exceptions_1.BaseException));
  exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
  var ViewWrappedException = (function(_super) {
    __extends(ViewWrappedException, _super);
    function ViewWrappedException(originalException, originalStack, context) {
      _super.call(this, "Error in " + context.source, originalException, originalStack, context);
    }
    return ViewWrappedException;
  }(exceptions_1.WrappedException));
  exports.ViewWrappedException = ViewWrappedException;
  var ViewDestroyedException = (function(_super) {
    __extends(ViewDestroyedException, _super);
    function ViewDestroyedException(details) {
      _super.call(this, "Attempt to use a destroyed view: " + details);
    }
    return ViewDestroyedException;
  }(exceptions_1.BaseException));
  exports.ViewDestroyedException = ViewDestroyedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/linker/view_utils.js", ["../application_tokens", "../change_detection/change_detection", "../change_detection/change_detection_util", "../di/decorators", "../facade/collection", "../facade/exceptions", "../facade/lang", "../render/api", "../security", "./element", "./exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var application_tokens_1 = $__require('../application_tokens');
  var change_detection_1 = $__require('../change_detection/change_detection');
  var change_detection_util_1 = $__require('../change_detection/change_detection_util');
  var decorators_1 = $__require('../di/decorators');
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var api_1 = $__require('../render/api');
  var security_1 = $__require('../security');
  var element_1 = $__require('./element');
  var exceptions_2 = $__require('./exceptions');
  var ViewUtils = (function() {
    function ViewUtils(_renderer, _appId, sanitizer) {
      this._renderer = _renderer;
      this._appId = _appId;
      this._nextCompTypeId = 0;
      this.sanitizer = sanitizer;
    }
    ViewUtils.prototype.createRenderComponentType = function(templateUrl, slotCount, encapsulation, styles, animations) {
      return new api_1.RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
    };
    ViewUtils.prototype.renderComponent = function(renderComponentType) {
      return this._renderer.renderComponent(renderComponentType);
    };
    ViewUtils.decorators = [{type: decorators_1.Injectable}];
    ViewUtils.ctorParameters = [{type: api_1.RootRenderer}, {
      type: undefined,
      decorators: [{
        type: decorators_1.Inject,
        args: [application_tokens_1.APP_ID]
      }]
    }, {type: security_1.SanitizationService}];
    return ViewUtils;
  }());
  exports.ViewUtils = ViewUtils;
  function flattenNestedViewRenderNodes(nodes) {
    return _flattenNestedViewRenderNodes(nodes, []);
  }
  exports.flattenNestedViewRenderNodes = flattenNestedViewRenderNodes;
  function _flattenNestedViewRenderNodes(nodes, renderNodes) {
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node instanceof element_1.AppElement) {
        var appEl = node;
        renderNodes.push(appEl.nativeElement);
        if (lang_1.isPresent(appEl.nestedViews)) {
          for (var k = 0; k < appEl.nestedViews.length; k++) {
            _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
          }
        }
      } else {
        renderNodes.push(node);
      }
    }
    return renderNodes;
  }
  var EMPTY_ARR = [];
  function ensureSlotCount(projectableNodes, expectedSlotCount) {
    var res;
    if (lang_1.isBlank(projectableNodes)) {
      res = EMPTY_ARR;
    } else if (projectableNodes.length < expectedSlotCount) {
      var givenSlotCount = projectableNodes.length;
      res = collection_1.ListWrapper.createFixedSize(expectedSlotCount);
      for (var i = 0; i < expectedSlotCount; i++) {
        res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
      }
    } else {
      res = projectableNodes;
    }
    return res;
  }
  exports.ensureSlotCount = ensureSlotCount;
  exports.MAX_INTERPOLATION_VALUES = 9;
  function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
    switch (valueCount) {
      case 1:
        return c0 + _toStringWithNull(a1) + c1;
      case 2:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
      case 3:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;
      case 4:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;
      case 5:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
      case 6:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
      case 7:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;
      case 8:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
      case 9:
        return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
      default:
        throw new exceptions_1.BaseException("Does not support more than 9 expressions");
    }
  }
  exports.interpolate = interpolate;
  function _toStringWithNull(v) {
    return v != null ? v.toString() : '';
  }
  function checkBinding(throwOnChange, oldValue, newValue) {
    if (throwOnChange) {
      if (!change_detection_1.devModeEqual(oldValue, newValue)) {
        throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
      }
      return false;
    } else {
      return !lang_1.looseIdentical(oldValue, newValue);
    }
  }
  exports.checkBinding = checkBinding;
  function castByValue(input, value) {
    return input;
  }
  exports.castByValue = castByValue;
  exports.EMPTY_ARRAY = [];
  exports.EMPTY_MAP = {};
  function pureProxy1(fn) {
    var result;
    var v0 = change_detection_util_1.UNINITIALIZED;
    return function(p0) {
      if (!lang_1.looseIdentical(v0, p0)) {
        v0 = p0;
        result = fn(p0);
      }
      return result;
    };
  }
  exports.pureProxy1 = pureProxy1;
  function pureProxy2(fn) {
    var result;
    var v0 = change_detection_util_1.UNINITIALIZED;
    var v1 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1)) {
        v0 = p0;
        v1 = p1;
        result = fn(p0, p1);
      }
      return result;
    };
  }
  exports.pureProxy2 = pureProxy2;
  function pureProxy3(fn) {
    var result;
    var v0 = change_detection_util_1.UNINITIALIZED;
    var v1 = change_detection_util_1.UNINITIALIZED;
    var v2 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        result = fn(p0, p1, p2);
      }
      return result;
    };
  }
  exports.pureProxy3 = pureProxy3;
  function pureProxy4(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3;
    v0 = v1 = v2 = v3 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        result = fn(p0, p1, p2, p3);
      }
      return result;
    };
  }
  exports.pureProxy4 = pureProxy4;
  function pureProxy5(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4;
    v0 = v1 = v2 = v3 = v4 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        result = fn(p0, p1, p2, p3, p4);
      }
      return result;
    };
  }
  exports.pureProxy5 = pureProxy5;
  function pureProxy6(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5;
    v0 = v1 = v2 = v3 = v4 = v5 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4, p5) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        result = fn(p0, p1, p2, p3, p4, p5);
      }
      return result;
    };
  }
  exports.pureProxy6 = pureProxy6;
  function pureProxy7(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4, p5, p6) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) || !lang_1.looseIdentical(v6, p6)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        result = fn(p0, p1, p2, p3, p4, p5, p6);
      }
      return result;
    };
  }
  exports.pureProxy7 = pureProxy7;
  function pureProxy8(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4, p5, p6, p7) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) || !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
      }
      return result;
    };
  }
  exports.pureProxy8 = pureProxy8;
  function pureProxy9(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7,
        v8;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4, p5, p6, p7, p8) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) || !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        v8 = p8;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
      }
      return result;
    };
  }
  exports.pureProxy9 = pureProxy9;
  function pureProxy10(fn) {
    var result;
    var v0,
        v1,
        v2,
        v3,
        v4,
        v5,
        v6,
        v7,
        v8,
        v9;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = change_detection_util_1.UNINITIALIZED;
    return function(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
      if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) || !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) || !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8) || !lang_1.looseIdentical(v9, p9)) {
        v0 = p0;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = p4;
        v5 = p5;
        v6 = p6;
        v7 = p7;
        v8 = p8;
        v9 = p9;
        result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
      }
      return result;
    };
  }
  exports.pureProxy10 = pureProxy10;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata/lifecycle_hooks.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
  })(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
  var LifecycleHooks = exports.LifecycleHooks;
  exports.LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];
  var OnChanges = (function() {
    function OnChanges() {}
    return OnChanges;
  }());
  exports.OnChanges = OnChanges;
  var OnInit = (function() {
    function OnInit() {}
    return OnInit;
  }());
  exports.OnInit = OnInit;
  var DoCheck = (function() {
    function DoCheck() {}
    return DoCheck;
  }());
  exports.DoCheck = DoCheck;
  var OnDestroy = (function() {
    function OnDestroy() {}
    return OnDestroy;
  }());
  exports.OnDestroy = OnDestroy;
  var AfterContentInit = (function() {
    function AfterContentInit() {}
    return AfterContentInit;
  }());
  exports.AfterContentInit = AfterContentInit;
  var AfterContentChecked = (function() {
    function AfterContentChecked() {}
    return AfterContentChecked;
  }());
  exports.AfterContentChecked = AfterContentChecked;
  var AfterViewInit = (function() {
    function AfterViewInit() {}
    return AfterViewInit;
  }());
  exports.AfterViewInit = AfterViewInit;
  var AfterViewChecked = (function() {
    function AfterViewChecked() {}
    return AfterViewChecked;
  }());
  exports.AfterViewChecked = AfterViewChecked;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/metadata/view.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(ViewEncapsulation) {
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
  var ViewEncapsulation = exports.ViewEncapsulation;
  exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
  var ViewMetadata = (function() {
    function ViewMetadata(_a) {
      var _b = _a === void 0 ? {} : _a,
          templateUrl = _b.templateUrl,
          template = _b.template,
          directives = _b.directives,
          pipes = _b.pipes,
          encapsulation = _b.encapsulation,
          styles = _b.styles,
          styleUrls = _b.styleUrls,
          animations = _b.animations,
          interpolation = _b.interpolation;
      this.templateUrl = templateUrl;
      this.template = template;
      this.styleUrls = styleUrls;
      this.styles = styles;
      this.directives = directives;
      this.pipes = pipes;
      this.encapsulation = encapsulation;
      this.animations = animations;
      this.interpolation = interpolation;
    }
    return ViewMetadata;
  }());
  exports.ViewMetadata = ViewMetadata;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/profile/wtf_init.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function wtfInit() {}
  exports.wtfInit = wtfInit;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/reflection/reflector.js", ["../facade/collection", "../facade/exceptions", "../facade/lang", "./reflector_reader"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var collection_1 = $__require('../facade/collection');
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var reflector_reader_1 = $__require('./reflector_reader');
  var ReflectionInfo = (function() {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
      this.annotations = annotations;
      this.parameters = parameters;
      this.factory = factory;
      this.interfaces = interfaces;
      this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
  }());
  exports.ReflectionInfo = ReflectionInfo;
  var Reflector = (function(_super) {
    __extends(Reflector, _super);
    function Reflector(reflectionCapabilities) {
      _super.call(this);
      this._injectableInfo = new collection_1.Map();
      this._getters = new collection_1.Map();
      this._setters = new collection_1.Map();
      this._methods = new collection_1.Map();
      this._usedKeys = null;
      this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.updateCapabilities = function(caps) {
      this.reflectionCapabilities = caps;
    };
    Reflector.prototype.isReflectionEnabled = function() {
      return this.reflectionCapabilities.isReflectionEnabled();
    };
    Reflector.prototype.trackUsage = function() {
      this._usedKeys = new collection_1.Set();
    };
    Reflector.prototype.listUnusedKeys = function() {
      var _this = this;
      if (this._usedKeys == null) {
        throw new exceptions_1.BaseException('Usage tracking is disabled');
      }
      var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
      return allTypes.filter(function(key) {
        return !collection_1.SetWrapper.has(_this._usedKeys, key);
      });
    };
    Reflector.prototype.registerFunction = function(func, funcInfo) {
      this._injectableInfo.set(func, funcInfo);
    };
    Reflector.prototype.registerType = function(type, typeInfo) {
      this._injectableInfo.set(type, typeInfo);
    };
    Reflector.prototype.registerGetters = function(getters) {
      _mergeMaps(this._getters, getters);
    };
    Reflector.prototype.registerSetters = function(setters) {
      _mergeMaps(this._setters, setters);
    };
    Reflector.prototype.registerMethods = function(methods) {
      _mergeMaps(this._methods, methods);
    };
    Reflector.prototype.factory = function(type) {
      if (this._containsReflectionInfo(type)) {
        var res = this._getReflectionInfo(type).factory;
        return lang_1.isPresent(res) ? res : null;
      } else {
        return this.reflectionCapabilities.factory(type);
      }
    };
    Reflector.prototype.parameters = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).parameters;
        return lang_1.isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.parameters(typeOrFunc);
      }
    };
    Reflector.prototype.annotations = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).annotations;
        return lang_1.isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.annotations(typeOrFunc);
      }
    };
    Reflector.prototype.propMetadata = function(typeOrFunc) {
      if (this._injectableInfo.has(typeOrFunc)) {
        var res = this._getReflectionInfo(typeOrFunc).propMetadata;
        return lang_1.isPresent(res) ? res : {};
      } else {
        return this.reflectionCapabilities.propMetadata(typeOrFunc);
      }
    };
    Reflector.prototype.interfaces = function(type) {
      if (this._injectableInfo.has(type)) {
        var res = this._getReflectionInfo(type).interfaces;
        return lang_1.isPresent(res) ? res : [];
      } else {
        return this.reflectionCapabilities.interfaces(type);
      }
    };
    Reflector.prototype.hasLifecycleHook = function(type, lcInterface, lcProperty) {
      var interfaces = this.interfaces(type);
      if (interfaces.indexOf(lcInterface) !== -1) {
        return true;
      } else {
        return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);
      }
    };
    Reflector.prototype.getter = function(name) {
      if (this._getters.has(name)) {
        return this._getters.get(name);
      } else {
        return this.reflectionCapabilities.getter(name);
      }
    };
    Reflector.prototype.setter = function(name) {
      if (this._setters.has(name)) {
        return this._setters.get(name);
      } else {
        return this.reflectionCapabilities.setter(name);
      }
    };
    Reflector.prototype.method = function(name) {
      if (this._methods.has(name)) {
        return this._methods.get(name);
      } else {
        return this.reflectionCapabilities.method(name);
      }
    };
    Reflector.prototype._getReflectionInfo = function(typeOrFunc) {
      if (lang_1.isPresent(this._usedKeys)) {
        this._usedKeys.add(typeOrFunc);
      }
      return this._injectableInfo.get(typeOrFunc);
    };
    Reflector.prototype._containsReflectionInfo = function(typeOrFunc) {
      return this._injectableInfo.has(typeOrFunc);
    };
    Reflector.prototype.importUri = function(type) {
      return this.reflectionCapabilities.importUri(type);
    };
    return Reflector;
  }(reflector_reader_1.ReflectorReader));
  exports.Reflector = Reflector;
  function _mergeMaps(target, config) {
    collection_1.StringMapWrapper.forEach(config, function(v, k) {
      return target.set(k, v);
    });
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/reflection/reflection.js", ["./reflection_capabilities", "./reflector"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var reflection_capabilities_1 = $__require('./reflection_capabilities');
  var reflector_1 = $__require('./reflector');
  var reflector_2 = $__require('./reflector');
  exports.ReflectionInfo = reflector_2.ReflectionInfo;
  exports.Reflector = reflector_2.Reflector;
  exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/reflection/reflection_capabilities.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var ReflectionCapabilities = (function() {
    function ReflectionCapabilities(reflect) {
      this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function() {
      return true;
    };
    ReflectionCapabilities.prototype.factory = function(t) {
      switch (t.length) {
        case 0:
          return function() {
            return new t();
          };
        case 1:
          return function(a1) {
            return new t(a1);
          };
        case 2:
          return function(a1, a2) {
            return new t(a1, a2);
          };
        case 3:
          return function(a1, a2, a3) {
            return new t(a1, a2, a3);
          };
        case 4:
          return function(a1, a2, a3, a4) {
            return new t(a1, a2, a3, a4);
          };
        case 5:
          return function(a1, a2, a3, a4, a5) {
            return new t(a1, a2, a3, a4, a5);
          };
        case 6:
          return function(a1, a2, a3, a4, a5, a6) {
            return new t(a1, a2, a3, a4, a5, a6);
          };
        case 7:
          return function(a1, a2, a3, a4, a5, a6, a7) {
            return new t(a1, a2, a3, a4, a5, a6, a7);
          };
        case 8:
          return function(a1, a2, a3, a4, a5, a6, a7, a8) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8);
          };
        case 9:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          };
        case 10:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          };
        case 11:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          };
        case 12:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          };
        case 13:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
          };
        case 14:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
          };
        case 15:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          };
        case 16:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          };
        case 17:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
          };
        case 18:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
          };
        case 19:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
          };
        case 20:
          return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
            return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
          };
      }
      ;
      throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
    };
    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function(paramTypes, paramAnnotations) {
      var result;
      if (typeof paramTypes === 'undefined') {
        result = new Array(paramAnnotations.length);
      } else {
        result = new Array(paramTypes.length);
      }
      for (var i = 0; i < result.length; i++) {
        if (typeof paramTypes === 'undefined') {
          result[i] = [];
        } else if (paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    };
    ReflectionCapabilities.prototype.parameters = function(typeOrFunc) {
      if (lang_1.isPresent(typeOrFunc.parameters)) {
        return typeOrFunc.parameters;
      }
      if (lang_1.isPresent(typeOrFunc.ctorParameters)) {
        var ctorParameters = typeOrFunc.ctorParameters;
        var paramTypes_1 = ctorParameters.map(function(ctorParam) {
          return ctorParam && ctorParam.type;
        });
        var paramAnnotations_1 = ctorParameters.map(function(ctorParam) {
          return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
        });
        return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
      }
      if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
        var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
        var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
        if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
      }
      var parameters = new Array(typeOrFunc.length);
      parameters.fill(undefined);
      return parameters;
    };
    ReflectionCapabilities.prototype.annotations = function(typeOrFunc) {
      if (lang_1.isPresent(typeOrFunc.annotations)) {
        var annotations = typeOrFunc.annotations;
        if (lang_1.isFunction(annotations) && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (lang_1.isPresent(typeOrFunc.decorators)) {
        return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
      }
      if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
        var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
        if (lang_1.isPresent(annotations))
          return annotations;
      }
      return [];
    };
    ReflectionCapabilities.prototype.propMetadata = function(typeOrFunc) {
      if (lang_1.isPresent(typeOrFunc.propMetadata)) {
        var propMetadata = typeOrFunc.propMetadata;
        if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (lang_1.isPresent(typeOrFunc.propDecorators)) {
        var propDecorators_1 = typeOrFunc.propDecorators;
        var propMetadata_1 = {};
        Object.keys(propDecorators_1).forEach(function(prop) {
          propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
        });
        return propMetadata_1;
      }
      if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
        var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
        if (lang_1.isPresent(propMetadata))
          return propMetadata;
      }
      return {};
    };
    ReflectionCapabilities.prototype.interfaces = function(type) {
      return [];
    };
    ReflectionCapabilities.prototype.hasLifecycleHook = function(type, lcInterface, lcProperty) {
      if (!(type instanceof lang_1.Type))
        return false;
      var proto = type.prototype;
      return !!proto[lcProperty];
    };
    ReflectionCapabilities.prototype.getter = function(name) {
      return new Function('o', 'return o.' + name + ';');
    };
    ReflectionCapabilities.prototype.setter = function(name) {
      return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function(name) {
      var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
      return new Function('o', 'args', functionBody);
    };
    ReflectionCapabilities.prototype.importUri = function(type) {
      if (typeof type === 'object' && type['filePath']) {
        return type['filePath'];
      }
      return "./" + lang_1.stringify(type);
    };
    return ReflectionCapabilities;
  }());
  exports.ReflectionCapabilities = ReflectionCapabilities;
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map(function(decoratorInvocation) {
      var decoratorType = decoratorInvocation.type;
      var annotationCls = decoratorType.annotationCls;
      var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      var annotation = Object.create(annotationCls.prototype);
      annotationCls.apply(annotation, annotationArgs);
      return annotation;
    });
  }
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/reflection/reflector_reader.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var ReflectorReader = (function() {
    function ReflectorReader() {}
    return ReflectorReader;
  }());
  exports.ReflectorReader = ReflectorReader;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/render/api.js", ["../facade/exceptions"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var RenderComponentType = (function() {
    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
      this.id = id;
      this.templateUrl = templateUrl;
      this.slotCount = slotCount;
      this.encapsulation = encapsulation;
      this.styles = styles;
      this.animations = animations;
    }
    return RenderComponentType;
  }());
  exports.RenderComponentType = RenderComponentType;
  var RenderDebugInfo = (function() {
    function RenderDebugInfo() {}
    Object.defineProperty(RenderDebugInfo.prototype, "injector", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "component", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "references", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "context", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "source", {
      get: function() {
        return exceptions_1.unimplemented();
      },
      enumerable: true,
      configurable: true
    });
    return RenderDebugInfo;
  }());
  exports.RenderDebugInfo = RenderDebugInfo;
  var Renderer = (function() {
    function Renderer() {}
    return Renderer;
  }());
  exports.Renderer = Renderer;
  var RootRenderer = (function() {
    function RootRenderer() {}
    return RootRenderer;
  }());
  exports.RootRenderer = RootRenderer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/util/decorators.js", ["../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('../facade/lang');
  var _nextClassId = 0;
  function extractAnnotation(annotation) {
    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
      annotation = annotation.annotation;
    }
    return annotation;
  }
  function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
      throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
    }
    if (lang_1.isFunction(fnOrArray)) {
      return fnOrArray;
    } else if (fnOrArray instanceof Array) {
      var annotations = fnOrArray;
      var annoLength = annotations.length - 1;
      var fn = fnOrArray[annoLength];
      if (!lang_1.isFunction(fn)) {
        throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
      }
      if (annoLength != fn.length) {
        throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
      }
      var paramsAnnotations = [];
      for (var i = 0,
          ii = annotations.length - 1; i < ii; i++) {
        var paramAnnotations = [];
        paramsAnnotations.push(paramAnnotations);
        var annotation = annotations[i];
        if (annotation instanceof Array) {
          for (var j = 0; j < annotation.length; j++) {
            paramAnnotations.push(extractAnnotation(annotation[j]));
          }
        } else if (lang_1.isFunction(annotation)) {
          paramAnnotations.push(extractAnnotation(annotation));
        } else {
          paramAnnotations.push(annotation);
        }
      }
      Reflect.defineMetadata('parameters', paramsAnnotations, fn);
      return fn;
    } else {
      throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
    }
  }
  function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
      if (lang_1.isFunction(clsDef.extends)) {
        constructor.prototype = proto = Object.create(clsDef.extends.prototype);
      } else {
        throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
      }
    }
    for (var key in clsDef) {
      if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
        proto[key] = applyParams(clsDef[key], key);
      }
    }
    if (this && this.annotations instanceof Array) {
      Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    if (!constructor['name']) {
      constructor['overriddenName'] = "class" + _nextClassId++;
    }
    return constructor;
  }
  exports.Class = Class;
  var Reflect = lang_1.global.Reflect;
  (function checkReflect() {
    if (!(Reflect && Reflect.getMetadata)) {
      throw 'reflect-metadata shim is required when using class decorators';
    }
  })();
  function makeDecorator(annotationCls, chainFn) {
    if (chainFn === void 0) {
      chainFn = null;
    }
    function DecoratorFactory(objOrType) {
      var annotationInstance = new annotationCls(objOrType);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
        chainAnnotation.push(annotationInstance);
        var TypeDecorator = function TypeDecorator(cls) {
          var annotations = Reflect.getOwnMetadata('annotations', cls) || [];
          annotations.push(annotationInstance);
          Reflect.defineMetadata('annotations', annotations, cls);
          return cls;
        };
        TypeDecorator.annotations = chainAnnotation;
        TypeDecorator.Class = Class;
        if (chainFn)
          chainFn(TypeDecorator);
        return TypeDecorator;
      }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    DecoratorFactory.annotationCls = annotationCls;
    return DecoratorFactory;
  }
  exports.makeDecorator = makeDecorator;
  function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      var annotationInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(annotationInstance, args);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
      }
      function ParamDecorator(cls, unusedKey, index) {
        var parameters = Reflect.getMetadata('parameters', cls) || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = parameters[index] || [];
        var annotationsForParam = parameters[index];
        annotationsForParam.push(annotationInstance);
        Reflect.defineMetadata('parameters', parameters, cls);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    ParamDecoratorFactory.annotationCls = annotationCls;
    return ParamDecoratorFactory;
  }
  exports.makeParamDecorator = makeParamDecorator;
  function makePropDecorator(annotationCls) {
    function PropDecoratorFactory() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
      }
      var decoratorInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(decoratorInstance, args);
      if (this instanceof annotationCls) {
        return decoratorInstance;
      } else {
        return function PropDecorator(target, name) {
          var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
          meta[name] = meta[name] || [];
          meta[name].unshift(decoratorInstance);
          Reflect.defineMetadata('propMetadata', meta, target.constructor);
        };
      }
    }
    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    PropDecoratorFactory.annotationCls = annotationCls;
    return PropDecoratorFactory;
  }
  exports.makePropDecorator = makePropDecorator;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/private_export.js", ["./src/animation/animation_constants", "./src/animation/animation_group_player", "./src/animation/animation_keyframe", "./src/animation/animation_player", "./src/animation/animation_sequence_player", "./src/animation/animation_style_util", "./src/animation/animation_styles", "./src/change_detection/change_detection_util", "./src/change_detection/constants", "./src/console", "./src/debug/debug_renderer", "./src/di/provider_util", "./src/di/reflective_provider", "./src/linker/component_factory_resolver", "./src/linker/debug_context", "./src/linker/element", "./src/linker/ng_module_factory", "./src/linker/template_ref", "./src/linker/view", "./src/linker/view_type", "./src/linker/view_utils", "./src/metadata/lifecycle_hooks", "./src/metadata/view", "./src/profile/wtf_init", "./src/reflection/reflection", "./src/reflection/reflection_capabilities", "./src/reflection/reflector_reader", "./src/render/api", "./src/util/decorators"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var animation_constants_1 = $__require('./src/animation/animation_constants');
  var animation_group_player_1 = $__require('./src/animation/animation_group_player');
  var animation_keyframe_1 = $__require('./src/animation/animation_keyframe');
  var animation_player_1 = $__require('./src/animation/animation_player');
  var animation_sequence_player_1 = $__require('./src/animation/animation_sequence_player');
  var animationUtils = $__require('./src/animation/animation_style_util');
  var animation_styles_1 = $__require('./src/animation/animation_styles');
  var change_detection_util = $__require('./src/change_detection/change_detection_util');
  var constants = $__require('./src/change_detection/constants');
  var console = $__require('./src/console');
  var debug = $__require('./src/debug/debug_renderer');
  var provider_util = $__require('./src/di/provider_util');
  var reflective_provider = $__require('./src/di/reflective_provider');
  var component_factory_resolver = $__require('./src/linker/component_factory_resolver');
  var debug_context = $__require('./src/linker/debug_context');
  var element = $__require('./src/linker/element');
  var ng_module_factory = $__require('./src/linker/ng_module_factory');
  var template_ref = $__require('./src/linker/template_ref');
  var view = $__require('./src/linker/view');
  var view_type = $__require('./src/linker/view_type');
  var view_utils = $__require('./src/linker/view_utils');
  var lifecycle_hooks = $__require('./src/metadata/lifecycle_hooks');
  var metadata_view = $__require('./src/metadata/view');
  var wtf_init = $__require('./src/profile/wtf_init');
  var reflection = $__require('./src/reflection/reflection');
  var reflection_capabilities = $__require('./src/reflection/reflection_capabilities');
  var reflector_reader = $__require('./src/reflection/reflector_reader');
  var api = $__require('./src/render/api');
  var decorators = $__require('./src/util/decorators');
  exports.__core_private__ = {
    isDefaultChangeDetectionStrategy: constants.isDefaultChangeDetectionStrategy,
    ChangeDetectorStatus: constants.ChangeDetectorStatus,
    CHANGE_DETECTION_STRATEGY_VALUES: constants.CHANGE_DETECTION_STRATEGY_VALUES,
    constructDependencies: reflective_provider.constructDependencies,
    LifecycleHooks: lifecycle_hooks.LifecycleHooks,
    LIFECYCLE_HOOKS_VALUES: lifecycle_hooks.LIFECYCLE_HOOKS_VALUES,
    ReflectorReader: reflector_reader.ReflectorReader,
    CodegenComponentFactoryResolver: component_factory_resolver.CodegenComponentFactoryResolver,
    AppElement: element.AppElement,
    AppView: view.AppView,
    DebugAppView: view.DebugAppView,
    NgModuleInjector: ng_module_factory.NgModuleInjector,
    ViewType: view_type.ViewType,
    MAX_INTERPOLATION_VALUES: view_utils.MAX_INTERPOLATION_VALUES,
    checkBinding: view_utils.checkBinding,
    flattenNestedViewRenderNodes: view_utils.flattenNestedViewRenderNodes,
    interpolate: view_utils.interpolate,
    ViewUtils: view_utils.ViewUtils,
    VIEW_ENCAPSULATION_VALUES: metadata_view.VIEW_ENCAPSULATION_VALUES,
    DebugContext: debug_context.DebugContext,
    StaticNodeDebugInfo: debug_context.StaticNodeDebugInfo,
    devModeEqual: change_detection_util.devModeEqual,
    UNINITIALIZED: change_detection_util.UNINITIALIZED,
    ValueUnwrapper: change_detection_util.ValueUnwrapper,
    RenderDebugInfo: api.RenderDebugInfo,
    TemplateRef_: template_ref.TemplateRef_,
    wtfInit: wtf_init.wtfInit,
    ReflectionCapabilities: reflection_capabilities.ReflectionCapabilities,
    makeDecorator: decorators.makeDecorator,
    DebugDomRootRenderer: debug.DebugDomRootRenderer,
    createProvider: provider_util.createProvider,
    isProviderLiteral: provider_util.isProviderLiteral,
    EMPTY_ARRAY: view_utils.EMPTY_ARRAY,
    EMPTY_MAP: view_utils.EMPTY_MAP,
    pureProxy1: view_utils.pureProxy1,
    pureProxy2: view_utils.pureProxy2,
    pureProxy3: view_utils.pureProxy3,
    pureProxy4: view_utils.pureProxy4,
    pureProxy5: view_utils.pureProxy5,
    pureProxy6: view_utils.pureProxy6,
    pureProxy7: view_utils.pureProxy7,
    pureProxy8: view_utils.pureProxy8,
    pureProxy9: view_utils.pureProxy9,
    pureProxy10: view_utils.pureProxy10,
    castByValue: view_utils.castByValue,
    Console: console.Console,
    reflector: reflection.reflector,
    Reflector: reflection.Reflector,
    NoOpAnimationPlayer: animation_player_1.NoOpAnimationPlayer,
    AnimationPlayer: animation_player_1.AnimationPlayer,
    AnimationSequencePlayer: animation_sequence_player_1.AnimationSequencePlayer,
    AnimationGroupPlayer: animation_group_player_1.AnimationGroupPlayer,
    AnimationKeyframe: animation_keyframe_1.AnimationKeyframe,
    prepareFinalAnimationStyles: animationUtils.prepareFinalAnimationStyles,
    balanceAnimationKeyframes: animationUtils.balanceAnimationKeyframes,
    flattenStyles: animationUtils.flattenStyles,
    clearStyles: animationUtils.clearStyles,
    renderStyles: animationUtils.renderStyles,
    collectAndResolveStyles: animationUtils.collectAndResolveStyles,
    AnimationStyles: animation_styles_1.AnimationStyles,
    ANY_STATE: animation_constants_1.ANY_STATE,
    DEFAULT_STATE: animation_constants_1.DEFAULT_STATE,
    EMPTY_STATE: animation_constants_1.EMPTY_STATE,
    FILL_STYLE_FLAG: animation_constants_1.FILL_STYLE_FLAG
  };
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/metadata.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  exports.AUTO_STYLE = '*';
  var AnimationEntryMetadata = (function() {
    function AnimationEntryMetadata(name, definitions) {
      this.name = name;
      this.definitions = definitions;
    }
    return AnimationEntryMetadata;
  }());
  exports.AnimationEntryMetadata = AnimationEntryMetadata;
  var AnimationStateMetadata = (function() {
    function AnimationStateMetadata() {}
    return AnimationStateMetadata;
  }());
  exports.AnimationStateMetadata = AnimationStateMetadata;
  var AnimationStateDeclarationMetadata = (function(_super) {
    __extends(AnimationStateDeclarationMetadata, _super);
    function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
      _super.call(this);
      this.stateNameExpr = stateNameExpr;
      this.styles = styles;
    }
    return AnimationStateDeclarationMetadata;
  }(AnimationStateMetadata));
  exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
  var AnimationStateTransitionMetadata = (function(_super) {
    __extends(AnimationStateTransitionMetadata, _super);
    function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
      _super.call(this);
      this.stateChangeExpr = stateChangeExpr;
      this.steps = steps;
    }
    return AnimationStateTransitionMetadata;
  }(AnimationStateMetadata));
  exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
  var AnimationMetadata = (function() {
    function AnimationMetadata() {}
    return AnimationMetadata;
  }());
  exports.AnimationMetadata = AnimationMetadata;
  var AnimationKeyframesSequenceMetadata = (function(_super) {
    __extends(AnimationKeyframesSequenceMetadata, _super);
    function AnimationKeyframesSequenceMetadata(steps) {
      _super.call(this);
      this.steps = steps;
    }
    return AnimationKeyframesSequenceMetadata;
  }(AnimationMetadata));
  exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
  var AnimationStyleMetadata = (function(_super) {
    __extends(AnimationStyleMetadata, _super);
    function AnimationStyleMetadata(styles, offset) {
      if (offset === void 0) {
        offset = null;
      }
      _super.call(this);
      this.styles = styles;
      this.offset = offset;
    }
    return AnimationStyleMetadata;
  }(AnimationMetadata));
  exports.AnimationStyleMetadata = AnimationStyleMetadata;
  var AnimationAnimateMetadata = (function(_super) {
    __extends(AnimationAnimateMetadata, _super);
    function AnimationAnimateMetadata(timings, styles) {
      _super.call(this);
      this.timings = timings;
      this.styles = styles;
    }
    return AnimationAnimateMetadata;
  }(AnimationMetadata));
  exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
  var AnimationWithStepsMetadata = (function(_super) {
    __extends(AnimationWithStepsMetadata, _super);
    function AnimationWithStepsMetadata() {
      _super.call(this);
    }
    Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
      get: function() {
        throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class');
      },
      enumerable: true,
      configurable: true
    });
    return AnimationWithStepsMetadata;
  }(AnimationMetadata));
  exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
  var AnimationSequenceMetadata = (function(_super) {
    __extends(AnimationSequenceMetadata, _super);
    function AnimationSequenceMetadata(_steps) {
      _super.call(this);
      this._steps = _steps;
    }
    Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
      get: function() {
        return this._steps;
      },
      enumerable: true,
      configurable: true
    });
    return AnimationSequenceMetadata;
  }(AnimationWithStepsMetadata));
  exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
  var AnimationGroupMetadata = (function(_super) {
    __extends(AnimationGroupMetadata, _super);
    function AnimationGroupMetadata(_steps) {
      _super.call(this);
      this._steps = _steps;
    }
    Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
      get: function() {
        return this._steps;
      },
      enumerable: true,
      configurable: true
    });
    return AnimationGroupMetadata;
  }(AnimationWithStepsMetadata));
  exports.AnimationGroupMetadata = AnimationGroupMetadata;
  function animate(timing, styles) {
    if (styles === void 0) {
      styles = null;
    }
    var stylesEntry = styles;
    if (!lang_1.isPresent(stylesEntry)) {
      var EMPTY_STYLE = {};
      stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
    }
    return new AnimationAnimateMetadata(timing, stylesEntry);
  }
  exports.animate = animate;
  function group(steps) {
    return new AnimationGroupMetadata(steps);
  }
  exports.group = group;
  function sequence(steps) {
    return new AnimationSequenceMetadata(steps);
  }
  exports.sequence = sequence;
  function style(tokens) {
    var input;
    var offset = null;
    if (lang_1.isString(tokens)) {
      input = [tokens];
    } else {
      if (lang_1.isArray(tokens)) {
        input = tokens;
      } else {
        input = [tokens];
      }
      input.forEach(function(entry) {
        var entryOffset = entry['offset'];
        if (lang_1.isPresent(entryOffset)) {
          offset = offset == null ? lang_1.NumberWrapper.parseFloat(entryOffset) : offset;
        }
      });
    }
    return new AnimationStyleMetadata(input, offset);
  }
  exports.style = style;
  function state(stateNameExpr, styles) {
    return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
  }
  exports.state = state;
  function keyframes(steps) {
    return new AnimationKeyframesSequenceMetadata(steps);
  }
  exports.keyframes = keyframes;
  function transition(stateChangeExpr, steps) {
    var animationData = lang_1.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
    return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
  }
  exports.transition = transition;
  function trigger(name, animation) {
    return new AnimationEntryMetadata(name, animation);
  }
  exports.trigger = trigger;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/base_wrapped_exception.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BaseWrappedException = (function(_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
      _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
      get: function() {
        return '';
      },
      enumerable: true,
      configurable: true
    });
    return BaseWrappedException;
  }(Error));
  exports.BaseWrappedException = BaseWrappedException;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/collection.js", ["./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var lang_1 = $__require('./lang');
  exports.Map = lang_1.global.Map;
  exports.Set = lang_1.global.Set;
  var createMapFromPairs = (function() {
    try {
      if (new exports.Map([[1, 2]]).size === 1) {
        return function createMapFromPairs(pairs) {
          return new exports.Map(pairs);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromPairs(pairs) {
      var map = new exports.Map();
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        map.set(pair[0], pair[1]);
      }
      return map;
    };
  })();
  var createMapFromMap = (function() {
    try {
      if (new exports.Map(new exports.Map())) {
        return function createMapFromMap(m) {
          return new exports.Map(m);
        };
      }
    } catch (e) {}
    return function createMapAndPopulateFromMap(m) {
      var map = new exports.Map();
      m.forEach(function(v, k) {
        map.set(k, v);
      });
      return map;
    };
  })();
  var _clearValues = (function() {
    if ((new exports.Map()).keys().next) {
      return function _clearValues(m) {
        var keyIterator = m.keys();
        var k;
        while (!((k = keyIterator.next()).done)) {
          m.set(k.value, null);
        }
      };
    } else {
      return function _clearValuesWithForeEach(m) {
        m.forEach(function(v, k) {
          m.set(k, null);
        });
      };
    }
  })();
  var _arrayFromMap = (function() {
    try {
      if ((new exports.Map()).values().next) {
        return function createArrayFromMap(m, getValues) {
          return getValues ? Array.from(m.values()) : Array.from(m.keys());
        };
      }
    } catch (e) {}
    return function createArrayFromMapWithForeach(m, getValues) {
      var res = ListWrapper.createFixedSize(m.size),
          i = 0;
      m.forEach(function(v, k) {
        res[i] = getValues ? v : k;
        i++;
      });
      return res;
    };
  })();
  var MapWrapper = (function() {
    function MapWrapper() {}
    MapWrapper.clone = function(m) {
      return createMapFromMap(m);
    };
    MapWrapper.createFromStringMap = function(stringMap) {
      var result = new exports.Map();
      for (var prop in stringMap) {
        result.set(prop, stringMap[prop]);
      }
      return result;
    };
    MapWrapper.toStringMap = function(m) {
      var r = {};
      m.forEach(function(v, k) {
        return r[k] = v;
      });
      return r;
    };
    MapWrapper.createFromPairs = function(pairs) {
      return createMapFromPairs(pairs);
    };
    MapWrapper.clearValues = function(m) {
      _clearValues(m);
    };
    MapWrapper.iterable = function(m) {
      return m;
    };
    MapWrapper.keys = function(m) {
      return _arrayFromMap(m, false);
    };
    MapWrapper.values = function(m) {
      return _arrayFromMap(m, true);
    };
    return MapWrapper;
  }());
  exports.MapWrapper = MapWrapper;
  var StringMapWrapper = (function() {
    function StringMapWrapper() {}
    StringMapWrapper.create = function() {
      return {};
    };
    StringMapWrapper.contains = function(map, key) {
      return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function(map, key) {
      return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function(map, key, value) {
      map[key] = value;
    };
    StringMapWrapper.keys = function(map) {
      return Object.keys(map);
    };
    StringMapWrapper.values = function(map) {
      return Object.keys(map).map(function(k) {
        return map[k];
      });
    };
    StringMapWrapper.isEmpty = function(map) {
      for (var prop in map) {
        return false;
      }
      return true;
    };
    StringMapWrapper.delete = function(map, key) {
      delete map[key];
    };
    StringMapWrapper.forEach = function(map, callback) {
      for (var _i = 0,
          _a = Object.keys(map); _i < _a.length; _i++) {
        var k = _a[_i];
        callback(map[k], k);
      }
    };
    StringMapWrapper.merge = function(m1, m2) {
      var m = {};
      for (var _i = 0,
          _a = Object.keys(m1); _i < _a.length; _i++) {
        var k = _a[_i];
        m[k] = m1[k];
      }
      for (var _b = 0,
          _c = Object.keys(m2); _b < _c.length; _b++) {
        var k = _c[_b];
        m[k] = m2[k];
      }
      return m;
    };
    StringMapWrapper.equals = function(m1, m2) {
      var k1 = Object.keys(m1);
      var k2 = Object.keys(m2);
      if (k1.length != k2.length) {
        return false;
      }
      var key;
      for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (m1[key] !== m2[key]) {
          return false;
        }
      }
      return true;
    };
    return StringMapWrapper;
  }());
  exports.StringMapWrapper = StringMapWrapper;
  var ListWrapper = (function() {
    function ListWrapper() {}
    ListWrapper.createFixedSize = function(size) {
      return new Array(size);
    };
    ListWrapper.createGrowableSize = function(size) {
      return new Array(size);
    };
    ListWrapper.clone = function(array) {
      return array.slice(0);
    };
    ListWrapper.forEachWithIndex = function(array, fn) {
      for (var i = 0; i < array.length; i++) {
        fn(array[i], i);
      }
    };
    ListWrapper.first = function(array) {
      if (!array)
        return null;
      return array[0];
    };
    ListWrapper.last = function(array) {
      if (!array || array.length == 0)
        return null;
      return array[array.length - 1];
    };
    ListWrapper.indexOf = function(array, value, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function(list, el) {
      return list.indexOf(el) !== -1;
    };
    ListWrapper.reversed = function(array) {
      var a = ListWrapper.clone(array);
      return a.reverse();
    };
    ListWrapper.concat = function(a, b) {
      return a.concat(b);
    };
    ListWrapper.insert = function(list, index, value) {
      list.splice(index, 0, value);
    };
    ListWrapper.removeAt = function(list, index) {
      var res = list[index];
      list.splice(index, 1);
      return res;
    };
    ListWrapper.removeAll = function(list, items) {
      for (var i = 0; i < items.length; ++i) {
        var index = list.indexOf(items[i]);
        list.splice(index, 1);
      }
    };
    ListWrapper.remove = function(list, el) {
      var index = list.indexOf(el);
      if (index > -1) {
        list.splice(index, 1);
        return true;
      }
      return false;
    };
    ListWrapper.clear = function(list) {
      list.length = 0;
    };
    ListWrapper.isEmpty = function(list) {
      return list.length == 0;
    };
    ListWrapper.fill = function(list, value, start, end) {
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = null;
      }
      list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    };
    ListWrapper.slice = function(l, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function(l, from, length) {
      return l.splice(from, length);
    };
    ListWrapper.sort = function(l, compareFn) {
      if (lang_1.isPresent(compareFn)) {
        l.sort(compareFn);
      } else {
        l.sort();
      }
    };
    ListWrapper.toString = function(l) {
      return l.toString();
    };
    ListWrapper.toJSON = function(l) {
      return JSON.stringify(l);
    };
    ListWrapper.maximum = function(list, predicate) {
      if (list.length == 0) {
        return null;
      }
      var solution = null;
      var maxValue = -Infinity;
      for (var index = 0; index < list.length; index++) {
        var candidate = list[index];
        if (lang_1.isBlank(candidate)) {
          continue;
        }
        var candidateValue = predicate(candidate);
        if (candidateValue > maxValue) {
          solution = candidate;
          maxValue = candidateValue;
        }
      }
      return solution;
    };
    ListWrapper.flatten = function(list) {
      var target = [];
      _flattenArray(list, target);
      return target;
    };
    ListWrapper.addAll = function(list, source) {
      for (var i = 0; i < source.length; i++) {
        list.push(source[i]);
      }
    };
    return ListWrapper;
  }());
  exports.ListWrapper = ListWrapper;
  function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
      for (var i = 0; i < source.length; i++) {
        var item = source[i];
        if (lang_1.isArray(item)) {
          _flattenArray(item, target);
        } else {
          target.push(item);
        }
      }
    }
    return target;
  }
  function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
      return false;
    return lang_1.isArray(obj) || (!(obj instanceof exports.Map) && lang_1.getSymbolIterator() in obj);
  }
  exports.isListLikeIterable = isListLikeIterable;
  function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
      var item1 = iterator1.next();
      var item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  exports.areIterablesEqual = areIterablesEqual;
  function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[lang_1.getSymbolIterator()]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  exports.iterateListLike = iterateListLike;
  var createSetFromList = (function() {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
      return function createSetFromList(lst) {
        return new exports.Set(lst);
      };
    } else {
      return function createSetAndPopulateFromList(lst) {
        var res = new exports.Set(lst);
        if (res.size !== lst.length) {
          for (var i = 0; i < lst.length; i++) {
            res.add(lst[i]);
          }
        }
        return res;
      };
    }
  })();
  var SetWrapper = (function() {
    function SetWrapper() {}
    SetWrapper.createFromList = function(lst) {
      return createSetFromList(lst);
    };
    SetWrapper.has = function(s, key) {
      return s.has(key);
    };
    SetWrapper.delete = function(m, k) {
      m.delete(k);
    };
    return SetWrapper;
  }());
  exports.SetWrapper = SetWrapper;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/exception_handler.js", ["./base_wrapped_exception", "./collection", "./lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var collection_1 = $__require('./collection');
  var lang_1 = $__require('./lang');
  var _ArrayLogger = (function() {
    function _ArrayLogger() {
      this.res = [];
    }
    _ArrayLogger.prototype.log = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logError = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroup = function(s) {
      this.res.push(s);
    };
    _ArrayLogger.prototype.logGroupEnd = function() {};
    ;
    return _ArrayLogger;
  }());
  var ExceptionHandler = (function() {
    function ExceptionHandler(_logger, _rethrowException) {
      if (_rethrowException === void 0) {
        _rethrowException = true;
      }
      this._logger = _logger;
      this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var l = new _ArrayLogger();
      var e = new ExceptionHandler(l, false);
      e.call(exception, stackTrace, reason);
      return l.res.join('\n');
    };
    ExceptionHandler.prototype.call = function(exception, stackTrace, reason) {
      if (stackTrace === void 0) {
        stackTrace = null;
      }
      if (reason === void 0) {
        reason = null;
      }
      var originalException = this._findOriginalException(exception);
      var originalStack = this._findOriginalStack(exception);
      var context = this._findContext(exception);
      this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
      if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
        this._logger.logError('STACKTRACE:');
        this._logger.logError(this._longStackTrace(stackTrace));
      }
      if (lang_1.isPresent(reason)) {
        this._logger.logError("REASON: " + reason);
      }
      if (lang_1.isPresent(originalException)) {
        this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
      }
      if (lang_1.isPresent(originalStack)) {
        this._logger.logError('ORIGINAL STACKTRACE:');
        this._logger.logError(this._longStackTrace(originalStack));
      }
      if (lang_1.isPresent(context)) {
        this._logger.logError('ERROR CONTEXT:');
        this._logger.logError(context);
      }
      this._logger.logGroupEnd();
      if (this._rethrowException)
        throw exception;
    };
    ExceptionHandler.prototype._extractMessage = function(exception) {
      return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage : exception.toString();
    };
    ExceptionHandler.prototype._longStackTrace = function(stackTrace) {
      return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
    };
    ExceptionHandler.prototype._findContext = function(exception) {
      try {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
          return null;
        return lang_1.isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
      } catch (e) {
        return null;
      }
    };
    ExceptionHandler.prototype._findOriginalException = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception.originalException;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
      }
      return e;
    };
    ExceptionHandler.prototype._findOriginalStack = function(exception) {
      if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
        return null;
      var e = exception;
      var stack = exception.originalStack;
      while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
        e = e.originalException;
        if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
          stack = e.originalStack;
        }
      }
      return stack;
    };
    return ExceptionHandler;
  }());
  exports.ExceptionHandler = ExceptionHandler;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/exceptions.js", ["./base_wrapped_exception", "./exception_handler"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var base_wrapped_exception_1 = $__require('./base_wrapped_exception');
  var exception_handler_1 = $__require('./exception_handler');
  var exception_handler_2 = $__require('./exception_handler');
  exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
  var BaseException = (function(_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
      if (message === void 0) {
        message = '--';
      }
      _super.call(this, message);
      this.message = message;
      this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function() {
      return this.message;
    };
    return BaseException;
  }(Error));
  exports.BaseException = BaseException;
  var WrappedException = (function(_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
      _super.call(this, _wrapperMessage);
      this._wrapperMessage = _wrapperMessage;
      this._originalException = _originalException;
      this._originalStack = _originalStack;
      this._context = _context;
      this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
      get: function() {
        return this._wrapperMessage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
      get: function() {
        return this._wrapperStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
      get: function() {
        return this._originalException;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
      get: function() {
        return this._originalStack;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
      get: function() {
        return this._context;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
      get: function() {
        return exception_handler_1.ExceptionHandler.exceptionToString(this);
      },
      enumerable: true,
      configurable: true
    });
    WrappedException.prototype.toString = function() {
      return this.message;
    };
    return WrappedException;
  }(base_wrapped_exception_1.BaseWrappedException));
  exports.WrappedException = WrappedException;
  function makeTypeError(message) {
    return new TypeError(message);
  }
  exports.makeTypeError = makeTypeError;
  function unimplemented() {
    throw new BaseException('unimplemented');
  }
  exports.unimplemented = unimplemented;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/facade/lang.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  exports.scheduleMicroTask = scheduleMicroTask;
  var _global = globalScope;
  exports.global = _global;
  exports.Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  exports.getTypeNameForDebugging = getTypeNameForDebugging;
  exports.Math = _global.Math;
  exports.Date = _global.Date;
  _global.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  exports.isPresent = isPresent;
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  exports.isBlank = isBlank;
  function isBoolean(obj) {
    return typeof obj === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  exports.isNumber = isNumber;
  function isString(obj) {
    return typeof obj === 'string';
  }
  exports.isString = isString;
  function isFunction(obj) {
    return typeof obj === 'function';
  }
  exports.isFunction = isFunction;
  function isType(obj) {
    return isFunction(obj);
  }
  exports.isType = isType;
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  exports.isStringMap = isStringMap;
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  exports.isStrictStringMap = isStrictStringMap;
  function isPromise(obj) {
    return isPresent(obj) && isFunction(obj.then);
  }
  exports.isPromise = isPromise;
  function isArray(obj) {
    return Array.isArray(obj);
  }
  exports.isArray = isArray;
  function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
  }
  exports.isDate = isDate;
  function noop() {}
  exports.noop = noop;
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf('\n');
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  exports.stringify = stringify;
  function serializeEnum(val) {
    return val;
  }
  exports.serializeEnum = serializeEnum;
  function deserializeEnum(val, values) {
    return val;
  }
  exports.deserializeEnum = deserializeEnum;
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  exports.resolveEnumToken = resolveEnumToken;
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  exports.StringWrapper = StringWrapper;
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join('');
    };
    return StringJoiner;
  }());
  exports.StringJoiner = StringJoiner;
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  exports.NumberParseError = NumberParseError;
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError('Invalid integer literal when parsing ' + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNumeric = function(value) {
      return !isNaN(value - parseFloat(value));
    };
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  exports.NumberWrapper = NumberWrapper;
  exports.RegExp = _global.RegExp;
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    FunctionWrapper.bind = function(fn, scope) {
      return fn.bind(scope);
    };
    return FunctionWrapper;
  }());
  exports.FunctionWrapper = FunctionWrapper;
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  exports.looseIdentical = looseIdentical;
  function getMapKey(value) {
    return value;
  }
  exports.getMapKey = getMapKey;
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  exports.normalizeBlank = normalizeBlank;
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  exports.normalizeBool = normalizeBool;
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  exports.isJsObject = isJsObject;
  function print(obj) {
    console.log(obj);
  }
  exports.print = print;
  function warn(obj) {
    console.warn(obj);
  }
  exports.warn = warn;
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return _global.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return _global.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  exports.Json = Json;
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new exports.Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new exports.Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new exports.Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  exports.DateWrapper = DateWrapper;
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  exports.setValueOnPath = setValueOnPath;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  exports.evalExpression = evalExpression;
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  exports.isPrimitive = isPrimitive;
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  exports.hasConstructor = hasConstructor;
  function escape(s) {
    return _global.encodeURI(s);
  }
  exports.escape = escape;
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  exports.escapeRegExp = escapeRegExp;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/animation/animation_player.js", ["../facade/exceptions", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var exceptions_1 = $__require('../facade/exceptions');
  var lang_1 = $__require('../facade/lang');
  var AnimationPlayer = (function() {
    function AnimationPlayer() {}
    Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
      get: function() {
        throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class');
      },
      set: function(player) {
        throw new exceptions_1.BaseException('NOT IMPLEMENTED: Base Class');
      },
      enumerable: true,
      configurable: true
    });
    return AnimationPlayer;
  }());
  exports.AnimationPlayer = AnimationPlayer;
  var NoOpAnimationPlayer = (function() {
    function NoOpAnimationPlayer() {
      var _this = this;
      this._subscriptions = [];
      this._started = false;
      this.parentPlayer = null;
      lang_1.scheduleMicroTask(function() {
        return _this._onFinish();
      });
    }
    NoOpAnimationPlayer.prototype._onFinish = function() {
      this._subscriptions.forEach(function(entry) {
        entry();
      });
      this._subscriptions = [];
    };
    NoOpAnimationPlayer.prototype.onDone = function(fn) {
      this._subscriptions.push(fn);
    };
    NoOpAnimationPlayer.prototype.hasStarted = function() {
      return this._started;
    };
    NoOpAnimationPlayer.prototype.init = function() {};
    NoOpAnimationPlayer.prototype.play = function() {
      this._started = true;
    };
    NoOpAnimationPlayer.prototype.pause = function() {};
    NoOpAnimationPlayer.prototype.restart = function() {};
    NoOpAnimationPlayer.prototype.finish = function() {
      this._onFinish();
    };
    NoOpAnimationPlayer.prototype.destroy = function() {};
    NoOpAnimationPlayer.prototype.reset = function() {};
    NoOpAnimationPlayer.prototype.setPosition = function(p) {};
    NoOpAnimationPlayer.prototype.getPosition = function() {
      return 0;
    };
    return NoOpAnimationPlayer;
  }());
  exports.NoOpAnimationPlayer = NoOpAnimationPlayer;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/src/security.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  (function(SecurityContext) {
    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext[SecurityContext["URL"] = 4] = "URL";
    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(exports.SecurityContext || (exports.SecurityContext = {}));
  var SecurityContext = exports.SecurityContext;
  var SanitizationService = (function() {
    function SanitizationService() {}
    return SanitizationService;
  }());
  exports.SanitizationService = SanitizationService;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/core/index.js", ["./src/metadata", "./src/util", "./src/di", "./src/application_ref", "./src/application_tokens", "./src/application_init", "./src/zone", "./src/render", "./src/linker", "./src/debug/debug_node", "./src/testability/testability", "./src/change_detection", "./src/platform_directives_and_pipes", "./src/platform_core_providers", "./src/application_module", "./src/profile/profile", "./src/facade/lang", "./src/facade/async", "./src/facade/exceptions", "./private_export", "./src/animation/metadata", "./src/animation/animation_player", "./src/security"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  __export($__require('./src/metadata'));
  __export($__require('./src/util'));
  __export($__require('./src/di'));
  var application_ref_1 = $__require('./src/application_ref');
  exports.createPlatform = application_ref_1.createPlatform;
  exports.assertPlatform = application_ref_1.assertPlatform;
  exports.disposePlatform = application_ref_1.disposePlatform;
  exports.getPlatform = application_ref_1.getPlatform;
  exports.coreBootstrap = application_ref_1.coreBootstrap;
  exports.coreLoadAndBootstrap = application_ref_1.coreLoadAndBootstrap;
  exports.PlatformRef = application_ref_1.PlatformRef;
  exports.ApplicationRef = application_ref_1.ApplicationRef;
  exports.enableProdMode = application_ref_1.enableProdMode;
  exports.lockRunMode = application_ref_1.lockRunMode;
  exports.isDevMode = application_ref_1.isDevMode;
  exports.createPlatformFactory = application_ref_1.createPlatformFactory;
  var application_tokens_1 = $__require('./src/application_tokens');
  exports.APP_ID = application_tokens_1.APP_ID;
  exports.PACKAGE_ROOT_URL = application_tokens_1.PACKAGE_ROOT_URL;
  exports.PLATFORM_INITIALIZER = application_tokens_1.PLATFORM_INITIALIZER;
  exports.APP_BOOTSTRAP_LISTENER = application_tokens_1.APP_BOOTSTRAP_LISTENER;
  var application_init_1 = $__require('./src/application_init');
  exports.APP_INITIALIZER = application_init_1.APP_INITIALIZER;
  exports.ApplicationInitStatus = application_init_1.ApplicationInitStatus;
  __export($__require('./src/zone'));
  __export($__require('./src/render'));
  __export($__require('./src/linker'));
  var debug_node_1 = $__require('./src/debug/debug_node');
  exports.DebugElement = debug_node_1.DebugElement;
  exports.DebugNode = debug_node_1.DebugNode;
  exports.asNativeElements = debug_node_1.asNativeElements;
  exports.getDebugNode = debug_node_1.getDebugNode;
  __export($__require('./src/testability/testability'));
  __export($__require('./src/change_detection'));
  __export($__require('./src/platform_directives_and_pipes'));
  __export($__require('./src/platform_core_providers'));
  var application_module_1 = $__require('./src/application_module');
  exports.APPLICATION_COMMON_PROVIDERS = application_module_1.APPLICATION_COMMON_PROVIDERS;
  exports.ApplicationModule = application_module_1.ApplicationModule;
  var profile_1 = $__require('./src/profile/profile');
  exports.wtfCreateScope = profile_1.wtfCreateScope;
  exports.wtfLeave = profile_1.wtfLeave;
  exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
  exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;
  var lang_1 = $__require('./src/facade/lang');
  exports.Type = lang_1.Type;
  var async_1 = $__require('./src/facade/async');
  exports.EventEmitter = async_1.EventEmitter;
  var exceptions_1 = $__require('./src/facade/exceptions');
  exports.ExceptionHandler = exceptions_1.ExceptionHandler;
  exports.WrappedException = exceptions_1.WrappedException;
  exports.BaseException = exceptions_1.BaseException;
  __export($__require('./private_export'));
  __export($__require('./src/animation/metadata'));
  var animation_player_1 = $__require('./src/animation/animation_player');
  exports.AnimationPlayer = animation_player_1.AnimationPlayer;
  var security_1 = $__require('./src/security');
  exports.SanitizationService = security_1.SanitizationService;
  exports.SecurityContext = security_1.SecurityContext;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/facade/lang.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var globalScope;
  if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      globalScope = self;
    } else {
      globalScope = global;
    }
  } else {
    globalScope = window;
  }
  function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
  }
  exports.scheduleMicroTask = scheduleMicroTask;
  var _global = globalScope;
  exports.global = _global;
  exports.Type = Function;
  function getTypeNameForDebugging(type) {
    if (type['name']) {
      return type['name'];
    }
    return typeof type;
  }
  exports.getTypeNameForDebugging = getTypeNameForDebugging;
  exports.Math = _global.Math;
  exports.Date = _global.Date;
  _global.assert = function assert(condition) {};
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  exports.isPresent = isPresent;
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  exports.isBlank = isBlank;
  function isBoolean(obj) {
    return typeof obj === 'boolean';
  }
  exports.isBoolean = isBoolean;
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  exports.isNumber = isNumber;
  function isString(obj) {
    return typeof obj === 'string';
  }
  exports.isString = isString;
  function isFunction(obj) {
    return typeof obj === 'function';
  }
  exports.isFunction = isFunction;
  function isType(obj) {
    return isFunction(obj);
  }
  exports.isType = isType;
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  exports.isStringMap = isStringMap;
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  exports.isStrictStringMap = isStrictStringMap;
  function isPromise(obj) {
    return isPresent(obj) && isFunction(obj.then);
  }
  exports.isPromise = isPromise;
  function isArray(obj) {
    return Array.isArray(obj);
  }
  exports.isArray = isArray;
  function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
  }
  exports.isDate = isDate;
  function noop() {}
  exports.noop = noop;
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return token.overriddenName;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf('\n');
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  exports.stringify = stringify;
  function serializeEnum(val) {
    return val;
  }
  exports.serializeEnum = serializeEnum;
  function deserializeEnum(val, values) {
    return val;
  }
  exports.deserializeEnum = deserializeEnum;
  function resolveEnumToken(enumValue, val) {
    return enumValue[val];
  }
  exports.resolveEnumToken = resolveEnumToken;
  var StringWrapper = (function() {
    function StringWrapper() {}
    StringWrapper.fromCharCode = function(code) {
      return String.fromCharCode(code);
    };
    StringWrapper.charCodeAt = function(s, index) {
      return s.charCodeAt(index);
    };
    StringWrapper.split = function(s, regExp) {
      return s.split(regExp);
    };
    StringWrapper.equals = function(s, s2) {
      return s === s2;
    };
    StringWrapper.stripLeft = function(s, charVal) {
      if (s && s.length) {
        var pos = 0;
        for (var i = 0; i < s.length; i++) {
          if (s[i] != charVal)
            break;
          pos++;
        }
        s = s.substring(pos);
      }
      return s;
    };
    StringWrapper.stripRight = function(s, charVal) {
      if (s && s.length) {
        var pos = s.length;
        for (var i = s.length - 1; i >= 0; i--) {
          if (s[i] != charVal)
            break;
          pos--;
        }
        s = s.substring(0, pos);
      }
      return s;
    };
    StringWrapper.replace = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function(s, from, replace) {
      return s.replace(from, replace);
    };
    StringWrapper.slice = function(s, from, to) {
      if (from === void 0) {
        from = 0;
      }
      if (to === void 0) {
        to = null;
      }
      return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function(s, from, cb) {
      return s.replace(from, function() {
        var matches = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          matches[_i - 0] = arguments[_i];
        }
        matches.splice(-2, 2);
        return cb(matches);
      });
    };
    StringWrapper.contains = function(s, substr) {
      return s.indexOf(substr) != -1;
    };
    StringWrapper.compare = function(a, b) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    };
    return StringWrapper;
  }());
  exports.StringWrapper = StringWrapper;
  var StringJoiner = (function() {
    function StringJoiner(parts) {
      if (parts === void 0) {
        parts = [];
      }
      this.parts = parts;
    }
    StringJoiner.prototype.add = function(part) {
      this.parts.push(part);
    };
    StringJoiner.prototype.toString = function() {
      return this.parts.join('');
    };
    return StringJoiner;
  }());
  exports.StringJoiner = StringJoiner;
  var NumberParseError = (function(_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
      _super.call(this);
      this.message = message;
    }
    NumberParseError.prototype.toString = function() {
      return this.message;
    };
    return NumberParseError;
  }(Error));
  exports.NumberParseError = NumberParseError;
  var NumberWrapper = (function() {
    function NumberWrapper() {}
    NumberWrapper.toFixed = function(n, fractionDigits) {
      return n.toFixed(fractionDigits);
    };
    NumberWrapper.equal = function(a, b) {
      return a === b;
    };
    NumberWrapper.parseIntAutoRadix = function(text) {
      var result = parseInt(text);
      if (isNaN(result)) {
        throw new NumberParseError('Invalid integer literal when parsing ' + text);
      }
      return result;
    };
    NumberWrapper.parseInt = function(text, radix) {
      if (radix == 10) {
        if (/^(\-|\+)?[0-9]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else if (radix == 16) {
        if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
          return parseInt(text, radix);
        }
      } else {
        var result = parseInt(text, radix);
        if (!isNaN(result)) {
          return result;
        }
      }
      throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    NumberWrapper.parseFloat = function(text) {
      return parseFloat(text);
    };
    Object.defineProperty(NumberWrapper, "NaN", {
      get: function() {
        return NaN;
      },
      enumerable: true,
      configurable: true
    });
    NumberWrapper.isNumeric = function(value) {
      return !isNaN(value - parseFloat(value));
    };
    NumberWrapper.isNaN = function(value) {
      return isNaN(value);
    };
    NumberWrapper.isInteger = function(value) {
      return Number.isInteger(value);
    };
    return NumberWrapper;
  }());
  exports.NumberWrapper = NumberWrapper;
  exports.RegExp = _global.RegExp;
  var FunctionWrapper = (function() {
    function FunctionWrapper() {}
    FunctionWrapper.apply = function(fn, posArgs) {
      return fn.apply(null, posArgs);
    };
    FunctionWrapper.bind = function(fn, scope) {
      return fn.bind(scope);
    };
    return FunctionWrapper;
  }());
  exports.FunctionWrapper = FunctionWrapper;
  function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  exports.looseIdentical = looseIdentical;
  function getMapKey(value) {
    return value;
  }
  exports.getMapKey = getMapKey;
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  exports.normalizeBlank = normalizeBlank;
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  exports.normalizeBool = normalizeBool;
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  exports.isJsObject = isJsObject;
  function print(obj) {
    console.log(obj);
  }
  exports.print = print;
  function warn(obj) {
    console.warn(obj);
  }
  exports.warn = warn;
  var Json = (function() {
    function Json() {}
    Json.parse = function(s) {
      return _global.JSON.parse(s);
    };
    Json.stringify = function(data) {
      return _global.JSON.stringify(data, null, 2);
    };
    return Json;
  }());
  exports.Json = Json;
  var DateWrapper = (function() {
    function DateWrapper() {}
    DateWrapper.create = function(year, month, day, hour, minutes, seconds, milliseconds) {
      if (month === void 0) {
        month = 1;
      }
      if (day === void 0) {
        day = 1;
      }
      if (hour === void 0) {
        hour = 0;
      }
      if (minutes === void 0) {
        minutes = 0;
      }
      if (seconds === void 0) {
        seconds = 0;
      }
      if (milliseconds === void 0) {
        milliseconds = 0;
      }
      return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function(str) {
      return new exports.Date(str);
    };
    DateWrapper.fromMillis = function(ms) {
      return new exports.Date(ms);
    };
    DateWrapper.toMillis = function(date) {
      return date.getTime();
    };
    DateWrapper.now = function() {
      return new exports.Date();
    };
    DateWrapper.toJson = function(date) {
      return date.toJSON();
    };
    return DateWrapper;
  }());
  exports.DateWrapper = DateWrapper;
  function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
      var name = parts.shift();
      if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
        obj = obj[name];
      } else {
        obj = obj[name] = {};
      }
    }
    if (obj === undefined || obj === null) {
      obj = {};
    }
    obj[parts.shift()] = value;
  }
  exports.setValueOnPath = setValueOnPath;
  var _symbolIterator = null;
  function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
      if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
        _symbolIterator = Symbol.iterator;
      } else {
        var keys = Object.getOwnPropertyNames(Map.prototype);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
      fnArgNames.push(argName);
      fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  exports.evalExpression = evalExpression;
  function isPrimitive(obj) {
    return !isJsObject(obj);
  }
  exports.isPrimitive = isPrimitive;
  function hasConstructor(value, type) {
    return value.constructor === type;
  }
  exports.hasConstructor = hasConstructor;
  function escape(s) {
    return _global.encodeURI(s);
  }
  exports.escape = escape;
  function escapeRegExp(s) {
    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  exports.escapeRegExp = escapeRegExp;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/src/xhr/xhr_impl.js", ["@angular/compiler", "@angular/core", "../facade/lang"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var compiler_1 = $__require('@angular/compiler');
  var core_1 = $__require('@angular/core');
  var lang_1 = $__require('../facade/lang');
  var XHRImpl = (function(_super) {
    __extends(XHRImpl, _super);
    function XHRImpl() {
      _super.apply(this, arguments);
    }
    XHRImpl.prototype.get = function(url) {
      var resolve;
      var reject;
      var promise = new Promise(function(res, rej) {
        resolve = res;
        reject = rej;
      });
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'text';
      xhr.onload = function() {
        var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;
        var status = xhr.status === 1223 ? 204 : xhr.status;
        if (status === 0) {
          status = response ? 200 : 0;
        }
        if (200 <= status && status <= 300) {
          resolve(response);
        } else {
          reject("Failed to load " + url);
        }
      };
      xhr.onerror = function() {
        reject("Failed to load " + url);
      };
      xhr.send();
      return promise;
    };
    XHRImpl.decorators = [{type: core_1.Injectable}];
    return XHRImpl;
  }(compiler_1.XHR));
  exports.XHRImpl = XHRImpl;
  return module.exports;
});

System.registerDynamic("node_modules/@angular/platform-browser-dynamic/index.js", ["@angular/compiler", "@angular/core", "@angular/platform-browser", "./core_private", "./src/platform_providers", "./src/xhr/xhr_cache", "./src/xhr/xhr_impl"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this || self,
      GLOBAL = global;
  var compiler_1 = $__require('@angular/compiler');
  var core_1 = $__require('@angular/core');
  var platform_browser_1 = $__require('@angular/platform-browser');
  var core_private_1 = $__require('./core_private');
  var platform_providers_1 = $__require('./src/platform_providers');
  var xhr_cache_1 = $__require('./src/xhr/xhr_cache');
  var xhr_impl_1 = $__require('./src/xhr/xhr_impl');
  exports.BROWSER_APP_COMPILER_PROVIDERS = [];
  exports.CACHED_TEMPLATE_PROVIDER = [{
    provide: compiler_1.XHR,
    useClass: xhr_cache_1.CachedXHR
  }];
  exports.platformBrowserDynamic = core_1.createPlatformFactory(compiler_1.platformCoreDynamic, 'browserDynamic', platform_providers_1.INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);
  exports.browserDynamicPlatform = exports.platformBrowserDynamic;
  function bootstrap(appComponentType, customProviders) {
    var compilerOptions;
    var declarations = [];
    var entryComponents = [];
    var deprecationMessages = [];
    var deprecatedConfiguration = compiler_1.analyzeAppProvidersForDeprecatedConfiguration(customProviders);
    declarations = deprecatedConfiguration.moduleDeclarations.concat(declarations);
    compilerOptions = deprecatedConfiguration.compilerOptions;
    deprecationMessages = deprecatedConfiguration.deprecationMessages;
    var DynamicModule = (function() {
      function DynamicModule() {}
      DynamicModule.decorators = [{
        type: core_1.NgModule,
        args: [{
          providers: customProviders,
          declarations: declarations.concat([appComponentType]),
          imports: [platform_browser_1.BrowserModule],
          entryComponents: entryComponents,
          bootstrap: [appComponentType],
          schemas: [core_1.CUSTOM_ELEMENTS_SCHEMA]
        }]
      }];
      return DynamicModule;
    }());
    return exports.platformBrowserDynamic().bootstrapModule(DynamicModule, compilerOptions).then(function(moduleRef) {
      var console = moduleRef.injector.get(core_private_1.Console);
      deprecationMessages.forEach(function(msg) {
        return console.warn(msg);
      });
      var appRef = moduleRef.injector.get(core_1.ApplicationRef);
      return appRef.components[0];
    });
  }
  exports.bootstrap = bootstrap;
  function bootstrapWorkerUi(workerScriptUri, customProviders) {
    if (customProviders === void 0) {
      customProviders = [];
    }
    return Promise.resolve(platform_browser_1.platformWorkerUi([{
      provide: platform_browser_1.WORKER_SCRIPT,
      useValue: workerScriptUri
    }].concat(customProviders)));
  }
  exports.bootstrapWorkerUi = bootstrapWorkerUi;
  exports.platformWorkerAppDynamic = core_1.createPlatformFactory(compiler_1.platformCoreDynamic, 'workerAppDynamic', [{
    provide: core_1.COMPILER_OPTIONS,
    useValue: {providers: [{
        provide: compiler_1.XHR,
        useClass: xhr_impl_1.XHRImpl
      }]},
    multi: true
  }]);
  exports.workerAppDynamicPlatform = exports.platformWorkerAppDynamic;
  function bootstrapWorkerApp(appComponentType, customProviders) {
    console.warn('bootstrapWorkerApp is deprecated. Create an @NgModule that includes the `WorkerAppModule` and use `bootstrapModule` with the `workerAppDynamicPlatform()` instead.');
    var deprecatedConfiguration = compiler_1.analyzeAppProvidersForDeprecatedConfiguration(customProviders);
    var declarations = [deprecatedConfiguration.moduleDeclarations.concat([appComponentType])];
    var DynamicModule = (function() {
      function DynamicModule() {}
      DynamicModule.decorators = [{
        type: core_1.NgModule,
        args: [{
          providers: customProviders,
          declarations: declarations,
          imports: [platform_browser_1.WorkerAppModule],
          bootstrap: [appComponentType]
        }]
      }];
      return DynamicModule;
    }());
    return exports.platformWorkerAppDynamic().bootstrapModule(DynamicModule, deprecatedConfiguration.compilerOptions).then(function(moduleRef) {
      var console = moduleRef.injector.get(core_private_1.Console);
      deprecatedConfiguration.deprecationMessages.forEach(function(msg) {
        return console.warn(msg);
      });
      var appRef = moduleRef.injector.get(core_1.ApplicationRef);
      return appRef.components[0];
    });
  }
  exports.bootstrapWorkerApp = bootstrapWorkerApp;
  function normalizeArray(arr) {
    return arr ? arr : [];
  }
  return module.exports;
});

/**
 * System configuration for Angular 2 samples
 * Adjust as necessary for your application needs.
 */
(function(global) {
    // map tells the System loader where to look for things
    var map = {
        'app':                        'app', // 'dist',
        '@angular':                   'node_modules/@angular',
        'angular2-in-memory-web-api': 'node_modules/angular2-in-memory-web-api',
        'rxjs':                       'node_modules/rxjs',
        //'rxjs/*':                       'node_modules/rxjs/bundles/Rx.umd.js',
        //"rxjsbundle":                 "node_modules/rxjs/bundles/Rx.js"
    };
    // packages tells the System loader how to load when no filename and/or no extension
    var packages = {
        'app':                        { main: 'main.js',  defaultExtension: 'js' },
        'rxjs': {
            defaultExtension: 'js',
            // map: {
            //     "rxjs/*": "rxjsbundle"
            // },
            // bundles: {
            //     "rxjsbundle": ["rxjs/Subject"]
            // }
        },
        'angular2-in-memory-web-api': { main: 'index.js', defaultExtension: 'js' },
    };
    var ngPackageNames = [
        'common',
        'compiler',
        'core',
        'forms',
        'http',
        'platform-browser',
        'platform-browser-dynamic',
        'router',
        'router-deprecated',
        'upgrade',
    ];
    // Individual files (~300 requests):
    function packIndex(pkgName) {
        packages['@angular/'+pkgName] = { main: 'index.js', defaultExtension: 'js' };
    }
    // Bundled (~40 requests):
    function packUmd(pkgName) {
        packages['@angular/'+pkgName] = { main: '/bundles/' + pkgName + '.umd.js', defaultExtension: 'js' };
    }
    // Most environments should use UMD; some (Karma) need the individual index files
    var setPackageConfig = System.packageWithIndex ? packIndex : packUmd;
    // Add package entries for angular packages
    ngPackageNames.forEach(packIndex);
    var config = {
        map: map,
        packages: packages,
        // bundles: {
        //     "rxjsbundle": [
        //         "rxjs/Subject",
        //         "rxjs/Observable",
        //         "rxjs/operator/toPromise",
        //         "rxjs/observable/PromiseObservable",
        //     ],
        // },
    };
    System.config(config);
})(this);
